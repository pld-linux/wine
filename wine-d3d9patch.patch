diff -urN wine.20050419/configure wine.20050419.dx9/configure
--- wine.20050419/configure	2005-04-19 06:54:44.000000000 -0600
+++ wine.20050419.dx9/configure	2005-04-20 03:02:02.000000000 -0600
@@ -20054,7 +20054,7 @@
 MAKE_PROG_RULES=programs/Makeprog.rules
 
 
-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ac_config_files="$ac_config_files Make.rules dlls/Makedll.rules dlls/Maketest.rules libs/Makelib.rules programs/Makeprog.rules Makefile dlls/Makefile dlls/advapi32/Makefile dlls/advapi32/tests/Makefile dlls/advpack/Makefile dlls/advpack/tests/Makefile dlls/amstream/Makefile dlls/atl/Makefile dlls/avicap32/Makefile dlls/avifil32/Makefile dlls/cabinet/Makefile dlls/capi2032/Makefile dlls/cards/Makefile dlls/cfgmgr32/Makefile dlls/comcat/Makefile dlls/comctl32/Makefile dlls/comctl32/tests/Makefile dlls/commdlg/Makefile dlls/crtdll/Makefile dlls/crypt32/Makefile dlls/cryptdll/Makefile dlls/ctl3d/Makefile dlls/d3d8/Makefile dlls/d3d9/Makefile dlls/d3dim/Makefile dlls/d3drm/Makefile dlls/d3dx8/Makefile dlls/d3dxof/Makefile dlls/dbghelp/Makefile dlls/dciman32/Makefile dlls/ddraw/Makefile dlls/ddraw/tests/Makefile dlls/devenum/Makefile dlls/dinput/Makefile dlls/dinput8/Makefile dlls/dmband/Makefile dlls/dmcompos/Makefile dlls/dmime/Makefile dlls/dmloader/Makefile dlls/dmscript/Makefile dlls/dmstyle/Makefile dlls/dmsynth/Makefile dlls/dmusic/Makefile dlls/dmusic32/Makefile dlls/dplay/Makefile dlls/dplayx/Makefile dlls/dpnet/Makefile dlls/dpnhpast/Makefile dlls/dsound/Makefile dlls/dsound/tests/Makefile dlls/dswave/Makefile dlls/dxdiagn/Makefile dlls/dxerr8/Makefile dlls/dxerr9/Makefile dlls/dxguid/Makefile dlls/gdi/Makefile dlls/gdi/tests/Makefile dlls/glu32/Makefile dlls/glut32/Makefile dlls/hhctrl.ocx/Makefile dlls/iccvid/Makefile dlls/icmp/Makefile dlls/ifsmgr.vxd/Makefile dlls/imagehlp/Makefile dlls/imm32/Makefile dlls/iphlpapi/Makefile dlls/iphlpapi/tests/Makefile dlls/itss/Makefile dlls/kernel/Makefile dlls/kernel/tests/Makefile dlls/lzexpand/Makefile dlls/lzexpand/tests/Makefile dlls/mapi32/Makefile dlls/mapi32/tests/Makefile dlls/mlang/Makefile dlls/mlang/tests/Makefile dlls/mmdevldr.vxd/Makefile dlls/monodebg.vxd/Makefile dlls/mpr/Makefile dlls/msacm/Makefile dlls/msacm/imaadp32/Makefile dlls/msacm/msadp32/Makefile dlls/msacm/msg711/Makefile dlls/msacm/winemp3/Makefile dlls/msacm/tests/Makefile dlls/mscms/Makefile dlls/mscms/tests/Makefile dlls/msdmo/Makefile dlls/mshtml/Makefile dlls/msi/Makefile dlls/msi/tests/Makefile dlls/msimg32/Makefile dlls/msisys/Makefile dlls/msnet32/Makefile dlls/msrle32/Makefile dlls/msvcrt/Makefile dlls/msvcrt/tests/Makefile dlls/msvcrt20/Makefile dlls/msvcrt40/Makefile dlls/msvcrtd/Makefile dlls/msvcrtd/tests/Makefile dlls/msvidc32/Makefile dlls/msvideo/Makefile dlls/mswsock/Makefile dlls/netapi32/Makefile dlls/netapi32/tests/Makefile dlls/newdev/Makefile dlls/ntdll/Makefile dlls/ntdll/tests/Makefile dlls/odbc32/Makefile dlls/ole32/Makefile dlls/ole32/tests/Makefile dlls/oleacc/Makefile dlls/oleaut32/Makefile dlls/oleaut32/tests/Makefile dlls/olecli/Makefile dlls/oledlg/Makefile dlls/olepro32/Makefile dlls/olesvr/Makefile dlls/opengl32/Makefile dlls/psapi/Makefile dlls/psapi/tests/Makefile dlls/qcap/Makefile dlls/quartz/Makefile dlls/quartz/tests/Makefile dlls/rasapi32/Makefile dlls/riched20/Makefile dlls/richedit/Makefile dlls/rpcrt4/Makefile dlls/rpcrt4/tests/Makefile dlls/rsabase/Makefile dlls/rsabase/tests/Makefile dlls/rsaenh/Makefile dlls/rsaenh/tests/Makefile dlls/secur32/Makefile dlls/sensapi/Makefile dlls/serialui/Makefile dlls/setupapi/Makefile dlls/shdocvw/Makefile dlls/shell32/Makefile dlls/shell32/tests/Makefile dlls/shfolder/Makefile dlls/shlwapi/Makefile dlls/shlwapi/tests/Makefile dlls/snmpapi/Makefile dlls/stdole32.tlb/Makefile dlls/sti/Makefile dlls/strmiids/Makefile dlls/tapi32/Makefile dlls/ttydrv/Makefile dlls/twain/Makefile dlls/unicows/Makefile dlls/url/Makefile dlls/urlmon/Makefile dlls/urlmon/tests/Makefile dlls/user/Makefile dlls/user/tests/Makefile dlls/uuid/Makefile dlls/uxtheme/Makefile dlls/vdhcp.vxd/Makefile dlls/vdmdbg/Makefile dlls/version/Makefile dlls/version/tests/Makefile dlls/vmm.vxd/Makefile dlls/vnbt.vxd/Makefile dlls/vnetbios.vxd/Makefile dlls/vtdapi.vxd/Makefile dlls/vwin32.vxd/Makefile dlls/win32s/Makefile dlls/winaspi/Makefile dlls/wined3d/Makefile dlls/winedos/Makefile dlls/wineps/Makefile dlls/wininet/Makefile dlls/wininet/tests/Makefile dlls/winmm/Makefile dlls/winmm/joystick/Makefile dlls/winmm/mcianim/Makefile dlls/winmm/mciavi/Makefile dlls/winmm/mcicda/Makefile dlls/winmm/mciseq/Makefile dlls/winmm/mciwave/Makefile dlls/winmm/midimap/Makefile dlls/winmm/tests/Makefile dlls/winmm/wavemap/Makefile dlls/winmm/winealsa/Makefile dlls/winmm/winearts/Makefile dlls/winmm/wineaudioio/Makefile dlls/winmm/winejack/Makefile dlls/winmm/winenas/Makefile dlls/winmm/wineoss/Makefile dlls/winnls/Makefile dlls/winsock/Makefile dlls/winsock/tests/Makefile dlls/winspool/Makefile dlls/winspool/tests/Makefile dlls/wintab32/Makefile dlls/wintrust/Makefile dlls/wow32/Makefile dlls/wsock32/Makefile dlls/wtsapi32/Makefile dlls/x11drv/Makefile documentation/Makefile fonts/Makefile include/Makefile libs/Makefile libs/port/Makefile libs/unicode/Makefile libs/wine/Makefile libs/wpp/Makefile loader/Makefile programs/Makefile programs/avitools/Makefile programs/clock/Makefile programs/cmdlgtst/Makefile programs/control/Makefile programs/expand/Makefile programs/msiexec/Makefile programs/notepad/Makefile programs/progman/Makefile programs/regedit/Makefile programs/regsvr32/Makefile programs/rpcss/Makefile programs/rundll32/Makefile programs/start/Makefile programs/taskmgr/Makefile programs/uninstaller/Makefile programs/view/Makefile programs/wcmd/Makefile programs/wineboot/Makefile programs/winebrowser/Makefile programs/winecfg/Makefile programs/wineconsole/Makefile programs/winedbg/Makefile programs/winefile/Makefile programs/winemenubuilder/Makefile programs/winemine/Makefile programs/winepath/Makefile programs/winetest/Makefile programs/winevdm/Makefile programs/winhelp/Makefile programs/winver/Makefile server/Makefile tools/Makefile tools/widl/Makefile tools/winapi/Makefile tools/winebuild/Makefile tools/winedump/Makefile tools/winegcc/Makefile tools/wmc/Makefile tools/wrc/Makefile"
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ac_config_files="$ac_config_files Make.rules dlls/Makedll.rules dlls/Maketest.rules libs/Makelib.rules programs/Makeprog.rules Makefile dlls/Makefile dlls/advapi32/Makefile dlls/advapi32/tests/Makefile dlls/advpack/Makefile dlls/advpack/tests/Makefile dlls/amstream/Makefile dlls/atl/Makefile dlls/avicap32/Makefile dlls/avifil32/Makefile dlls/cabinet/Makefile dlls/capi2032/Makefile dlls/cards/Makefile dlls/cfgmgr32/Makefile dlls/comcat/Makefile dlls/comctl32/Makefile dlls/comctl32/tests/Makefile dlls/commdlg/Makefile dlls/crtdll/Makefile dlls/crypt32/Makefile dlls/cryptdll/Makefile dlls/ctl3d/Makefile dlls/d3d8/Makefile dlls/d3d9/Makefile dlls/d3dim/Makefile dlls/d3drm/Makefile dlls/d3dx8/Makefile dlls/d3dx9/Makefile dlls/d3dxof/Makefile dlls/dbghelp/Makefile dlls/dciman32/Makefile dlls/ddraw/Makefile dlls/ddraw/tests/Makefile dlls/devenum/Makefile dlls/dinput/Makefile dlls/dinput8/Makefile dlls/dmband/Makefile dlls/dmcompos/Makefile dlls/dmime/Makefile dlls/dmloader/Makefile dlls/dmscript/Makefile dlls/dmstyle/Makefile dlls/dmsynth/Makefile dlls/dmusic/Makefile dlls/dmusic32/Makefile dlls/dplay/Makefile dlls/dplayx/Makefile dlls/dpnet/Makefile dlls/dpnhpast/Makefile dlls/dsound/Makefile dlls/dsound/tests/Makefile dlls/dswave/Makefile dlls/dxdiagn/Makefile dlls/dxerr8/Makefile dlls/dxerr9/Makefile dlls/dxguid/Makefile dlls/gdi/Makefile dlls/gdi/tests/Makefile dlls/glu32/Makefile dlls/glut32/Makefile dlls/hhctrl.ocx/Makefile dlls/iccvid/Makefile dlls/icmp/Makefile dlls/ifsmgr.vxd/Makefile dlls/imagehlp/Makefile dlls/imm32/Makefile dlls/iphlpapi/Makefile dlls/iphlpapi/tests/Makefile dlls/itss/Makefile dlls/kernel/Makefile dlls/kernel/tests/Makefile dlls/lzexpand/Makefile dlls/lzexpand/tests/Makefile dlls/mapi32/Makefile dlls/mapi32/tests/Makefile dlls/mlang/Makefile dlls/mlang/tests/Makefile dlls/mmdevldr.vxd/Makefile dlls/monodebg.vxd/Makefile dlls/mpr/Makefile dlls/msacm/Makefile dlls/msacm/imaadp32/Makefile dlls/msacm/msadp32/Makefile dlls/msacm/msg711/Makefile dlls/msacm/winemp3/Makefile dlls/msacm/tests/Makefile dlls/mscms/Makefile dlls/mscms/tests/Makefile dlls/msdmo/Makefile dlls/mshtml/Makefile dlls/msi/Makefile dlls/msi/tests/Makefile dlls/msimg32/Makefile dlls/msisys/Makefile dlls/msnet32/Makefile dlls/msrle32/Makefile dlls/msvcrt/Makefile dlls/msvcrt/tests/Makefile dlls/msvcrt20/Makefile dlls/msvcrt40/Makefile dlls/msvcrtd/Makefile dlls/msvcrtd/tests/Makefile dlls/msvidc32/Makefile dlls/msvideo/Makefile dlls/mswsock/Makefile dlls/netapi32/Makefile dlls/netapi32/tests/Makefile dlls/newdev/Makefile dlls/ntdll/Makefile dlls/ntdll/tests/Makefile dlls/odbc32/Makefile dlls/ole32/Makefile dlls/ole32/tests/Makefile dlls/oleacc/Makefile dlls/oleaut32/Makefile dlls/oleaut32/tests/Makefile dlls/olecli/Makefile dlls/oledlg/Makefile dlls/olepro32/Makefile dlls/olesvr/Makefile dlls/opengl32/Makefile dlls/psapi/Makefile dlls/psapi/tests/Makefile dlls/qcap/Makefile dlls/quartz/Makefile dlls/quartz/tests/Makefile dlls/rasapi32/Makefile dlls/riched20/Makefile dlls/richedit/Makefile dlls/rpcrt4/Makefile dlls/rpcrt4/tests/Makefile dlls/rsabase/Makefile dlls/rsabase/tests/Makefile dlls/rsaenh/Makefile dlls/rsaenh/tests/Makefile dlls/secur32/Makefile dlls/sensapi/Makefile dlls/serialui/Makefile dlls/setupapi/Makefile dlls/shdocvw/Makefile dlls/shell32/Makefile dlls/shell32/tests/Makefile dlls/shfolder/Makefile dlls/shlwapi/Makefile dlls/shlwapi/tests/Makefile dlls/snmpapi/Makefile dlls/stdole32.tlb/Makefile dlls/sti/Makefile dlls/strmiids/Makefile dlls/tapi32/Makefile dlls/ttydrv/Makefile dlls/twain/Makefile dlls/unicows/Makefile dlls/url/Makefile dlls/urlmon/Makefile dlls/urlmon/tests/Makefile dlls/user/Makefile dlls/user/tests/Makefile dlls/uuid/Makefile dlls/uxtheme/Makefile dlls/vdhcp.vxd/Makefile dlls/vdmdbg/Makefile dlls/version/Makefile dlls/version/tests/Makefile dlls/vmm.vxd/Makefile dlls/vnbt.vxd/Makefile dlls/vnetbios.vxd/Makefile dlls/vtdapi.vxd/Makefile dlls/vwin32.vxd/Makefile dlls/win32s/Makefile dlls/winaspi/Makefile dlls/wined3d/Makefile dlls/winedos/Makefile dlls/wineps/Makefile dlls/wininet/Makefile dlls/wininet/tests/Makefile dlls/winmm/Makefile dlls/winmm/joystick/Makefile dlls/winmm/mcianim/Makefile dlls/winmm/mciavi/Makefile dlls/winmm/mcicda/Makefile dlls/winmm/mciseq/Makefile dlls/winmm/mciwave/Makefile dlls/winmm/midimap/Makefile dlls/winmm/tests/Makefile dlls/winmm/wavemap/Makefile dlls/winmm/winealsa/Makefile dlls/winmm/winearts/Makefile dlls/winmm/wineaudioio/Makefile dlls/winmm/winejack/Makefile dlls/winmm/winenas/Makefile dlls/winmm/wineoss/Makefile dlls/winnls/Makefile dlls/winsock/Makefile dlls/winsock/tests/Makefile dlls/winspool/Makefile dlls/winspool/tests/Makefile dlls/wintab32/Makefile dlls/wintrust/Makefile dlls/wow32/Makefile dlls/wsock32/Makefile dlls/wtsapi32/Makefile dlls/x11drv/Makefile documentation/Makefile fonts/Makefile include/Makefile libs/Makefile libs/port/Makefile libs/unicode/Makefile libs/wine/Makefile libs/wpp/Makefile loader/Makefile programs/Makefile programs/avitools/Makefile programs/clock/Makefile programs/cmdlgtst/Makefile programs/control/Makefile programs/expand/Makefile programs/msiexec/Makefile programs/notepad/Makefile programs/progman/Makefile programs/regedit/Makefile programs/regsvr32/Makefile programs/rpcss/Makefile programs/rundll32/Makefile programs/start/Makefile programs/taskmgr/Makefile programs/uninstaller/Makefile programs/view/Makefile programs/wcmd/Makefile programs/wineboot/Makefile programs/winebrowser/Makefile programs/winecfg/Makefile programs/wineconsole/Makefile programs/winedbg/Makefile programs/winefile/Makefile programs/winemenubuilder/Makefile programs/winemine/Makefile programs/winepath/Makefile programs/winetest/Makefile programs/winevdm/Makefile programs/winhelp/Makefile programs/winver/Makefile server/Makefile tools/Makefile tools/widl/Makefile tools/winapi/Makefile tools/winebuild/Makefile tools/winedump/Makefile tools/winegcc/Makefile tools/wmc/Makefile tools/wrc/Makefile"
 
 
 cat >confcache <<\_ACEOF
@@ -20617,6 +20617,7 @@
   "dlls/d3dim/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/d3dim/Makefile" ;;
   "dlls/d3drm/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/d3drm/Makefile" ;;
   "dlls/d3dx8/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/d3dx8/Makefile" ;;
+  "dlls/d3dx9/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/d3dx9/Makefile" ;;
   "dlls/d3dxof/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/d3dxof/Makefile" ;;
   "dlls/dbghelp/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/dbghelp/Makefile" ;;
   "dlls/dciman32/Makefile" ) CONFIG_FILES="$CONFIG_FILES dlls/dciman32/Makefile" ;;
diff -urN wine.20050419/configure.ac wine.20050419.dx9/configure.ac
--- wine.20050419/configure.ac	2005-03-28 02:58:45.000000000 -0700
+++ wine.20050419.dx9/configure.ac	2005-04-20 01:52:56.000000000 -0600
@@ -1536,6 +1536,7 @@
 dlls/d3dim/Makefile
 dlls/d3drm/Makefile
 dlls/d3dx8/Makefile
+dlls/d3dx9/Makefile
 dlls/d3dxof/Makefile
 dlls/dbghelp/Makefile
 dlls/dciman32/Makefile
diff -urN wine.20050419/dlls/Makefile.in wine.20050419.dx9/dlls/Makefile.in
--- wine.20050419/dlls/Makefile.in	2005-03-05 04:19:14.000000000 -0700
+++ wine.20050419.dx9/dlls/Makefile.in	2005-04-20 01:52:56.000000000 -0600
@@ -9,7 +9,7 @@
 
 GLU32FILES = glu32
 GLUT32FILES = glut32
-OPENGLFILES = d3d8 d3d9 d3dx8 opengl32 wined3d
+OPENGLFILES = d3d8 d3d9 d3dx8 d3dx9 opengl32 wined3d
 XFILES = ddraw x11drv
 EXTRADIRS = @GLU32FILES@ @GLUT32FILES@ @OPENGLFILES@ @XFILES@
 
@@ -174,6 +174,7 @@
 	d3d8 \
 	d3d9 \
 	d3dx8 \
+	d3dx9 \
 	ddraw \
 	dxerr8 \
 	dxerr9 \
@@ -494,6 +495,9 @@
 d3dx8.dll.so: d3dx8/d3dx8.dll.so
 	$(RM) $@ && $(LN_S) d3dx8/d3dx8.dll.so $@
 
+d3dx9.dll.so: d3dx9/d3dx9.dll.so
+	$(RM) $@ && $(LN_S) d3dx9/d3dx9.dll.so $@
+
 d3dxof.dll.so: d3dxof/d3dxof.dll.so
 	$(RM) $@ && $(LN_S) d3dxof/d3dxof.dll.so $@
 
@@ -1003,7 +1007,6 @@
 libuuid.a: uuid/libuuid.a
 	$(RM) $@ && $(LN_S) uuid/libuuid.a $@
 
-
 # Import libraries
 
 IMPORT_LIBS = \
@@ -1029,6 +1032,7 @@
 	libd3dim.$(IMPLIBEXT) \
 	libd3drm.$(IMPLIBEXT) \
 	libd3dx8.$(IMPLIBEXT) \
+	libd3dx9.$(IMPLIBEXT) \
 	libd3dxof.$(IMPLIBEXT) \
 	libdbghelp.$(IMPLIBEXT) \
 	libdciman32.$(IMPLIBEXT) \
@@ -1256,6 +1260,11 @@
 libd3dx8.a: d3dx8/d3dx8.spec.def
 	$(DLLTOOL) -k -l $@ -d d3dx8/d3dx8.spec.def
 
+libd3dx9.def: d3dx9/d3dx9.spec.def
+	$(RM) $@ && $(LN_S) d3dx9/d3dx9.spec.def $@
+libd3dx9.a: d3dx9/d3dx9.spec.def
+	$(DLLTOOL) -k -l $@ -d d3dx9/d3dx9.spec.def
+
 libd3dxof.def: d3dxof/d3dxof.spec.def
 	$(RM) $@ && $(LN_S) d3dxof/d3dxof.spec.def $@
 libd3dxof.a: d3dxof/d3dxof.spec.def
@@ -1823,6 +1832,7 @@
 d3dim/d3dim.spec.def: $(WINEBUILD)
 d3drm/d3drm.spec.def: $(WINEBUILD)
 d3dx8/d3dx8.spec.def: $(WINEBUILD)
+d3dx9/d3dx9.spec.def: $(WINEBUILD)
 d3dxof/d3dxof.spec.def: $(WINEBUILD)
 dbghelp/dbghelp.spec.def: $(WINEBUILD)
 dciman32/dciman32.spec.def: $(WINEBUILD)
@@ -1960,6 +1970,7 @@
 d3dim/d3dim.dll.so: d3dim
 d3drm/d3drm.dll.so: d3drm
 d3dx8/d3dx8.dll.so: d3dx8
+d3dx9/d3dx9.dll.so: d3dx9
 d3dxof/d3dxof.dll.so: d3dxof
 dbghelp/dbghelp.dll.so: dbghelp
 dciman32/dciman32.dll.so: dciman32
diff -urN wine.20050419/dlls/d3d8/d3d8_private.h wine.20050419.dx9/dlls/d3d8/d3d8_private.h
--- wine.20050419/dlls/d3d8/d3d8_private.h	2005-03-23 06:15:20.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d8/d3d8_private.h	2005-04-20 01:52:56.000000000 -0600
@@ -596,6 +596,9 @@
     /* OpenGL/GLX related */
     GLXContext              swap_ctx;
     Drawable                swap_drawable;
+
+    /* ready for when we move over to wined3d */
+    IWineD3DSwapChain      *wineD3DSwapChain;
 };
 
 /* IUnknown: */
diff -urN wine.20050419/dlls/d3d8/device.c wine.20050419.dx9/dlls/d3d8/device.c
--- wine.20050419/dlls/d3d8/device.c	2005-03-23 06:15:20.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d8/device.c	2005-04-20 01:52:56.000000000 -0600
@@ -70,6 +70,12 @@
     memcpy(gl_mat, (mat), 16 * sizeof(float));                                              \
 } while (0)
 
+
+/*internal function, (static) */
+
+HRESULT  WINAPI IDirect3DDevice8Impl_CreateSurface(LPDIRECT3DDEVICE8 , UINT , UINT , D3DFORMAT , BOOL Lockable,
+ IDirect3DSurface8** ppSurface, D3DRESOURCETYPE , UINT ,D3DPOOL , D3DMULTISAMPLE_TYPE  );
+
 /* Apply the current values to the specified texture stage */
 void setupTextureStates(LPDIRECT3DDEVICE8 iface, DWORD Stage, DWORD Flags) {
     IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
@@ -352,9 +358,90 @@
 }
 HRESULT  WINAPI  IDirect3DDevice8Impl_GetDeviceCaps(LPDIRECT3DDEVICE8 iface, D3DCAPS8* pCaps) {
     IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
-    FIXME("(%p) : stub, calling idirect3d for now\n", This);
-    IDirect3D8Impl_GetDeviceCaps((LPDIRECT3D8) This->direct3d8, This->adapterNo, This->devType, pCaps);
-    return D3D_OK;
+    HRESULT hrc = D3D_OK;
+    WINED3DCAPS *pWineCaps = NULL;
+
+    if(NULL == pCaps){
+        return D3DERR_INVALIDCALL;
+    }
+    
+    pWineCaps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WINED3DCAPS));
+    if(pWineCaps == NULL){
+        return D3DERR_INVALIDCALL; /*well this is what MSDN says to return*/
+    }
+    pWineCaps->DeviceType                        = &pCaps->DeviceType;
+    pWineCaps->AdapterOrdinal                    = &pCaps->AdapterOrdinal;
+    pWineCaps->Caps                              = &pCaps->Caps;
+    pWineCaps->Caps2                             = &pCaps->Caps2;
+    pWineCaps->Caps3                             = &pCaps->Caps3;
+    pWineCaps->PresentationIntervals             = &pCaps->PresentationIntervals;
+    pWineCaps->CursorCaps                        = &pCaps->CursorCaps;
+    pWineCaps->DevCaps                           = &pCaps->DevCaps;
+    pWineCaps->PrimitiveMiscCaps                 = &pCaps->PrimitiveMiscCaps;
+    pWineCaps->RasterCaps                        = &pCaps->RasterCaps;
+    pWineCaps->ZCmpCaps                          = &pCaps->ZCmpCaps;
+    pWineCaps->SrcBlendCaps                      = &pCaps->SrcBlendCaps;
+    pWineCaps->DestBlendCaps                     = &pCaps->DestBlendCaps;
+    pWineCaps->AlphaCmpCaps                      = &pCaps->AlphaCmpCaps;
+    pWineCaps->ShadeCaps                         = &pCaps->ShadeCaps;
+    pWineCaps->TextureCaps                       = &pCaps->TextureCaps;
+    pWineCaps->TextureFilterCaps                 = &pCaps->TextureFilterCaps;
+    pWineCaps->CubeTextureFilterCaps             = &pCaps->CubeTextureFilterCaps;
+    pWineCaps->VolumeTextureFilterCaps           = &pCaps->VolumeTextureFilterCaps;
+    pWineCaps->TextureAddressCaps                = &pCaps->TextureAddressCaps;
+    pWineCaps->VolumeTextureAddressCaps          = &pCaps->VolumeTextureAddressCaps;
+    pWineCaps->LineCaps                          = &pCaps->LineCaps;
+    pWineCaps->MaxTextureWidth                   = &pCaps->MaxTextureWidth;
+    pWineCaps->MaxTextureHeight                  = &pCaps->MaxTextureHeight;
+    pWineCaps->MaxVolumeExtent                   = &pCaps->MaxVolumeExtent;
+    pWineCaps->MaxTextureRepeat                  = &pCaps->MaxTextureRepeat;
+    pWineCaps->MaxTextureAspectRatio             = &pCaps->MaxTextureAspectRatio;
+    pWineCaps->MaxAnisotropy                     = &pCaps->MaxAnisotropy;
+    pWineCaps->MaxVertexW                        = &pCaps->MaxVertexW;
+    pWineCaps->GuardBandLeft                     = &pCaps->GuardBandLeft;
+    pWineCaps->GuardBandTop                      = &pCaps->GuardBandTop;
+    pWineCaps->GuardBandRight                    = &pCaps->GuardBandRight;
+    pWineCaps->GuardBandBottom                   = &pCaps->GuardBandBottom;
+    pWineCaps->ExtentsAdjust                     = &pCaps->ExtentsAdjust;
+    pWineCaps->StencilCaps                       = &pCaps->StencilCaps;
+    pWineCaps->FVFCaps                           = &pCaps->FVFCaps;
+    pWineCaps->TextureOpCaps                     = &pCaps->TextureOpCaps;
+    pWineCaps->MaxTextureBlendStages             = &pCaps->MaxTextureBlendStages;
+    pWineCaps->MaxSimultaneousTextures           = &pCaps->MaxSimultaneousTextures;
+    pWineCaps->VertexProcessingCaps              = &pCaps->VertexProcessingCaps;
+    pWineCaps->MaxActiveLights                   = &pCaps->MaxActiveLights;
+    pWineCaps->MaxUserClipPlanes                 = &pCaps->MaxUserClipPlanes;
+    pWineCaps->MaxVertexBlendMatrices            = &pCaps->MaxVertexBlendMatrices;
+    pWineCaps->MaxVertexBlendMatrixIndex         = &pCaps->MaxVertexBlendMatrixIndex;
+    pWineCaps->MaxPointSize                      = &pCaps->MaxPointSize;
+    pWineCaps->MaxPrimitiveCount                 = &pCaps->MaxPrimitiveCount;
+    pWineCaps->MaxVertexIndex                    = &pCaps->MaxVertexIndex;
+    pWineCaps->MaxStreams                        = &pCaps->MaxStreams;
+    pWineCaps->MaxStreamStride                   = &pCaps->MaxStreamStride;
+    pWineCaps->VertexShaderVersion               = &pCaps->VertexShaderVersion;
+    pWineCaps->MaxVertexShaderConst              = &pCaps->MaxVertexShaderConst;
+    pWineCaps->PixelShaderVersion                = &pCaps->PixelShaderVersion;
+    /* d3d9 only    
+    pWineCaps->PixelShader1xMaxValue             = &pCaps->PixelShader1xMaxValue;
+    pWineCaps->DevCaps2                          = &pCaps->DevCaps2;
+    pWineCaps->MaxNpatchTessellationLevel        = &pCaps->MaxNpatchTessellationLevel;
+    pWineCaps->MasterAdapterOrdinal              = &pCaps->MasterAdapterOrdinal;
+    pWineCaps->AdapterOrdinalInGroup             = &pCaps->AdapterOrdinalInGroup;
+    pWineCaps->NumberOfAdaptersInGroup           = &pCaps->NumberOfAdaptersInGroup;
+    pWineCaps->DeclTypes                         = &pCaps->DeclTypes;
+    pWineCaps->NumSimultaneousRTs                = &pCaps->NumSimultaneousRTs;
+    pWineCaps->StretchRectFilterCaps             = &pCaps->StretchRectFilterCaps;
+    pWineCaps->VS20Caps                          = &pCaps->VS20Caps;
+    pWineCaps->PS20Caps                          = &pCaps->PS20Caps;
+    pWineCaps->VertexTextureFilterCaps           = &pCaps->VertexTextureFilterCaps;
+    pWineCaps->MaxVShaderInstructionsExecuted    = &pCaps->MaxVShaderInstructionsExecuted;
+    pWineCaps->MaxPShaderInstructionsExecuted    = &pCaps->MaxPShaderInstructionsExecuted;
+    pWineCaps->MaxVertexShader30InstructionSlots = &pCaps->MaxVertexShader30InstructionSlots;
+    pWineCaps->MaxPixelShader30InstructionSlots  = &pCaps->MaxPixelShader30InstructionSlots;
+    */
+    hrc = IWineD3DDevice_GetDeviceCaps(This->WineD3DDevice, pWineCaps);
+    HeapFree(GetProcessHeap(), 0, pWineCaps);
+    return hrc;    
 }
 HRESULT  WINAPI  IDirect3DDevice8Impl_GetDisplayMode(LPDIRECT3DDEVICE8 iface, D3DDISPLAYMODE* pMode) {
 
@@ -387,6 +474,10 @@
 HRESULT  WINAPI  IDirect3DDevice8Impl_GetCreationParameters(LPDIRECT3DDEVICE8 iface, D3DDEVICE_CREATION_PARAMETERS *pParameters) {
     IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
     TRACE("(%p) copying to %p\n", This, pParameters);    
+    if(pParameters == NULL || (int)pParameters < 1000) {
+        FIXME("GetCrationParameters called with no buffer or corrupt buffer!\n");
+        return D3DERR_INVALIDCALL; /*should we allocate?*/
+    }
     memcpy(pParameters, &This->CreateParms, sizeof(D3DDEVICE_CREATION_PARAMETERS));
     return D3D_OK;
 }
@@ -854,7 +945,6 @@
     object->Device = This;
     object->ref = 1;
     object->ResourceType = D3DRTYPE_INDEXBUFFER;
-
     object->currentDesc.Type = D3DRTYPE_INDEXBUFFER;
     object->currentDesc.Usage = Usage;
     object->currentDesc.Pool  = Pool;
@@ -869,47 +959,11 @@
 
     return D3D_OK;
 }
-HRESULT  WINAPI  IDirect3DDevice8Impl_CreateRenderTarget(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, IDirect3DSurface8** ppSurface) {
-    IDirect3DSurface8Impl *object;
-    IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
     
-    object  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DSurface8Impl));
-    if (NULL == object) {
-      *ppSurface = NULL;
-      return D3DERR_OUTOFVIDEOMEMORY;
-    }
-    *ppSurface = (LPDIRECT3DSURFACE8) object;
-    object->lpVtbl = &Direct3DSurface8_Vtbl;
-    object->Device = This;
-    object->ResourceType = D3DRTYPE_SURFACE;
-    object->Container = (IUnknown*) This;
 
-    object->ref = 1;
-    object->myDesc.Width  = Width;
-    object->myDesc.Height = Height;
-    object->myDesc.Format = Format;
-    object->myDesc.Type = D3DRTYPE_SURFACE;
-    object->myDesc.Usage = D3DUSAGE_RENDERTARGET;
-    object->myDesc.Pool = D3DPOOL_DEFAULT;
-    object->myDesc.MultiSampleType = MultiSample;
-    object->bytesPerPixel = D3DFmtGetBpp(This, Format);
-    if (Format == D3DFMT_DXT1) { 
-        object->myDesc.Size = (Width * object->bytesPerPixel)/2 * Height;  /* DXT1 is half byte per pixel */
-    } else {
-        object->myDesc.Size = (Width * object->bytesPerPixel) * Height;
-    }
-    object->allocatedMemory = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, object->myDesc.Size);
-    object->lockable = Lockable;
-    object->locked = FALSE;
-    memset(&object->lockedRect, 0, sizeof(RECT));
-    IDirect3DSurface8Impl_CleanDirtyRect((LPDIRECT3DSURFACE8) object);
+HRESULT  WINAPI IDirect3DDevice8Impl_CreateSurface(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, BOOL Lockable, IDirect3DSurface8** ppSurface,D3DRESOURCETYPE Type, UINT Usage,D3DPOOL Pool, D3DMULTISAMPLE_TYPE MultiSample ) {
 
-    TRACE("(%p) : w(%d) h(%d) fmt(%d,%s) lockable(%d) surf@%p, surfmem@%p, %d bytes\n", This, Width, Height, Format, debug_d3dformat(Format), Lockable, *ppSurface, object->allocatedMemory, object->myDesc.Size);
-    return D3D_OK;
-}
-HRESULT  WINAPI  IDirect3DDevice8Impl_CreateDepthStencilSurface(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, IDirect3DSurface8** ppSurface) {
     IDirect3DSurface8Impl *object;
-
     IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
 
     object  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DSurface8Impl));
@@ -917,6 +971,7 @@
       *ppSurface = NULL;
       return D3DERR_OUTOFVIDEOMEMORY;
     }
+    
     *ppSurface = (LPDIRECT3DSURFACE8) object;
     object->lpVtbl = &Direct3DSurface8_Vtbl;
     object->Device = This;
@@ -927,45 +982,12 @@
     object->myDesc.Width  = Width;
     object->myDesc.Height = Height;
     object->myDesc.Format = Format;
-    object->myDesc.Type = D3DRTYPE_SURFACE;
-    object->myDesc.Usage = D3DUSAGE_DEPTHSTENCIL;
-    object->myDesc.Pool = D3DPOOL_DEFAULT;
+    object->myDesc.Type   = Type;
+    object->myDesc.Usage  = Usage;
+    object->myDesc.Pool   = Pool;
     object->myDesc.MultiSampleType = MultiSample;
     object->bytesPerPixel = D3DFmtGetBpp(This, Format);
-    if (Format == D3DFMT_DXT1) { 
-        object->myDesc.Size = (Width * object->bytesPerPixel)/2 * Height; /* DXT1 is half byte per pixel */
-    } else {
-        object->myDesc.Size = (Width * object->bytesPerPixel) * Height;
-    }
-    object->allocatedMemory = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, object->myDesc.Size);
-    object->lockable = (D3DFMT_D16_LOCKABLE == Format) ? TRUE : FALSE;
-    object->locked = FALSE;
-    memset(&object->lockedRect, 0, sizeof(RECT));
-    IDirect3DSurface8Impl_CleanDirtyRect((LPDIRECT3DSURFACE8) object);
-
-    TRACE("(%p) : w(%d) h(%d) fmt(%d,%s) surf@%p, surfmem@%p, %d bytes\n", This, Width, Height, Format, debug_d3dformat(Format), *ppSurface, object->allocatedMemory, object->myDesc.Size);
-    return D3D_OK;
-}
-HRESULT  WINAPI  IDirect3DDevice8Impl_CreateImageSurface(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, IDirect3DSurface8** ppSurface) {
-    IDirect3DSurface8Impl *object;
-
-    IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
-
-    object  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DSurface8Impl));
-    *ppSurface = (LPDIRECT3DSURFACE8) object;
-    object->lpVtbl = &Direct3DSurface8_Vtbl;
-    object->Device = This;
-    object->ResourceType = D3DRTYPE_SURFACE;
-    object->Container = (IUnknown*) This;
 
-    object->ref = 1;
-    object->myDesc.Width  = Width;
-    object->myDesc.Height = Height;
-    object->myDesc.Format = Format;
-    object->myDesc.Type = D3DRTYPE_SURFACE;
-    object->myDesc.Usage = 0;
-    object->myDesc.Pool = D3DPOOL_SYSTEMMEM;
-    object->bytesPerPixel = D3DFmtGetBpp(This, Format);
     /* DXTn mipmaps use the same number of 'levels' down to eg. 8x1, but since
        it is based around 4x4 pixel blocks it requires padding, so allocate enough
        space!                                                                      */
@@ -977,15 +999,43 @@
     } else {
         object->myDesc.Size = (Width * object->bytesPerPixel) * Height;
     }
+    
     object->allocatedMemory = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, object->myDesc.Size);
-    object->lockable = TRUE;
+    object->lockable = (D3DFMT_D16_LOCKABLE == Format) ? TRUE : Lockable;
     object->locked = FALSE;
     memset(&object->lockedRect, 0, sizeof(RECT));
     IDirect3DSurface8Impl_CleanDirtyRect((LPDIRECT3DSURFACE8) object);
 
     TRACE("(%p) : w(%d) h(%d) fmt(%d,%s) surf@%p, surfmem@%p, %d bytes\n", This, Width, Height, Format, debug_d3dformat(Format), *ppSurface, object->allocatedMemory, object->myDesc.Size);
     return D3D_OK;
+    
+    
+
+}
+
+
+HRESULT  WINAPI  IDirect3DDevice8Impl_CreateRenderTarget(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, IDirect3DSurface8** ppSurface) {
+
+	Format |= Lockable?D3DFMT_D16_LOCKABLE:0;
+	return IDirect3DDevice8Impl_CreateSurface(iface,Width,Height,Format,TRUE /*Lockable*/,ppSurface,D3DRTYPE_SURFACE,D3DUSAGE_DEPTHSTENCIL,D3DPOOL_SYSTEMMEM,MultiSample);
+	
 }
+
+
+HRESULT  WINAPI  IDirect3DDevice8Impl_CreateDepthStencilSurface(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, IDirect3DSurface8** ppSurface) {
+    
+    return IDirect3DDevice8Impl_CreateSurface(iface,Width,Height,Format,FALSE/*Lockable*/,ppSurface,D3DRTYPE_SURFACE,D3DUSAGE_DEPTHSTENCIL,D3DPOOL_DEFAULT,MultiSample);
+}
+
+
+
+HRESULT  WINAPI  IDirect3DDevice8Impl_CreateImageSurface(LPDIRECT3DDEVICE8 iface, UINT Width, UINT Height, D3DFORMAT Format, IDirect3DSurface8** ppSurface) {
+
+    return IDirect3DDevice8Impl_CreateSurface(iface,Width,Height,Format,TRUE/*Lockable*/,ppSurface,D3DRTYPE_SURFACE,0,D3DPOOL_SCRATCH,D3DMULTISAMPLE_NONE);
+    
+}
+
+
 HRESULT  WINAPI  IDirect3DDevice8Impl_CopyRects(LPDIRECT3DDEVICE8 iface, 
                                                 IDirect3DSurface8* pSourceSurface, CONST RECT* pSourceRectsArray, UINT cRects,
                                                 IDirect3DSurface8* pDestinationSurface, CONST POINT* pDestPointsArray) {
@@ -3111,7 +3161,7 @@
   IDirect3DStateBlockImpl* pSB = (IDirect3DStateBlockImpl*) Token;
   IDirect3DDevice8Impl *This = (IDirect3DDevice8Impl *)iface;
 
-  TRACE("(%p)\n", This);
+  FIXME("(%p)\n", This);
 
   return IDirect3DDeviceImpl_CaptureStateBlock(This, pSB);
 }
diff -urN wine.20050419/dlls/d3d8/directx.c wine.20050419.dx9/dlls/d3d8/directx.c
--- wine.20050419/dlls/d3d8/directx.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d8/directx.c	2005-04-20 01:52:56.000000000 -0600
@@ -192,7 +192,88 @@
 
 HRESULT  WINAPI  IDirect3D8Impl_GetDeviceCaps(LPDIRECT3D8 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS8* pCaps) {
     IDirect3D8Impl *This = (IDirect3D8Impl *)iface;
-    return IWineD3D_GetDeviceCaps(This->WineD3D, Adapter, DeviceType, (void *)pCaps);
+    HRESULT hrc            = D3D_OK;
+    WINED3DCAPS *pWineCaps = NULL;
+   if(NULL == pCaps){
+        return D3DERR_INVALIDCALL;
+    }        
+    pWineCaps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WINED3DCAPS));
+    if(pWineCaps == NULL){
+        return D3DERR_INVALIDCALL; /*well this is what MSDN says to return*/
+    }
+    pWineCaps->DeviceType                        = &pCaps->DeviceType;
+    pWineCaps->AdapterOrdinal                    = &pCaps->AdapterOrdinal;
+    pWineCaps->Caps                              = &pCaps->Caps;
+    pWineCaps->Caps2                             = &pCaps->Caps2;
+    pWineCaps->Caps3                             = &pCaps->Caps3;
+    pWineCaps->PresentationIntervals             = &pCaps->PresentationIntervals;
+    pWineCaps->CursorCaps                        = &pCaps->CursorCaps;
+    pWineCaps->DevCaps                           = &pCaps->DevCaps;
+    pWineCaps->PrimitiveMiscCaps                 = &pCaps->PrimitiveMiscCaps;
+    pWineCaps->RasterCaps                        = &pCaps->RasterCaps;
+    pWineCaps->ZCmpCaps                          = &pCaps->ZCmpCaps;
+    pWineCaps->SrcBlendCaps                      = &pCaps->SrcBlendCaps;
+    pWineCaps->DestBlendCaps                     = &pCaps->DestBlendCaps;
+    pWineCaps->AlphaCmpCaps                      = &pCaps->AlphaCmpCaps;
+    pWineCaps->ShadeCaps                         = &pCaps->ShadeCaps;
+    pWineCaps->TextureCaps                       = &pCaps->TextureCaps;
+    pWineCaps->TextureFilterCaps                 = &pCaps->TextureFilterCaps;
+    pWineCaps->CubeTextureFilterCaps             = &pCaps->CubeTextureFilterCaps;
+    pWineCaps->VolumeTextureFilterCaps           = &pCaps->VolumeTextureFilterCaps;
+    pWineCaps->TextureAddressCaps                = &pCaps->TextureAddressCaps;
+    pWineCaps->VolumeTextureAddressCaps          = &pCaps->VolumeTextureAddressCaps;
+    pWineCaps->LineCaps                          = &pCaps->LineCaps;
+    pWineCaps->MaxTextureWidth                   = &pCaps->MaxTextureWidth;
+    pWineCaps->MaxTextureHeight                  = &pCaps->MaxTextureHeight;
+    pWineCaps->MaxVolumeExtent                   = &pCaps->MaxVolumeExtent;
+    pWineCaps->MaxTextureRepeat                  = &pCaps->MaxTextureRepeat;
+    pWineCaps->MaxTextureAspectRatio             = &pCaps->MaxTextureAspectRatio;
+    pWineCaps->MaxAnisotropy                     = &pCaps->MaxAnisotropy;
+    pWineCaps->MaxVertexW                        = &pCaps->MaxVertexW;
+    pWineCaps->GuardBandLeft                     = &pCaps->GuardBandLeft;
+    pWineCaps->GuardBandTop                      = &pCaps->GuardBandTop;
+    pWineCaps->GuardBandRight                    = &pCaps->GuardBandRight;
+    pWineCaps->GuardBandBottom                   = &pCaps->GuardBandBottom;
+    pWineCaps->ExtentsAdjust                     = &pCaps->ExtentsAdjust;
+    pWineCaps->StencilCaps                       = &pCaps->StencilCaps;
+    pWineCaps->FVFCaps                           = &pCaps->FVFCaps;
+    pWineCaps->TextureOpCaps                     = &pCaps->TextureOpCaps;
+    pWineCaps->MaxTextureBlendStages             = &pCaps->MaxTextureBlendStages;
+    pWineCaps->MaxSimultaneousTextures           = &pCaps->MaxSimultaneousTextures;
+    pWineCaps->VertexProcessingCaps              = &pCaps->VertexProcessingCaps;
+    pWineCaps->MaxActiveLights                   = &pCaps->MaxActiveLights;
+    pWineCaps->MaxUserClipPlanes                 = &pCaps->MaxUserClipPlanes;
+    pWineCaps->MaxVertexBlendMatrices            = &pCaps->MaxVertexBlendMatrices;
+    pWineCaps->MaxVertexBlendMatrixIndex         = &pCaps->MaxVertexBlendMatrixIndex;
+    pWineCaps->MaxPointSize                      = &pCaps->MaxPointSize;
+    pWineCaps->MaxPrimitiveCount                 = &pCaps->MaxPrimitiveCount;
+    pWineCaps->MaxVertexIndex                    = &pCaps->MaxVertexIndex;
+    pWineCaps->MaxStreams                        = &pCaps->MaxStreams;
+    pWineCaps->MaxStreamStride                   = &pCaps->MaxStreamStride;
+    pWineCaps->VertexShaderVersion               = &pCaps->VertexShaderVersion;
+    pWineCaps->MaxVertexShaderConst              = &pCaps->MaxVertexShaderConst;
+    pWineCaps->PixelShaderVersion                = &pCaps->PixelShaderVersion;
+    /* d3d9 only
+    pWineCaps->PixelShader1xMaxValue             = &pCaps->PixelShader1xMaxValue;
+    pWineCaps->DevCaps2                          = &pCaps->DevCaps2;
+    pWineCaps->MaxNpatchTessellationLevel        = &pCaps->MaxNpatchTessellationLevel;
+    pWineCaps->MasterAdapterOrdinal              = &pCaps->MasterAdapterOrdinal;
+    pWineCaps->AdapterOrdinalInGroup             = &pCaps->AdapterOrdinalInGroup;
+    pWineCaps->NumberOfAdaptersInGroup           = &pCaps->NumberOfAdaptersInGroup;
+    pWineCaps->DeclTypes                         = &pCaps->DeclTypes;
+    pWineCaps->NumSimultaneousRTs                = &pCaps->NumSimultaneousRTs;
+    pWineCaps->StretchRectFilterCaps             = &pCaps->StretchRectFilterCaps;
+    pWineCaps->VS20Caps                          = &pCaps->VS20Caps;
+    pWineCaps->PS20Caps                          = &pCaps->PS20Caps;
+    pWineCaps->VertexTextureFilterCaps           = &pCaps->VertexTextureFilterCaps;
+    pWineCaps->MaxVShaderInstructionsExecuted    = &pCaps->MaxVShaderInstructionsExecuted;
+    pWineCaps->MaxPShaderInstructionsExecuted    = &pCaps->MaxPShaderInstructionsExecuted;
+    pWineCaps->MaxVertexShader30InstructionSlots = &pCaps->MaxVertexShader30InstructionSlots;
+    pWineCaps->MaxPixelShader30InstructionSlots  = &pCaps->MaxPixelShader30InstructionSlots;
+    */
+    hrc = IWineD3D_GetDeviceCaps(This->WineD3D, Adapter, DeviceType, pWineCaps);
+    HeapFree(GetProcessHeap(), 0, pWineCaps);
+    return hrc;
 }
 
 HMONITOR WINAPI  IDirect3D8Impl_GetAdapterMonitor(LPDIRECT3D8 iface, UINT Adapter) {
@@ -563,6 +644,86 @@
     return res;
 }
 
+
+/* Internal function called back during the CreateDevice to create a render target */
+HRESULT WINAPI D3D8CB_CreateDepthStencilSurface(IUnknown *device, UINT Width, UINT Height, 
+                                         D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, 
+                                         DWORD MultisampleQuality, BOOL Discard,
+                                         IWineD3DSurface** ppSurface, HANDLE* pSharedHandle) {
+    HRESULT res = D3D_OK;
+    IDirect3DSurface8Impl *d3dSurface = NULL;
+
+    res = IDirect3DDevice8_CreateDepthStencilSurface((IDirect3DDevice8 *)device, Width, Height, 
+                                         Format, MultiSample,  (IDirect3DSurface8 **)&d3dSurface);
+    if (res == D3D_OK) {
+        *ppSurface = d3dSurface->wineD3DSurface;
+    }else{
+        FIXME("Error create depth stencil surface\n");
+        *ppSurface = NULL;
+    }
+    return res;
+}
+
+
+/* Callback for creating the inplicite swapchain when the device is created */
+
+HRESULT WINAPI D3D8CB_CreateAdditionalSwapChain(IUnknown *device,
+                                                WINED3DPRESENT_PARAMETERS* pPresentationParameters,
+                                                IWineD3DSwapChain ** ppSwapChain){
+    HRESULT res = D3D_OK;
+    IDirect3DSwapChain8Impl *d3dSwapChain = NULL;
+    /* We have to pass the presentation parameters back and forth */
+    D3DPRESENT_PARAMETERS localParameters;
+    localParameters.BackBufferWidth                = *(pPresentationParameters->BackBufferWidth);
+    localParameters.BackBufferHeight               = *(pPresentationParameters->BackBufferHeight);           
+    localParameters.BackBufferFormat               = *(pPresentationParameters->BackBufferFormat);           
+    localParameters.BackBufferCount                = *(pPresentationParameters->BackBufferCount);            
+    localParameters.MultiSampleType                = *(pPresentationParameters->MultiSampleType);
+/* d3d9 only */
+/*    localParameters.MultiSampleQuality             = *(pPresentationParameters->MultiSampleQuality); */
+    localParameters.SwapEffect                     = *(pPresentationParameters->SwapEffect);
+    localParameters.hDeviceWindow                  = *(pPresentationParameters->hDeviceWindow);
+    localParameters.Windowed                       = *(pPresentationParameters->Windowed);
+    localParameters.EnableAutoDepthStencil         = *(pPresentationParameters->EnableAutoDepthStencil);
+    localParameters.AutoDepthStencilFormat         = *(pPresentationParameters->AutoDepthStencilFormat);
+    localParameters.Flags                          = *(pPresentationParameters->Flags);
+    localParameters.FullScreen_RefreshRateInHz     = *(pPresentationParameters->FullScreen_RefreshRateInHz);
+/* not in d3d8 */
+/*    localParameters.PresentationInterval           = *(pPresentationParameters->PresentationInterval); */
+    
+    TRACE("(%p) rellaying\n", device);
+    /*copy the presentation parameters*/
+    res = IDirect3DDevice8_CreateAdditionalSwapChain((IDirect3DDevice8 *)device, &localParameters, (IDirect3DSwapChain8 **)&d3dSwapChain);
+    
+    if (res == D3D_OK){
+        *ppSwapChain = d3dSwapChain->wineD3DSwapChain;
+    } else {
+        FIXME("failed to create additional swap chain\n");
+        *ppSwapChain = NULL;
+    }
+    /* Copy back the presentation parameters */
+    TRACE("(%p) setting up return parameters\n", device);
+   *pPresentationParameters->BackBufferWidth               = localParameters.BackBufferWidth;
+   *pPresentationParameters->BackBufferHeight              = localParameters.BackBufferHeight;
+   *pPresentationParameters->BackBufferFormat              = localParameters.BackBufferFormat;
+   *pPresentationParameters->BackBufferCount               = localParameters.BackBufferCount;
+   *pPresentationParameters->MultiSampleType               = localParameters.MultiSampleType;
+/*   *pPresentationParameters->MultiSampleQuality            leave alone incase wineD3D set something internally */
+   *pPresentationParameters->SwapEffect                    = localParameters.SwapEffect;
+   *pPresentationParameters->hDeviceWindow                 = localParameters.hDeviceWindow;
+   *pPresentationParameters->Windowed                      = localParameters.Windowed;
+   *pPresentationParameters->EnableAutoDepthStencil        = localParameters.EnableAutoDepthStencil;
+   *pPresentationParameters->AutoDepthStencilFormat        = localParameters.AutoDepthStencilFormat;
+   *pPresentationParameters->Flags                         = localParameters.Flags;
+   *pPresentationParameters->FullScreen_RefreshRateInHz    = localParameters.FullScreen_RefreshRateInHz;
+/*   *pPresentationParameters->PresentationInterval          leave alone incase wineD3D set something internally */
+    
+   return res;       
+    
+}
+
+
+
 HRESULT  WINAPI  IDirect3D8Impl_CreateDevice               (LPDIRECT3D8 iface,
                                                             UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow,
                                                             DWORD BehaviourFlags, D3DPRESENT_PARAMETERS* pPresentationParameters,
@@ -608,7 +769,8 @@
     localParameters.Flags                          = &pPresentationParameters->Flags;                      
     localParameters.FullScreen_RefreshRateInHz     = &pPresentationParameters->FullScreen_RefreshRateInHz; 
     localParameters.PresentationInterval           = &pPresentationParameters->FullScreen_PresentationInterval;    /* Renamed in dx9 */
-    IWineD3D_CreateDevice(This->WineD3D, Adapter, DeviceType, hFocusWindow, BehaviourFlags, &localParameters, &object->WineD3DDevice, (IUnknown *)object, D3D8CB_CreateRenderTarget);
+    /*TODO: remove createRenderTarget and CreateDepthSurfae call backs*/
+    IWineD3D_CreateDevice(This->WineD3D, Adapter, DeviceType, hFocusWindow, BehaviourFlags, &localParameters, &object->WineD3DDevice, (IUnknown *)object, D3D8CB_CreateRenderTarget, D3D8CB_CreateDepthStencilSurface, D3D8CB_CreateAdditionalSwapChain);
 
     /** use StateBlock Factory here, for creating the startup stateBlock */
     object->StateBlock = NULL;
diff -urN wine.20050419/dlls/d3d8/stateblock.c wine.20050419.dx9/dlls/d3d8/stateblock.c
--- wine.20050419/dlls/d3d8/stateblock.c	2004-12-23 11:33:45.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d8/stateblock.c	2005-04-20 01:52:56.000000000 -0600
@@ -286,7 +286,9 @@
   TRACE("(%p) : Type(%d)\n", This, Type);
 
   /* Allocate Storage */
+  
   object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DStateBlockImpl));
+  FIXME("Allocated %p stateblock\n",object);
   if (object) {
     if (NULL == This->StateBlock) { /** if it the main stateblock only do init and returns */
       /*object->lpVtbl = &Direct3DStateBlock9_Vtbl;*/
@@ -354,6 +356,7 @@
         
         while (src) {
             newEl = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PLIGHTINFOEL));
+	    FIXME("Allocated %p sblights\n",newEl);
             if (newEl == NULL) return D3DERR_OUTOFVIDEOMEMORY;
             memcpy(newEl, src, sizeof(PLIGHTINFOEL));
             newEl->prev = dst;
@@ -386,10 +389,13 @@
   tmp = pSB->lights;
   if (tmp) tmp = tmp->next;
   while (tmp != NULL) {
+      FIXME("(%p) Freeing  sblight %p\n",This,tmp->prev);
       HeapFree(GetProcessHeap(), 0, (void *)(tmp->prev));
       tmp = tmp->next;
   }
+  FIXME("(%p) Freeing  sblight %p\n",This,tmp);
   HeapFree(GetProcessHeap(), 0, (void *)tmp);
+  FIXME("(%p) Freeing  stateblock  %p\n",This,pSB);
   HeapFree(GetProcessHeap(), 0, (void *)pSB);
   return D3D_OK;
 }
@@ -407,6 +413,7 @@
   /* Allocate Storage */
   object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DStateBlockImpl));
   if (object) {
+  FIXME("Allocated %p IDirect3DStateBlockImpl\n",object);
   } else {
     return E_OUTOFMEMORY;
   }
diff -urN wine.20050419/dlls/d3d9/cubetexture.c wine.20050419.dx9/dlls/d3d9/cubetexture.c
--- wine.20050419/dlls/d3d9/cubetexture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/cubetexture.c	2005-04-20 01:52:56.000000000 -0600
@@ -236,6 +236,8 @@
 
 
 
+
+
 /* IDirect3DDevice9 IDirect3DCubeTexture9 Methods follow: */
 HRESULT  WINAPI  IDirect3DDevice9Impl_CreateCubeTexture(LPDIRECT3DDEVICE9 iface,
                                                         UINT EdgeLength, UINT Levels, DWORD Usage,
diff -urN wine.20050419/dlls/d3d9/d3d9_main.c wine.20050419.dx9/dlls/d3d9/d3d9_main.c
--- wine.20050419/dlls/d3d9/d3d9_main.c	2005-03-02 06:44:59.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/d3d9_main.c	2005-04-20 01:52:56.000000000 -0600
@@ -44,6 +44,7 @@
 
     object->lpVtbl = &Direct3D9_Vtbl;
     object->ref = 1;
+    FIXME("calling WineDirect3DCreate with %d %d %p\n", SDKVersion, 9, (IUnknown *)object);
     object->WineD3D = WineDirect3DCreate(SDKVersion, 9, (IUnknown *)object);
 
     TRACE("SDKVersion = %x, Created Direct3D object @ %p, WineObj @ %p\n", SDKVersion, object, object->WineD3D);
diff -urN wine.20050419/dlls/d3d9/d3d9_private.h wine.20050419.dx9/dlls/d3d9/d3d9_private.h
--- wine.20050419/dlls/d3d9/d3d9_private.h	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/d3d9_private.h	2005-04-20 01:52:56.000000000 -0600
@@ -27,7 +27,6 @@
 # error You must include config.h to use this header
 #endif
 
-/* THIS FILE MUST NOT CONTAIN X11 or MESA DEFINES */
 #include <stdarg.h>
 
 #define NONAMELESSUNION
@@ -35,19 +34,10 @@
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
-#include "wingdi.h"
 #include "winuser.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
 
-#define XMD_H 
-#include <GL/gl.h>
-#include <GL/glx.h>
-#ifdef HAVE_GL_GLEXT_H
-# include <GL/glext.h>
-#endif
-#undef  XMD_H
-
 #undef APIENTRY
 #undef CALLBACK
 #undef WINAPI
@@ -61,116 +51,14 @@
 #include "d3d9_private.h"
 #include "wine/wined3d_interface.h"
 
-/* X11 locking */
-
-extern void (*wine_tsx11_lock_ptr)(void);
-extern void (*wine_tsx11_unlock_ptr)(void);
-
-/* As GLX relies on X, this is needed */
-#define ENTER_GL() wine_tsx11_lock_ptr()
-#define LEAVE_GL() wine_tsx11_unlock_ptr()
 
 #include <stdarg.h>
 
+
 #include "windef.h"
 #include "winbase.h"
-#include "d3d9.h"
+#include "d3d9.h" /*why is this included twice?*/
 
-/* Device caps */
-#define MAX_PALETTES      256
-#define MAX_STREAMS       16
-#define MAX_ACTIVE_LIGHTS 8
-#define MAX_CLIPPLANES    D3DMAXUSERCLIPPLANES
-#define MAX_LEVELS        256
-
-/* Other useful values */
-#define HIGHEST_RENDER_STATE D3DRS_BLENDOPALPHA
-#define HIGHEST_TEXTURE_STATE 29
-#define HIGHEST_TRANSFORMSTATE 512
-#define D3DSBT_RECORDED 0xfffffffe
-
-#define D3D_VSHADER_MAX_CONSTANTS 96
-#define D3D_PSHADER_MAX_CONSTANTS 32
-
-/* Direct3D9 Interfaces: */
-typedef struct IDirect3D9Impl                  IDirect3D9Impl;
-typedef struct IDirect3DDevice9Impl            IDirect3DDevice9Impl;
-typedef struct IDirect3DBaseTexture9Impl       IDirect3DBaseTexture9Impl;
-typedef struct IDirect3DTexture9Impl           IDirect3DTexture9Impl;
-typedef struct IDirect3DVolumeTexture9Impl     IDirect3DVolumeTexture9Impl;
-typedef struct IDirect3DCubeTexture9Impl       IDirect3DCubeTexture9Impl;
-typedef struct IDirect3DVertexBuffer9Impl      IDirect3DVertexBuffer9Impl;
-typedef struct IDirect3DIndexBuffer9Impl       IDirect3DIndexBuffer9Impl;
-typedef struct IDirect3DSurface9Impl           IDirect3DSurface9Impl;
-typedef struct IDirect3DSwapChain9Impl         IDirect3DSwapChain9Impl;
-typedef struct IDirect3DResource9Impl          IDirect3DResource9Impl;
-typedef struct IDirect3DVolume9Impl            IDirect3DVolume9Impl;
-typedef struct IDirect3DStateBlock9Impl        IDirect3DStateBlock9Impl;
-typedef struct IDirect3DVertexShader9Impl      IDirect3DVertexShader9Impl;
-typedef struct IDirect3DPixelShader9Impl       IDirect3DPixelShader9Impl;
-typedef struct IDirect3DVertexDeclaration9Impl IDirect3DVertexDeclaration9Impl;
-
-
-#define D3DCOLOR_R(dw) (((float) (((dw) >> 16) & 0xFF)) / 255.0f)
-#define D3DCOLOR_G(dw) (((float) (((dw) >>  8) & 0xFF)) / 255.0f)
-#define D3DCOLOR_B(dw) (((float) (((dw) >>  0) & 0xFF)) / 255.0f)
-#define D3DCOLOR_A(dw) (((float) (((dw) >> 24) & 0xFF)) / 255.0f)
-
-#define D3DCOLORTOCOLORVALUE(dw, col) \
-  (col).r = D3DCOLOR_R(dw); \
-  (col).g = D3DCOLOR_G(dw); \
-  (col).b = D3DCOLOR_B(dw); \
-  (col).a = D3DCOLOR_A(dw); 
-
-#define D3DCOLORTOVECTOR4(dw, vec) \
-  (vec).x = D3DCOLOR_R(dw); \
-  (vec).y = D3DCOLOR_G(dw); \
-  (vec).z = D3DCOLOR_B(dw); \
-  (vec).w = D3DCOLOR_A(dw);
-
-#define D3DCOLORTOGLFLOAT4(dw, vec) \
-  (vec)[0] = D3DCOLOR_R(dw); \
-  (vec)[1] = D3DCOLOR_G(dw); \
-  (vec)[2] = D3DCOLOR_B(dw); \
-  (vec)[3] = D3DCOLOR_A(dw);
-
-/**
- * State Block for Begin/End/Capture/Create/Apply State Block
- *  Note: Very long winded but I do not believe gl Lists will 
- *  resolve everything we need, so doing it manually for now
- */
-typedef struct SAVEDSTATES {
-  BOOL          lightEnable[MAX_ACTIVE_LIGHTS];
-  BOOL          Indices;
-  BOOL          lights[MAX_ACTIVE_LIGHTS];
-  BOOL          material;
-  BOOL          stream_source[MAX_STREAMS];
-  BOOL          textures[8];
-  BOOL          transform[HIGHEST_TRANSFORMSTATE];
-  BOOL          viewport;
-  BOOL          vertexShader;
-  BOOL          vertexShaderConstant;
-  BOOL          vertexShaderDecl;
-  BOOL          pixelShader;
-  BOOL          pixelShaderConstant;
-  BOOL          renderstate[HIGHEST_RENDER_STATE];
-  BOOL          texture_state[8][HIGHEST_TEXTURE_STATE];
-  BOOL          clipplane[MAX_CLIPPLANES];
-} SAVEDSTATES;
-
-typedef struct D3DSHADERVECTORF {
-  float x;
-  float y;
-  float z;
-  float w;
-} D3DSHADERVECTORF;
-
-typedef struct D3DSHADERVECTORI {
-  int x;
-  int y;
-  int z;
-  int w;
-} D3DSHADERVECTORI;
 
 /* ===========================================================================
     The interfactes themselves
@@ -188,7 +76,7 @@
 /*****************************************************************************
  * IDirect3D implementation structure
  */
-struct IDirect3D9Impl
+typedef struct IDirect3D9Impl
 {
     /* IUnknown fields */
     IDirect3D9Vtbl         *lpVtbl;
@@ -197,33 +85,11 @@
     /* The WineD3D device */
     IWineD3D               *WineD3D;
 
-    /* IDirect3D9 fields */
-};
+} IDirect3D9Impl;
 
-/* IUnknown: */
-extern HRESULT WINAPI   IDirect3D9Impl_QueryInterface(LPDIRECT3D9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG WINAPI     IDirect3D9Impl_AddRef(LPDIRECT3D9 iface);
-extern ULONG WINAPI     IDirect3D9Impl_Release(LPDIRECT3D9 iface);
-
-/* IDirect3d9: */
-extern HRESULT  WINAPI  IDirect3D9Impl_RegisterSoftwareDevice(LPDIRECT3D9 iface, void* pInitializeFunction);
-extern UINT     WINAPI  IDirect3D9Impl_GetAdapterCount(LPDIRECT3D9 iface);
-extern HRESULT  WINAPI  IDirect3D9Impl_GetAdapterIdentifier(LPDIRECT3D9 iface, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9* pIdentifier);
-extern UINT     WINAPI  IDirect3D9Impl_GetAdapterModeCount(LPDIRECT3D9 iface, UINT Adapter, D3DFORMAT Format);
-extern HRESULT  WINAPI  IDirect3D9Impl_EnumAdapterModes(LPDIRECT3D9 iface, UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE* pMode);
-extern HRESULT  WINAPI  IDirect3D9Impl_GetAdapterDisplayMode(LPDIRECT3D9 iface, UINT Adapter, D3DDISPLAYMODE* pMode);
-extern HRESULT  WINAPI  IDirect3D9Impl_CheckDeviceType(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
-extern HRESULT  WINAPI  IDirect3D9Impl_CheckDeviceFormat(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
-extern HRESULT  WINAPI  IDirect3D9Impl_CheckDeviceMultiSampleType(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels);
-extern HRESULT  WINAPI  IDirect3D9Impl_CheckDepthStencilMatch(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
-extern HRESULT  WINAPI  IDirect3D9Impl_CheckDeviceFormatConversion(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat);
-extern HRESULT  WINAPI  IDirect3D9Impl_GetDeviceCaps(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9* pCaps);
-extern HMONITOR WINAPI  IDirect3D9Impl_GetAdapterMonitor(LPDIRECT3D9 iface, UINT Adapter);
-extern HRESULT  WINAPI  IDirect3D9Impl_CreateDevice(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface);
-
-/* ---------------- */
-/* IDirect3DDevice9 */
-/* ---------------- */
+/* ---------- */
+/* IDirect3D9 */
+/* ---------- */
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
@@ -231,168 +97,33 @@
 extern IDirect3DDevice9Vtbl Direct3DDevice9_Vtbl;
 
 /*****************************************************************************
- * IDirect3DDevice9 implementation structure
+ * IDirect3D implementation structure
  */
-struct IDirect3DDevice9Impl
+typedef struct IDirect3DDevice9Impl
 {
     /* IUnknown fields */
     IDirect3DDevice9Vtbl         *lpVtbl;
     DWORD                         ref;
 
-    /* IDirect3DDevice9 fields */
-    IDirect3D9Impl               *direct3d;
+    /* The IDirect3DDevice9 fields */
     IWineD3DDevice               *WineD3DDevice;
 
-    /* FIXME: To be sorted out during move */
-    IDirect3DSurface9Impl        *frontBuffer;
-    IDirect3DSurface9Impl        *backBuffer;
-    IDirect3DSurface9Impl        *depthStencilBuffer;
-
-    IDirect3DSurface9Impl        *renderTarget;
-    IDirect3DSurface9Impl        *stencilBufferTarget;
-
-    D3DPRESENT_PARAMETERS         PresentParms;
-    D3DDEVICE_CREATION_PARAMETERS CreateParms;
-
-    UINT                          adapterNo;
-    D3DDEVTYPE                    devType;
-
-    UINT                          srcBlend;
-    UINT                          dstBlend;
-    UINT                          alphafunc;
-    UINT                          stencilfunc;
-
-    /* State block related */
-    BOOL                          isRecordingState;
-    IDirect3DStateBlock9Impl     *StateBlock;
-    IDirect3DStateBlock9Impl     *UpdateStateBlock;
-
-    /* Other required values */
-    float                         lightPosn[MAX_ACTIVE_LIGHTS][4];
-    float                         lightDirn[MAX_ACTIVE_LIGHTS][4];
-
-    /* palettes texture management */
-    PALETTEENTRY                  palettes[MAX_PALETTES][256];
-    UINT                          currentPalette;
-
-    /* Optimization */
-    D3DMATRIX                     lastProj;
-    D3DMATRIX                     lastView;
-    D3DMATRIX                     lastWorld0;
-    D3DMATRIX                     lastTexTrans[8];
-
-    /* OpenGL related */
-    /*
-    GLXContext                    glCtx;
-    XVisualInfo                  *visInfo;
-    Display                      *display;
-    GLXContext                    render_ctx;
-    Drawable                      drawable;
-    Window                        win;
-    */
-    HWND                          win_handle;
-
-    /* OpenGL Extension related */
-
-    /* Cursor management */
-    BOOL                          bCursorVisible;
-    UINT                          xHotSpot;
-    UINT                          yHotSpot;
-    UINT                          xScreenSpace;
-    UINT                          yScreenSpace;
+} IDirect3DDevice9Impl;
 
-    UINT                          dummyTextureName[8];
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI   IDirect3DDevice9Impl_QueryInterface(LPDIRECT3DDEVICE9 iface, REFIID refiid, LPVOID *obj);
-extern ULONG WINAPI     IDirect3DDevice9Impl_AddRef(LPDIRECT3DDEVICE9 iface);
-extern ULONG WINAPI     IDirect3DDevice9Impl_Release(LPDIRECT3DDEVICE9 iface);
 
 /* IDirect3DDevice9: */
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_TestCooperativeLevel(LPDIRECT3DDEVICE9 iface);
-extern UINT     WINAPI  IDirect3DDevice9Impl_GetAvailableTextureMem(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_EvictManagedRessources(LPDIRECT3DDEVICE9 iface);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetDirect3D(LPDIRECT3DDEVICE9 iface, IDirect3D9** ppD3D9);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetDeviceCaps(LPDIRECT3DDEVICE9 iface, D3DCAPS9* pCaps);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetDisplayMode(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, D3DDISPLAYMODE* pMode);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetCreationParameters(LPDIRECT3DDEVICE9 iface, D3DDEVICE_CREATION_PARAMETERS* pParameters);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetCursorProperties(LPDIRECT3DDEVICE9 iface, UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap);
-extern void     WINAPI  IDirect3DDevice9Impl_SetCursorPosition(LPDIRECT3DDEVICE9 iface, int XScreenSpace, int YScreenSpace, DWORD Flags);
-extern BOOL     WINAPI  IDirect3DDevice9Impl_ShowCursor(LPDIRECT3DDEVICE9 iface, BOOL bShow);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateAdditionalSwapChain(LPDIRECT3DDEVICE9 iface, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetSwapChain(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, IDirect3DSwapChain9** pSwapChain);
 extern UINT     WINAPI  IDirect3DDevice9Impl_GetNumberOfSwapChains(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_Reset(LPDIRECT3DDEVICE9 iface, D3DPRESENT_PARAMETERS* pPresentationParameters);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_Present(LPDIRECT3DDEVICE9 iface, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetBackBuffer(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, UINT BackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetRasterStatus(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetDialogBoxMode(LPDIRECT3DDEVICE9 iface, BOOL bEnableDialogs);
-extern void     WINAPI  IDirect3DDevice9Impl_SetGammaRamp(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, DWORD Flags, CONST D3DGAMMARAMP* pRamp);
-extern void     WINAPI  IDirect3DDevice9Impl_GetGammaRamp(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, D3DGAMMARAMP* pRamp);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateTexture(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateVolumeTexture(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateCubeTexture(LPDIRECT3DDEVICE9 iface, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateVertexBuffer(LPDIRECT3DDEVICE9 iface, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateIndexBuffer(LPDIRECT3DDEVICE9 iface, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateRenderTarget(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateDepthStencilSurface(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_UpdateSurface(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, CONST POINT* pDestPoint);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_UpdateTexture(LPDIRECT3DDEVICE9 iface, IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetRenderTargetData(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetFrontBufferData(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, IDirect3DSurface9* pDestSurface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_StretchRects(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_ColorFill(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pSurface, CONST RECT* pRect, D3DCOLOR color);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateOffscreenPlainSurface(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetRenderTarget(LPDIRECT3DDEVICE9 iface, DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetRenderTarget(LPDIRECT3DDEVICE9 iface, DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetDepthStencilSurface(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pNewZStencilSurface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetDepthStencilSurface(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9** ppZStencilSurface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_BeginScene(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_EndScene(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_Clear(LPDIRECT3DDEVICE9 iface, DWORD Count, CONST D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetTransform(LPDIRECT3DDEVICE9 iface, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetTransform(LPDIRECT3DDEVICE9 iface, D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_MultiplyTransform(LPDIRECT3DDEVICE9 iface, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetViewport(LPDIRECT3DDEVICE9 iface, CONST D3DVIEWPORT9* pViewport);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetViewport(LPDIRECT3DDEVICE9 iface, D3DVIEWPORT9* pViewport);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetMaterial(LPDIRECT3DDEVICE9 iface, CONST D3DMATERIAL9* pMaterial);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetMaterial(LPDIRECT3DDEVICE9 iface, D3DMATERIAL9* pMaterial);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetLight(LPDIRECT3DDEVICE9 iface, DWORD Index, CONST D3DLIGHT9* pLight);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetLight(LPDIRECT3DDEVICE9 iface, DWORD Index, D3DLIGHT9* pLight);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_LightEnable(LPDIRECT3DDEVICE9 iface, DWORD Index, BOOL Enable);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetLightEnable(LPDIRECT3DDEVICE9 iface, DWORD Index, BOOL* pEnable);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetClipPlane(LPDIRECT3DDEVICE9 iface, DWORD Index, CONST float* pPlane);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetClipPlane(LPDIRECT3DDEVICE9 iface, DWORD Index, float* pPlane);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetRenderState(LPDIRECT3DDEVICE9 iface, D3DRENDERSTATETYPE State, DWORD Value);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetRenderState(LPDIRECT3DDEVICE9 iface, D3DRENDERSTATETYPE State, DWORD* pValue);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateStateBlock(LPDIRECT3DDEVICE9 iface, D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_BeginStateBlock(LPDIRECT3DDEVICE9 iface);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_EndStateBlock(LPDIRECT3DDEVICE9 iface, IDirect3DStateBlock9** ppSB);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetClipStatus(LPDIRECT3DDEVICE9 iface, CONST D3DCLIPSTATUS9* pClipStatus);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetClipStatus(LPDIRECT3DDEVICE9 iface, D3DCLIPSTATUS9* pClipStatus);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetTexture(LPDIRECT3DDEVICE9 iface, DWORD Stage, IDirect3DBaseTexture9** ppTexture);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetTexture(LPDIRECT3DDEVICE9 iface, DWORD Stage, IDirect3DBaseTexture9* pTexture);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetTextureStageState(LPDIRECT3DDEVICE9 iface, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetTextureStageState(LPDIRECT3DDEVICE9 iface, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetSamplerState(LPDIRECT3DDEVICE9 iface, DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetSamplerState(LPDIRECT3DDEVICE9 iface, DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_ValidateDevice(LPDIRECT3DDEVICE9 iface, DWORD* pNumPasses);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetPaletteEntries(LPDIRECT3DDEVICE9 iface, UINT PaletteNumber, CONST PALETTEENTRY* pEntries);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetPaletteEntries(LPDIRECT3DDEVICE9 iface, UINT PaletteNumber, PALETTEENTRY* pEntries);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetCurrentTexturePalette(LPDIRECT3DDEVICE9 iface, UINT PaletteNumber);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetCurrentTexturePalette(LPDIRECT3DDEVICE9 iface, UINT *PaletteNumber);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetScissorRect(LPDIRECT3DDEVICE9 iface, CONST RECT* pRect);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetScissorRect(LPDIRECT3DDEVICE9 iface, RECT* pRect);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetSoftwareVertexProcessing(LPDIRECT3DDEVICE9 iface, BOOL bSoftware);
-extern BOOL     WINAPI  IDirect3DDevice9Impl_GetSoftwareVertexProcessing(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetNPatchMode(LPDIRECT3DDEVICE9 iface, float nSegments);
-extern float    WINAPI  IDirect3DDevice9Impl_GetNPatchMode(LPDIRECT3DDEVICE9 iface);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawPrimitive(LPDIRECT3DDEVICE9 iface, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawIndexedPrimitive(LPDIRECT3DDEVICE9 iface, D3DPRIMITIVETYPE, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawPrimitiveUP(LPDIRECT3DDEVICE9 iface, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawIndexedPrimitiveUP(LPDIRECT3DDEVICE9 iface, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, CONST void* pIndexData, D3DFORMAT IndexDataFormat, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_ProcessVertices(LPDIRECT3DDEVICE9 iface, UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateVertexDeclaration(LPDIRECT3DDEVICE9 iface, CONST D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetVertexDeclaration(LPDIRECT3DDEVICE9 iface, IDirect3DVertexDeclaration9* pDecl);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetVertexDeclaration(LPDIRECT3DDEVICE9 iface, IDirect3DVertexDeclaration9** ppDecl);
@@ -409,11 +140,8 @@
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetVertexShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT StartRegister, BOOL* pConstantData, UINT BoolCount);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetStreamSource(LPDIRECT3DDEVICE9 iface, UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetStreamSource(LPDIRECT3DDEVICE9 iface, UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* OffsetInBytes, UINT* pStride);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetStreamSourceFreq(LPDIRECT3DDEVICE9 iface, UINT StreamNumber, UINT Divider);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetStreamSourceFreq(LPDIRECT3DDEVICE9 iface, UINT StreamNumber, UINT* Divider);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetIndices(LPDIRECT3DDEVICE9 iface, IDirect3DIndexBuffer9* pIndexData);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetIndices(LPDIRECT3DDEVICE9 iface, IDirect3DIndexBuffer9** ppIndexData);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreatePixelShader(LPDIRECT3DDEVICE9 iface, CONST DWORD* pFunction, IDirect3DPixelShader9** ppShader);
+
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9* pShader);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9** ppShader);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetPixelShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT StartRegister, CONST float* pConstantData, UINT Vector4fCount);
@@ -422,9 +150,6 @@
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetPixelShaderConstantI(LPDIRECT3DDEVICE9 iface, UINT StartRegister, int* pConstantData, UINT Vector4iCount);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_SetPixelShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT StartRegister, CONST BOOL* pConstantData, UINT BoolCount);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_GetPixelShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT StartRegister, BOOL* pConstantData, UINT BoolCount);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawRectPatch(LPDIRECT3DDEVICE9 iface, UINT Handle, CONST float* pNumSegs, CONST D3DRECTPATCH_INFO* pRectPatchInfo);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DrawTriPatch(LPDIRECT3DDEVICE9 iface, UINT Handle, CONST float* pNumSegs, CONST D3DTRIPATCH_INFO* pTriPatchInfo);
-extern HRESULT  WINAPI  IDirect3DDevice9Impl_DeletePatch(LPDIRECT3DDEVICE9 iface, UINT Handle);
 extern HRESULT  WINAPI  IDirect3DDevice9Impl_CreateQuery(LPDIRECT3DDEVICE9 iface, D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery);
 
 
@@ -440,7 +165,7 @@
 /*****************************************************************************
  * IDirect3DVolume9 implementation structure
  */
-struct IDirect3DVolume9Impl
+typedef struct IDirect3DVolume9Impl
 {
     /* IUnknown fields */
     IDirect3DVolume9Vtbl   *lpVtbl;
@@ -448,23 +173,7 @@
 
     /* IDirect3DVolume9 fields */
     IWineD3DVolume         *wineD3DVolume;
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI IDirect3DVolume9Impl_QueryInterface(LPDIRECT3DVOLUME9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI   IDirect3DVolume9Impl_AddRef(LPDIRECT3DVOLUME9 iface);
-extern ULONG WINAPI   IDirect3DVolume9Impl_Release(LPDIRECT3DVOLUME9 iface);
-
-/* IDirect3DVolume9: */
-extern HRESULT WINAPI IDirect3DVolume9Impl_GetDevice(LPDIRECT3DVOLUME9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI IDirect3DVolume9Impl_SetPrivateData(LPDIRECT3DVOLUME9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT WINAPI IDirect3DVolume9Impl_GetPrivateData(LPDIRECT3DVOLUME9 iface, REFGUID  refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT WINAPI IDirect3DVolume9Impl_FreePrivateData(LPDIRECT3DVOLUME9 iface, REFGUID refguid);
-extern HRESULT WINAPI IDirect3DVolume9Impl_GetContainer(LPDIRECT3DVOLUME9 iface, REFIID riid, void** ppContainer);
-extern HRESULT WINAPI IDirect3DVolume9Impl_GetDesc(LPDIRECT3DVOLUME9 iface, D3DVOLUME_DESC* pDesc);
-extern HRESULT WINAPI IDirect3DVolume9Impl_LockBox(LPDIRECT3DVOLUME9 iface, D3DLOCKED_BOX* pLockedVolume, CONST D3DBOX* pBox, DWORD Flags);
-extern HRESULT WINAPI IDirect3DVolume9Impl_UnlockBox(LPDIRECT3DVOLUME9 iface);
-
+} IDirect3DVolume9Impl;
 
 /* ------------------- */
 /* IDirect3DSwapChain9 */
@@ -478,34 +187,15 @@
 /*****************************************************************************
  * IDirect3DSwapChain9 implementation structure
  */
-struct IDirect3DSwapChain9Impl
+typedef struct IDirect3DSwapChain9Impl
 {
     /* IUnknown fields */
     IDirect3DSwapChain9Vtbl *lpVtbl;
     DWORD                   ref;
 
     /* IDirect3DSwapChain9 fields */
-    IDirect3DDevice9Impl   *Device;
-    IDirect3DSurface9Impl  *frontBuffer;
-    IDirect3DSurface9Impl  *backBuffer;
-    IDirect3DSurface9Impl  *depthStencilBuffer;
-    D3DPRESENT_PARAMETERS   PresentParms;        
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_QueryInterface(LPDIRECT3DSWAPCHAIN9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI   IDirect3DSwapChain9Impl_AddRef(LPDIRECT3DSWAPCHAIN9 iface);
-extern ULONG WINAPI   IDirect3DSwapChain9Impl_Release(LPDIRECT3DSWAPCHAIN9 iface);
-
-/* IDirect3DSwapChain9: */
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_Present(LPDIRECT3DSWAPCHAIN9 iface, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion, DWORD dwFlags);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetFrontBufferData(LPDIRECT3DSWAPCHAIN9 iface, IDirect3DSurface9* pDestSurface);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetBackBuffer(LPDIRECT3DSWAPCHAIN9 iface, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetRasterStatus(LPDIRECT3DSWAPCHAIN9 iface, D3DRASTER_STATUS* pRasterStatus);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetDisplayMode(LPDIRECT3DSWAPCHAIN9 iface, D3DDISPLAYMODE* pMode);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetDevice(LPDIRECT3DSWAPCHAIN9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI IDirect3DSwapChain9Impl_GetPresentParameters(LPDIRECT3DSWAPCHAIN9 iface, D3DPRESENT_PARAMETERS* pPresentationParameters);
-
+    IWineD3DSwapChain      *wineD3DSwapChain;    
+} IDirect3DSwapChain9Impl;
 
 /* ------------------ */
 /* IDirect3DResource9 */
@@ -519,7 +209,7 @@
 /*****************************************************************************
  * IDirect3DResource9 implementation structure
  */
-struct IDirect3DResource9Impl
+typedef struct IDirect3DResource9Impl
 {
     /* IUnknown fields */
     IDirect3DResource9Vtbl *lpVtbl;
@@ -527,7 +217,7 @@
 
     /* IDirect3DResource9 fields */
     IWineD3DResource       *wineD3DResource;
-};
+} IDirect3DResource9Impl;
 
 /* IUnknown: */
 extern HRESULT WINAPI         IDirect3DResource9Impl_QueryInterface(LPDIRECT3DRESOURCE9 iface,REFIID refiid,LPVOID *obj);
@@ -544,7 +234,6 @@
 extern void     WINAPI        IDirect3DResource9Impl_PreLoad(LPDIRECT3DRESOURCE9 iface);
 extern D3DRESOURCETYPE WINAPI IDirect3DResource9Impl_GetType(LPDIRECT3DRESOURCE9 iface);
 
-
 /* ----------------- */
 /* IDirect3DSurface9 */
 /* ----------------- */
@@ -557,7 +246,7 @@
 /*****************************************************************************
  * IDirect3DSurface9 implementation structure
  */
-struct IDirect3DSurface9Impl
+typedef struct IDirect3DSurface9Impl
 {
     /* IUnknown fields */
     IDirect3DSurface9Vtbl  *lpVtbl;
@@ -566,31 +255,7 @@
     /* IDirect3DResource9 fields */
     IWineD3DSurface        *wineD3DSurface;
 
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI IDirect3DSurface9Impl_QueryInterface(LPDIRECT3DSURFACE9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI   IDirect3DSurface9Impl_AddRef(LPDIRECT3DSURFACE9 iface);
-extern ULONG WINAPI   IDirect3DSurface9Impl_Release(LPDIRECT3DSURFACE9 iface);
-
-/* IDirect3DSurface9: (Inherited from IDirect3DResource9) */
-extern HRESULT WINAPI IDirect3DSurface9Impl_GetDevice(LPDIRECT3DSURFACE9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI IDirect3DSurface9Impl_SetPrivateData(LPDIRECT3DSURFACE9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT WINAPI IDirect3DSurface9Impl_GetPrivateData(LPDIRECT3DSURFACE9 iface, REFGUID refguid, void* pData,DWORD* pSizeOfData);
-extern HRESULT WINAPI IDirect3DSurface9Impl_FreePrivateData(LPDIRECT3DSURFACE9 iface, REFGUID refguid);
-extern DWORD   WINAPI IDirect3DSurface9Impl_SetPriority(LPDIRECT3DSURFACE9 iface, DWORD PriorityNew);
-extern DWORD   WINAPI IDirect3DSurface9Impl_GetPriority(LPDIRECT3DSURFACE9 iface);
-extern void    WINAPI IDirect3DSurface9Impl_PreLoad(LPDIRECT3DSURFACE9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DSurface9Impl_GetType(LPDIRECT3DSURFACE9 iface);
-
-/* IDirect3DSurface9: */
-extern HRESULT WINAPI IDirect3DSurface9Impl_GetContainer(LPDIRECT3DSURFACE9 iface, REFIID riid, void** ppContainer);
-extern HRESULT WINAPI IDirect3DSurface9Impl_GetDesc(LPDIRECT3DSURFACE9 iface, D3DSURFACE_DESC *pDesc);
-extern HRESULT WINAPI IDirect3DSurface9Impl_LockRect(LPDIRECT3DSURFACE9 iface, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags);
-extern HRESULT WINAPI IDirect3DSurface9Impl_UnlockRect(LPDIRECT3DSURFACE9 iface);
-extern HRESULT WINAPI IDirect3DSurface9Impl_GetDC(LPDIRECT3DSURFACE9 iface, HDC* phdc);
-extern HRESULT WINAPI IDirect3DSurface9Impl_ReleaseDC(LPDIRECT3DSURFACE9 iface, HDC hdc);
-
+} IDirect3DSurface9Impl;
 
 /* ---------------------- */
 /* IDirect3DVertexBuffer9 */
@@ -604,7 +269,7 @@
 /*****************************************************************************
  * IDirect3DVertexBuffer9 implementation structure
  */
-struct IDirect3DVertexBuffer9Impl
+typedef struct IDirect3DVertexBuffer9Impl
 {
     /* IUnknown fields */
     IDirect3DVertexBuffer9Vtbl *lpVtbl;
@@ -612,28 +277,8 @@
 
     /* IDirect3DResource9 fields */
     IWineD3DVertexBuffer   *wineD3DVertexBuffer;
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DVertexBuffer9Impl_QueryInterface(LPDIRECT3DVERTEXBUFFER9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG WINAPI           IDirect3DVertexBuffer9Impl_AddRef(LPDIRECT3DVERTEXBUFFER9 iface);
-extern ULONG WINAPI           IDirect3DVertexBuffer9Impl_Release(LPDIRECT3DVERTEXBUFFER9 iface);
-
-/* IDirect3DVertexBuffer9: (Inherited from IDirect3DResource9) */
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_GetDevice(LPDIRECT3DVERTEXBUFFER9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_SetPrivateData(LPDIRECT3DVERTEXBUFFER9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_GetPrivateData(LPDIRECT3DVERTEXBUFFER9 iface, REFGUID refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_FreePrivateData(LPDIRECT3DVERTEXBUFFER9 iface, REFGUID refguid);
-extern DWORD    WINAPI        IDirect3DVertexBuffer9Impl_SetPriority(LPDIRECT3DVERTEXBUFFER9 iface, DWORD PriorityNew);
-extern DWORD    WINAPI        IDirect3DVertexBuffer9Impl_GetPriority(LPDIRECT3DVERTEXBUFFER9 iface);
-extern void     WINAPI        IDirect3DVertexBuffer9Impl_PreLoad(LPDIRECT3DVERTEXBUFFER9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DVertexBuffer9Impl_GetType(LPDIRECT3DVERTEXBUFFER9 iface);
-
-/* IDirect3DVertexBuffer9: */
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_Lock(LPDIRECT3DVERTEXBUFFER9 iface, UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_Unlock(LPDIRECT3DVERTEXBUFFER9 iface);
-extern HRESULT  WINAPI        IDirect3DVertexBuffer9Impl_GetDesc(LPDIRECT3DVERTEXBUFFER9 iface, D3DVERTEXBUFFER_DESC *pDesc);
 
+} IDirect3DVertexBuffer9Impl;
 
 /* --------------------- */
 /* IDirect3DIndexBuffer9 */
@@ -647,7 +292,7 @@
 /*****************************************************************************
  * IDirect3DIndexBuffer9 implementation structure
  */
-struct IDirect3DIndexBuffer9Impl
+typedef struct IDirect3DIndexBuffer9Impl
 {
     /* IUnknown fields */
     IDirect3DIndexBuffer9Vtbl *lpVtbl;
@@ -655,28 +300,7 @@
 
     /* IDirect3DResource9 fields */
     IWineD3DIndexBuffer    *wineD3DIndexBuffer;
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DIndexBuffer9Impl_QueryInterface(LPDIRECT3DINDEXBUFFER9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG WINAPI           IDirect3DIndexBuffer9Impl_AddRef(LPDIRECT3DINDEXBUFFER9 iface);
-extern ULONG WINAPI           IDirect3DIndexBuffer9Impl_Release(LPDIRECT3DINDEXBUFFER9 iface);
-
-/* IDirect3DIndexBuffer9: (Inherited from IDirect3DResource9) */
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_GetDevice(LPDIRECT3DINDEXBUFFER9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_SetPrivateData(LPDIRECT3DINDEXBUFFER9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_GetPrivateData(LPDIRECT3DINDEXBUFFER9 iface, REFGUID refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_FreePrivateData(LPDIRECT3DINDEXBUFFER9 iface, REFGUID refguid);
-extern DWORD    WINAPI        IDirect3DIndexBuffer9Impl_SetPriority(LPDIRECT3DINDEXBUFFER9 iface, DWORD PriorityNew);
-extern DWORD    WINAPI        IDirect3DIndexBuffer9Impl_GetPriority(LPDIRECT3DINDEXBUFFER9 iface);
-extern void     WINAPI        IDirect3DIndexBuffer9Impl_PreLoad(LPDIRECT3DINDEXBUFFER9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DIndexBuffer9Impl_GetType(LPDIRECT3DINDEXBUFFER9 iface);
-
-/* IDirect3DIndexBuffer9: */
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_Lock(LPDIRECT3DINDEXBUFFER9 iface, UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_Unlock(LPDIRECT3DINDEXBUFFER9 iface);
-extern HRESULT  WINAPI        IDirect3DIndexBuffer9Impl_GetDesc(LPDIRECT3DINDEXBUFFER9 iface, D3DINDEXBUFFER_DESC *pDesc);
-
+} IDirect3DIndexBuffer9Impl;
 
 /* --------------------- */
 /* IDirect3DBaseTexture9 */
@@ -690,7 +314,7 @@
 /*****************************************************************************
  * IDirect3DBaseTexture9 implementation structure
  */
-struct IDirect3DBaseTexture9Impl
+typedef struct IDirect3DBaseTexture9Impl
 {
     /* IUnknown fields */
     IDirect3DBaseTexture9Vtbl *lpVtbl;
@@ -698,7 +322,8 @@
 
     /* IDirect3DResource9 fields */
     IWineD3DBaseTexture    *wineD3DBaseTexture;
-};
+    
+} IDirect3DBaseTexture9Impl;
 
 /* IUnknown: */
 extern HRESULT WINAPI         IDirect3DBaseTexture9Impl_QueryInterface(LPDIRECT3DBASETEXTURE9 iface,REFIID refiid,LPVOID *obj);
@@ -723,113 +348,45 @@
 extern D3DTEXTUREFILTERTYPE WINAPI IDirect3DBaseTexture9Impl_GetAutoGenFilterType(LPDIRECT3DBASETEXTURE9 iface);
 extern void     WINAPI        IDirect3DBaseTexture9Impl_GenerateMipSubLevels(LPDIRECT3DBASETEXTURE9 iface);
 
-
-/* --------------------- */
-/* IDirect3DCubeTexture9 */
-/* --------------------- */
+/* ----------------- */
+/* IDirect3DTexture9 */
+/* ----------------- */
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
  */
-extern IDirect3DCubeTexture9Vtbl Direct3DCubeTexture9_Vtbl;
+extern IDirect3DTexture9Vtbl Direct3DTexture9_Vtbl;
 
 /*****************************************************************************
- * IDirect3DCubeTexture9 implementation structure
+ * IDirect3DTexture9 implementation structure
  */
-struct IDirect3DCubeTexture9Impl
+typedef struct IDirect3DTexture9Impl
 {
     /* IUnknown fields */
-    IDirect3DCubeTexture9Vtbl *lpVtbl;
+    IDirect3DTexture9Vtbl  *lpVtbl;
     DWORD                     ref;
-
     /* IDirect3DResource9 fields */
-    IWineD3DCubeTexture      *wineD3DCubeTexture;
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DCubeTexture9Impl_QueryInterface(LPDIRECT3DCUBETEXTURE9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG WINAPI           IDirect3DCubeTexture9Impl_AddRef(LPDIRECT3DCUBETEXTURE9 iface);
-extern ULONG WINAPI           IDirect3DCubeTexture9Impl_Release(LPDIRECT3DCUBETEXTURE9 iface);
-
-/* IDirect3DCubeTexture9: (Inherited from IDirect3DResource9) */
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_GetDevice(LPDIRECT3DCUBETEXTURE9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_SetPrivateData(LPDIRECT3DCUBETEXTURE9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_GetPrivateData(LPDIRECT3DCUBETEXTURE9 iface, REFGUID refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_FreePrivateData(LPDIRECT3DCUBETEXTURE9 iface, REFGUID refguid);
-extern DWORD    WINAPI        IDirect3DCubeTexture9Impl_SetPriority(LPDIRECT3DCUBETEXTURE9 iface, DWORD PriorityNew);
-extern DWORD    WINAPI        IDirect3DCubeTexture9Impl_GetPriority(LPDIRECT3DCUBETEXTURE9 iface);
-extern void     WINAPI        IDirect3DCubeTexture9Impl_PreLoad(LPDIRECT3DCUBETEXTURE9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DCubeTexture9Impl_GetType(LPDIRECT3DCUBETEXTURE9 iface);
-
-/* IDirect3DCubeTexture9: (Inherited from IDirect3DBaseTexture9) */
-extern DWORD    WINAPI        IDirect3DCubeTexture9Impl_SetLOD(LPDIRECT3DCUBETEXTURE9 iface, DWORD LODNew);
-extern DWORD    WINAPI        IDirect3DCubeTexture9Impl_GetLOD(LPDIRECT3DCUBETEXTURE9 iface);
-extern DWORD    WINAPI        IDirect3DCubeTexture9Impl_GetLevelCount(LPDIRECT3DCUBETEXTURE9 iface);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_SetAutoGenFilterType(LPDIRECT3DCUBETEXTURE9 iface, D3DTEXTUREFILTERTYPE FilterType);
-extern D3DTEXTUREFILTERTYPE WINAPI IDirect3DCubeTexture9Impl_GetAutoGenFilterType(LPDIRECT3DCUBETEXTURE9 iface);
-extern void     WINAPI        IDirect3DCubeTexture9Impl_GenerateMipSubLevels(LPDIRECT3DCUBETEXTURE9 iface);
-
-/* IDirect3DCubeTexture9 */
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_GetLevelDesc(LPDIRECT3DCUBETEXTURE9 iface, UINT Level, D3DSURFACE_DESC* pDesc);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_GetCubeMapSurface(LPDIRECT3DCUBETEXTURE9 iface, D3DCUBEMAP_FACES FaceType, UINT Level, IDirect3DSurface9** ppCubeMapSurface);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_LockRect(LPDIRECT3DCUBETEXTURE9 iface, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_UnlockRect(LPDIRECT3DCUBETEXTURE9 iface, D3DCUBEMAP_FACES FaceType, UINT Level);
-extern HRESULT  WINAPI        IDirect3DCubeTexture9Impl_AddDirtyRect(LPDIRECT3DCUBETEXTURE9 iface, D3DCUBEMAP_FACES FaceType, CONST RECT* pDirtyRect);
+    IWineD3DTexture        *wineD3DTexture;
 
-
-/* ----------------- */
-/* IDirect3DTexture9 */
-/* ----------------- */
+} IDirect3DTexture9Impl;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
  */
-extern IDirect3DTexture9Vtbl Direct3DTexture9_Vtbl;
+extern IDirect3DCubeTexture9Vtbl Direct3DCubeTexture9_Vtbl;
 
 /*****************************************************************************
- * IDirect3DTexture9 implementation structure
+ * IDirect3DCubeTexture9 implementation structure
  */
-struct IDirect3DTexture9Impl
+typedef struct IDirect3DCubeTexture9Impl
 {
     /* IUnknown fields */
-    IDirect3DTexture9Vtbl  *lpVtbl;
+    IDirect3DCubeTexture9Vtbl  *lpVtbl;
     DWORD                   ref;
-
     /* IDirect3DResource9 fields */
-    IWineD3DTexture        *wineD3DTexture;
-
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DTexture9Impl_QueryInterface(LPDIRECT3DTEXTURE9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG WINAPI           IDirect3DTexture9Impl_AddRef(LPDIRECT3DTEXTURE9 iface);
-extern ULONG WINAPI           IDirect3DTexture9Impl_Release(LPDIRECT3DTEXTURE9 iface);
-
-/* IDirect3DTexture9: (Inherited from IDirect3DResource9) */
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_GetDevice(LPDIRECT3DTEXTURE9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_SetPrivateData(LPDIRECT3DTEXTURE9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_GetPrivateData(LPDIRECT3DTEXTURE9 iface, REFGUID refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_FreePrivateData(LPDIRECT3DTEXTURE9 iface, REFGUID refguid);
-extern DWORD    WINAPI        IDirect3DTexture9Impl_SetPriority(LPDIRECT3DTEXTURE9 iface, DWORD PriorityNew);
-extern DWORD    WINAPI        IDirect3DTexture9Impl_GetPriority(LPDIRECT3DTEXTURE9 iface);
-extern void     WINAPI        IDirect3DTexture9Impl_PreLoad(LPDIRECT3DTEXTURE9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DTexture9Impl_GetType(LPDIRECT3DTEXTURE9 iface);
-
-/* IDirect3DTexture9: (Inherited from IDirect3DBaseTexture9) */
-extern DWORD    WINAPI        IDirect3DTexture9Impl_SetLOD(LPDIRECT3DTEXTURE9 iface, DWORD LODNew);
-extern DWORD    WINAPI        IDirect3DTexture9Impl_GetLOD(LPDIRECT3DTEXTURE9 iface);
-extern DWORD    WINAPI        IDirect3DTexture9Impl_GetLevelCount(LPDIRECT3DTEXTURE9 iface);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_SetAutoGenFilterType(LPDIRECT3DTEXTURE9 iface, D3DTEXTUREFILTERTYPE FilterType);
-extern D3DTEXTUREFILTERTYPE WINAPI IDirect3DTexture9Impl_GetAutoGenFilterType(LPDIRECT3DTEXTURE9 iface);
-extern void     WINAPI         IDirect3DTexture9Impl_GenerateMipSubLevels(LPDIRECT3DTEXTURE9 iface);
-
-/* IDirect3DTexture9: */
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_GetLevelDesc(LPDIRECT3DTEXTURE9 iface, UINT Level, D3DSURFACE_DESC* pDesc);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_GetSurfaceLevel(LPDIRECT3DTEXTURE9 iface, UINT Level, IDirect3DSurface9** ppSurfaceLevel);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_LockRect(LPDIRECT3DTEXTURE9 iface, UINT Level, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_UnlockRect(LPDIRECT3DTEXTURE9 iface, UINT Level);
-extern HRESULT  WINAPI        IDirect3DTexture9Impl_AddDirtyRect(LPDIRECT3DTEXTURE9 iface, CONST RECT* pDirtyRect);
+    IWineD3DCubeTexture        *wineD3DCubeTexture;
 
+} IDirect3DCubeTexture9Impl;
 
 /* ----------------------- */
 /* IDirect3DVolumeTexture9 */
@@ -843,7 +400,7 @@
 /*****************************************************************************
  * IDirect3DVolumeTexture9 implementation structure
  */
-struct IDirect3DVolumeTexture9Impl
+typedef struct IDirect3DVolumeTexture9Impl
 {
     /* IUnknown fields */
     IDirect3DVolumeTexture9Vtbl *lpVtbl;
@@ -851,38 +408,7 @@
 
     /* IDirect3DResource9 fields */
     IWineD3DVolumeTexture      *wineD3DVolumeTexture;
-};
-
-/* IUnknown: */
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_QueryInterface(LPDIRECT3DVOLUMETEXTURE9 iface,REFIID refiid,LPVOID *obj);
-extern ULONG    WINAPI        IDirect3DVolumeTexture9Impl_AddRef(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern ULONG    WINAPI        IDirect3DVolumeTexture9Impl_Release(LPDIRECT3DVOLUMETEXTURE9 iface);
-
-/* IDirect3DVolumeTexture9: (Inherited from IDirect3DResource9) */
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_GetDevice(LPDIRECT3DVOLUMETEXTURE9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_SetPrivateData(LPDIRECT3DVOLUMETEXTURE9 iface, REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_GetPrivateData(LPDIRECT3DVOLUMETEXTURE9 iface, REFGUID refguid, void* pData, DWORD* pSizeOfData);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_FreePrivateData(LPDIRECT3DVOLUMETEXTURE9 iface, REFGUID refguid);
-extern DWORD    WINAPI        IDirect3DVolumeTexture9Impl_SetPriority(LPDIRECT3DVOLUMETEXTURE9 iface, DWORD PriorityNew);
-extern DWORD    WINAPI        IDirect3DVolumeTexture9Impl_GetPriority(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern void     WINAPI        IDirect3DVolumeTexture9Impl_PreLoad(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern D3DRESOURCETYPE WINAPI IDirect3DVolumeTexture9Impl_GetType(LPDIRECT3DVOLUMETEXTURE9 iface);
-
-/* IDirect3DVolumeTexture9: (Inherited from IDirect3DBaseTexture9) */
-extern DWORD    WINAPI        IDirect3DVolumeTexture9Impl_SetLOD(LPDIRECT3DVOLUMETEXTURE9 iface, DWORD LODNew);
-extern DWORD    WINAPI        IDirect3DVolumeTexture9Impl_GetLOD(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern DWORD    WINAPI        IDirect3DVolumeTexture9Impl_GetLevelCount(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_SetAutoGenFilterType(LPDIRECT3DVOLUMETEXTURE9 iface, D3DTEXTUREFILTERTYPE FilterType);
-extern D3DTEXTUREFILTERTYPE WINAPI IDirect3DVolumeTexture9Impl_GetAutoGenFilterType(LPDIRECT3DVOLUMETEXTURE9 iface);
-extern void     WINAPI         IDirect3DVolumeTexture9Impl_GenerateMipSubLevels(LPDIRECT3DVOLUMETEXTURE9 iface);
-
-/* IDirect3DVolumeTexture9: */
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_GetLevelDesc(LPDIRECT3DVOLUMETEXTURE9 iface, UINT Level, D3DVOLUME_DESC *pDesc);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_GetVolumeLevel(LPDIRECT3DVOLUMETEXTURE9 iface, UINT Level, IDirect3DVolume9** ppVolumeLevel);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_LockBox(LPDIRECT3DVOLUMETEXTURE9 iface, UINT Level, D3DLOCKED_BOX* pLockedVolume, CONST D3DBOX* pBox, DWORD Flags);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_UnlockBox(LPDIRECT3DVOLUMETEXTURE9 iface, UINT Level);
-extern HRESULT  WINAPI        IDirect3DVolumeTexture9Impl_AddDirtyBox(LPDIRECT3DVOLUMETEXTURE9 iface, CONST D3DBOX* pDirtyBox);
-
+} IDirect3DVolumeTexture9Impl;
 
 /* ----------------------- */
 /* IDirect3DStateBlock9 */
@@ -896,91 +422,14 @@
 /*****************************************************************************
  * IDirect3DStateBlock9 implementation structure
  */
-struct  IDirect3DStateBlock9Impl {
+typedef struct IDirect3DStateBlock9Impl {
   /* IUnknown fields */
   IDirect3DStateBlock9Vtbl *lpVtbl;
   DWORD                     ref;
 
   /* IDirect3DStateBlock9 fields */
-  IDirect3DDevice9Impl*     Device;
-
-  D3DSTATEBLOCKTYPE         blockType;
-
-  SAVEDSTATES               Changed;
-  SAVEDSTATES               Set;
-  
-  /* Light Enable */
-  BOOL                      lightEnable[MAX_ACTIVE_LIGHTS];
-  
-  /* ClipPlane */
-  double                    clipplane[MAX_CLIPPLANES][4];
-  
-  /* Stream Source */
-  UINT                      stream_stride[MAX_STREAMS];
-  IDirect3DVertexBuffer9*   stream_source[MAX_STREAMS];
-  BOOL                      streamIsUP;
-
-  /* Indices */
-  IDirect3DIndexBuffer9*    pIndexData;
-  UINT                      baseVertexIndex;
-  
-  /* Texture */
-  IDirect3DBaseTexture9*    textures[8];
-  int                       textureDimensions[8];
-  /* Texture State Stage */
-  DWORD                     texture_state[8][HIGHEST_TEXTURE_STATE];
-  
-  /* RenderState */
-  DWORD                     renderstate[HIGHEST_RENDER_STATE];
-  
-  /* Transform */
-  D3DMATRIX                 transforms[HIGHEST_TRANSFORMSTATE];
-  
-
-  /* ViewPort */
-  D3DVIEWPORT9              viewport;
-  
-  /* Lights */
-  D3DLIGHT9                 lights[MAX_ACTIVE_LIGHTS];
-  
-  /* Material */
-  D3DMATERIAL9              material;
-
-  DWORD                     FVF;
-  
-  /* Vertex Shader */
-  IDirect3DVertexShader9*   VertexShader;
-
-  /* Vertex Shader Declaration */
-  IDirect3DVertexDeclaration9Impl* vertexDecl;
-  
-  /* Pixel Shader */
-  IDirect3DPixelShader9*    PixelShader;
-  
-  /* Indexed Vertex Blending */
-  D3DVERTEXBLENDFLAGS       vertex_blend;
-  FLOAT                     tween_factor;
-
-  /* Vertex Shader Constant */
-  D3DSHADERVECTORF          vertexShaderConstantF[D3D_VSHADER_MAX_CONSTANTS];
-  D3DSHADERVECTORI          vertexShaderConstantI[D3D_VSHADER_MAX_CONSTANTS];
-  BOOL                      vertexShaderConstantB[D3D_VSHADER_MAX_CONSTANTS];
-  /* Pixel Shader Constant */
-  D3DSHADERVECTORF          pixelShaderConstantF[D3D_PSHADER_MAX_CONSTANTS];
-  D3DSHADERVECTORI          pixelShaderConstantI[D3D_PSHADER_MAX_CONSTANTS];
-  BOOL                      pixelShaderConstantB[D3D_PSHADER_MAX_CONSTANTS];
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DStateBlock9Impl_QueryInterface(LPDIRECT3DSTATEBLOCK9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI           IDirect3DStateBlock9Impl_AddRef(LPDIRECT3DSTATEBLOCK9 iface);
-extern ULONG WINAPI           IDirect3DStateBlock9Impl_Release(LPDIRECT3DSTATEBLOCK9 iface);
-
-/* IDirect3DStateBlock9: */
-extern HRESULT WINAPI         IDirect3DStateBlock9Impl_GetDevice(LPDIRECT3DSTATEBLOCK9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI         IDirect3DStateBlock9Impl_Capture(LPDIRECT3DSTATEBLOCK9 iface);
-extern HRESULT WINAPI         IDirect3DStateBlock9Impl_Apply(LPDIRECT3DSTATEBLOCK9 iface);
-
+  IWineD3DStateBlock       *wineD3DStateBlock;  
+} IDirect3DStateBlock9Impl;
 
 /* --------------------------- */
 /* IDirect3DVertexDeclaration9 */
@@ -994,24 +443,14 @@
 /*****************************************************************************
  * IDirect3DVertexShaderDeclaration implementation structure
  */
-struct IDirect3DVertexDeclaration9Impl {
+typedef struct IDirect3DVertexDeclaration9Impl {
   /* IUnknown fields */
   IDirect3DVertexDeclaration9Vtbl *lpVtbl;
   DWORD   ref;
 
   /* IDirect3DVertexDeclaration9 fields */
   IWineD3DVertexDeclaration *wineD3DVertexDeclaration;
-};
-
-/* IUnknown: */
-extern HRESULT  WINAPI      IDirect3DVertexDeclaration9Impl_QueryInterface(LPDIRECT3DVERTEXDECLARATION9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG    WINAPI      IDirect3DVertexDeclaration9Impl_AddRef(LPDIRECT3DVERTEXDECLARATION9 iface);
-extern ULONG    WINAPI      IDirect3DVertexDeclaration9Impl_Release(LPDIRECT3DVERTEXDECLARATION9 iface);
-
-/* IDirect3DVertexDeclaration9: */
-extern HRESULT  WINAPI      IDirect3DVertexDeclaration9Impl_GetDevice(LPDIRECT3DVERTEXDECLARATION9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT  WINAPI      IDirect3DVertexDeclaration9Impl_GetDeclaration(LPDIRECT3DVERTEXDECLARATION9 iface, D3DVERTEXELEMENT9* pDecl, UINT* pNumElements);
-
+} IDirect3DVertexDeclaration9Impl;
 
 /* ---------------------- */
 /* IDirect3DVertexShader9 */
@@ -1025,35 +464,14 @@
 /*****************************************************************************
  * IDirect3DVertexShader implementation structure
  */
-struct IDirect3DVertexShader9Impl {
+typedef struct IDirect3DVertexShader9Impl {
   /* IUnknown fields */
   IDirect3DVertexShader9Vtbl *lpVtbl;
   DWORD ref;
 
-  /* IDirect3DVertexDeclaration9 fields */
-  IDirect3DDevice9Impl* Device;
-
-  DWORD* function;
-  UINT functionLength;
-  DWORD usage; /* 0 || D3DUSAGE_SOFTWAREPROCESSING */
-  DWORD version;
-  /* run time datas */
-  /*
-  VSHADERDATA* data;
-  VSHADERINPUTDATA input;
-  VSHADEROUTPUTDATA output;
-  */
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DVertexShader9Impl_QueryInterface(LPDIRECT3DVERTEXSHADER9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI           IDirect3DVertexShader9Impl_AddRef(LPDIRECT3DVERTEXSHADER9 iface);
-extern ULONG WINAPI           IDirect3DVertexShader9Impl_Release(LPDIRECT3DVERTEXSHADER9 iface);
-
-/* IDirect3DVertexShader9: */
-extern HRESULT WINAPI         IDirect3DVertexShader9Impl_GetDevice(LPDIRECT3DVERTEXSHADER9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI         IDirect3DVertexShader9Impl_GetFunction(LPDIRECT3DVERTEXSHADER9 iface, VOID* pData, UINT* pSizeOfData);
-
+  /* IDirect3DVertexShader9 fields */
+  IWineD3DVertexShader       *wineD3DVertexShader;
+} IDirect3DVertexShader9Impl;
 
 /* --------------------- */
 /* IDirect3DPixelShader9 */
@@ -1067,34 +485,14 @@
 /*****************************************************************************
  * IDirect3DPixelShader implementation structure
  */
-struct IDirect3DPixelShader9Impl { 
+typedef struct IDirect3DPixelShader9Impl { 
   /* IUnknown fields */
   IDirect3DPixelShader9Vtbl *lpVtbl;
   DWORD ref;
 
   /* IDirect3DPixelShader9 fields */
-  IDirect3DDevice9Impl* Device;
-
-  DWORD* function;
-  UINT functionLength;
-  DWORD version;
-  /* run time datas */
-  /*
-  PSHADERDATA* data;
-  PSHADERINPUTDATA input;
-  PSHADEROUTPUTDATA output;
-  */
-};
-
-/* IUnknown: */
-extern HRESULT WINAPI         IDirect3DPixelShader9Impl_QueryInterface(LPDIRECT3DPIXELSHADER9 iface, REFIID refiid, LPVOID* obj);
-extern ULONG WINAPI           IDirect3DPixelShader9Impl_AddRef(LPDIRECT3DPIXELSHADER9 iface);
-extern ULONG WINAPI           IDirect3DPixelShader9Impl_Release(LPDIRECT3DPIXELSHADER9 iface);
-
-/* IDirect3DPixelShader9: */
-extern HRESULT WINAPI         IDirect3DPixelShader9Impl_GetDevice(LPDIRECT3DPIXELSHADER9 iface, IDirect3DDevice9** ppDevice);
-extern HRESULT WINAPI         IDirect3DPixelShader9Impl_GetFunction(LPDIRECT3DPIXELSHADER9 iface, VOID* pData, UINT* pSizeOfData);
-
+  IWineD3DPixelShader       *wineD3DPixelShader;
+} IDirect3DPixelShader9Impl;
 
 /* --------------- */
 /* IDirect3DQuery9 */
@@ -1128,4 +526,15 @@
                                           IWineD3DVolume **ppVolume, 
                                           HANDLE   * pSharedHandle);
 
+extern HRESULT WINAPI D3D9CB_CreateDepthStencilSurface(IUnknown *device, UINT Width, UINT Height, 
+                                         D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, 
+                                         DWORD MultisampleQuality, BOOL Discard,
+                                         IWineD3DSurface** ppSurface, HANDLE* pSharedHandle);
+                                         
+extern HRESULT WINAPI D3D9CB_CreateRenderTarget(IUnknown *device, UINT Width, UINT Height, 
+                                         D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, 
+                                         DWORD MultisampleQuality, BOOL Lockable, 
+                                         IWineD3DSurface** ppSurface, HANDLE* pSharedHandle);
+
+                                         
 #endif /* __WINE_D3D9_PRIVATE_H */
diff -urN wine.20050419/dlls/d3d9/d3dcore_gl.h wine.20050419.dx9/dlls/d3d9/d3dcore_gl.h
--- wine.20050419/dlls/d3d9/d3dcore_gl.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/d3dcore_gl.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,878 @@
+/*
+ * Direct3D gl definitions
+ *
+ * Copyright 2003-2004 Raphael Junqueira
+ * Copyright 2004 Christian Costa
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __WINE_D3DCORE_GL_H
+#define __WINE_D3DCORE_GL_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#define XMD_H /* This is to prevent the Xmd.h inclusion bug :-/ */
+#include <GL/gl.h>
+#include <GL/glx.h>
+#ifdef HAVE_GL_GLEXT_H
+# include <GL/glext.h>
+#endif
+#undef  XMD_H
+
+#undef  APIENTRY
+#define APIENTRY
+
+/**********************************
+ * OpenGL Extensions (EXT and ARB)
+ *  defines and functions pointer
+ */
+
+/* GL_ARB_vertex_blend */
+#ifndef GL_ARB_vertex_blend
+#define GL_ARB_vertex_blend 1
+#define GL_MAX_VERTEX_UNITS_ARB           0x86A4
+#define GL_ACTIVE_VERTEX_UNITS_ARB        0x86A5
+#define GL_WEIGHT_SUM_UNITY_ARB           0x86A6
+#define GL_VERTEX_BLEND_ARB               0x86A7
+#define GL_CURRENT_WEIGHT_ARB             0x86A8
+#define GL_WEIGHT_ARRAY_TYPE_ARB          0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_ARB        0x86AA
+#define GL_WEIGHT_ARRAY_SIZE_ARB          0x86AB
+#define GL_WEIGHT_ARRAY_POINTER_ARB       0x86AC
+#define GL_WEIGHT_ARRAY_ARB               0x86AD
+#define GL_MODELVIEW0_ARB                 0x1700
+#define GL_MODELVIEW1_ARB                 0x850A
+#define GL_MODELVIEW2_ARB                 0x8722
+#define GL_MODELVIEW3_ARB                 0x8723
+#define GL_MODELVIEW4_ARB                 0x8724
+#define GL_MODELVIEW5_ARB                 0x8725
+#define GL_MODELVIEW6_ARB                 0x8726
+#define GL_MODELVIEW7_ARB                 0x8727
+#define GL_MODELVIEW8_ARB                 0x8728
+#define GL_MODELVIEW9_ARB                 0x8729
+#define GL_MODELVIEW10_ARB                0x872A
+#define GL_MODELVIEW11_ARB                0x872B
+#define GL_MODELVIEW12_ARB                0x872C
+#define GL_MODELVIEW13_ARB                0x872D
+#define GL_MODELVIEW14_ARB                0x872E
+#define GL_MODELVIEW15_ARB                0x872F
+#define GL_MODELVIEW16_ARB                0x8730
+#define GL_MODELVIEW17_ARB                0x8731
+#define GL_MODELVIEW18_ARB                0x8732
+#define GL_MODELVIEW19_ARB                0x8733
+#define GL_MODELVIEW20_ARB                0x8734
+#define GL_MODELVIEW21_ARB                0x8735
+#define GL_MODELVIEW22_ARB                0x8736
+#define GL_MODELVIEW23_ARB                0x8737
+#define GL_MODELVIEW24_ARB                0x8738
+#define GL_MODELVIEW25_ARB                0x8739
+#define GL_MODELVIEW26_ARB                0x873A
+#define GL_MODELVIEW27_ARB                0x873B
+#define GL_MODELVIEW28_ARB                0x873C
+#define GL_MODELVIEW29_ARB                0x873D
+#define GL_MODELVIEW30_ARB                0x873E
+#define GL_MODELVIEW31_ARB                0x873F
+#endif
+/* GL_EXT_secondary_color */
+#ifndef GL_EXT_secondary_color
+#define GL_EXT_secondary_color 1
+#define GL_COLOR_SUM_EXT                     0x8458
+#define GL_CURRENT_SECONDARY_COLOR_EXT       0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT    0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT    0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT  0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define GL_SECONDARY_COLOR_ARRAY_EXT         0x845E
+#endif
+typedef void (APIENTRY * PGLFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
+typedef void (APIENTRY * PGLFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
+typedef void (APIENTRY * PGLFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
+typedef void (APIENTRY * PGLFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+/* GL_EXT_paletted_texture */
+#ifndef GL_EXT_paletted_texture
+#define GL_EXT_paletted_texture 1
+#define GL_COLOR_INDEX1_EXT               0x80E2
+#define GL_COLOR_INDEX2_EXT               0x80E3
+#define GL_COLOR_INDEX4_EXT               0x80E4
+#define GL_COLOR_INDEX8_EXT               0x80E5
+#define GL_COLOR_INDEX12_EXT              0x80E6
+#define GL_COLOR_INDEX16_EXT              0x80E7
+#define GL_TEXTURE_INDEX_SIZE_EXT         0x80ED
+#endif
+typedef void (APIENTRY * PGLFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+/* GL_EXT_point_parameters */
+#ifndef GL_EXT_point_parameters
+#define GL_EXT_point_parameters 1
+#define GL_POINT_SIZE_MIN_EXT             0x8126
+#define GL_POINT_SIZE_MAX_EXT             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_EXT  0x8128
+#define GL_DISTANCE_ATTENUATION_EXT       0x8129
+#endif
+typedef void (APIENTRY * PGLFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRY * PGLFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
+/* GL_EXT_texture_env_combine */
+#ifndef GL_EXT_texture_env_combine
+#define GL_EXT_texture_env_combine 1
+#define GL_COMBINE_EXT                    0x8570
+#define GL_COMBINE_RGB_EXT                0x8571
+#define GL_COMBINE_ALPHA_EXT              0x8572
+#define GL_RGB_SCALE_EXT                  0x8573
+#define GL_ADD_SIGNED_EXT                 0x8574
+#define GL_INTERPOLATE_EXT                0x8575
+#define GL_SUBTRACT_EXT                   0x84E7
+#define GL_CONSTANT_EXT                   0x8576
+#define GL_PRIMARY_COLOR_EXT              0x8577
+#define GL_PREVIOUS_EXT                   0x8578
+#define GL_SOURCE0_RGB_EXT                0x8580
+#define GL_SOURCE1_RGB_EXT                0x8581
+#define GL_SOURCE2_RGB_EXT                0x8582
+#define GL_SOURCE3_RGB_EXT                0x8583
+#define GL_SOURCE4_RGB_EXT                0x8584
+#define GL_SOURCE5_RGB_EXT                0x8585
+#define GL_SOURCE6_RGB_EXT                0x8586
+#define GL_SOURCE7_RGB_EXT                0x8587
+#define GL_SOURCE0_ALPHA_EXT              0x8588
+#define GL_SOURCE1_ALPHA_EXT              0x8589
+#define GL_SOURCE2_ALPHA_EXT              0x858A
+#define GL_SOURCE3_ALPHA_EXT              0x858B
+#define GL_SOURCE4_ALPHA_EXT              0x858C
+#define GL_SOURCE5_ALPHA_EXT              0x858D
+#define GL_SOURCE6_ALPHA_EXT              0x858E
+#define GL_SOURCE7_ALPHA_EXT              0x858F
+#define GL_OPERAND0_RGB_EXT               0x8590
+#define GL_OPERAND1_RGB_EXT               0x8591
+#define GL_OPERAND2_RGB_EXT               0x8592
+#define GL_OPERAND3_RGB_EXT               0x8593
+#define GL_OPERAND4_RGB_EXT               0x8594
+#define GL_OPERAND5_RGB_EXT               0x8595
+#define GL_OPERAND6_RGB_EXT               0x8596
+#define GL_OPERAND7_RGB_EXT               0x8597
+#define GL_OPERAND0_ALPHA_EXT             0x8598
+#define GL_OPERAND1_ALPHA_EXT             0x8599
+#define GL_OPERAND2_ALPHA_EXT             0x859A
+#define GL_OPERAND3_ALPHA_EXT             0x859B
+#define GL_OPERAND4_ALPHA_EXT             0x859C
+#define GL_OPERAND5_ALPHA_EXT             0x859D
+#define GL_OPERAND6_ALPHA_EXT             0x859E
+#define GL_OPERAND7_ALPHA_EXT             0x859F
+#endif
+/* GL_EXT_texture_env_dot3 */
+#ifndef GL_EXT_texture_env_dot3
+#define GL_EXT_texture_env_dot3 1
+#define GL_DOT3_RGB_EXT			  0x8740
+#define GL_DOT3_RGBA_EXT		  0x8741
+#endif
+/* GL_EXT_texture_lod_bias */
+#ifndef GL_EXT_texture_lod_bias
+#define GL_EXT_texture_lod_bias 1
+#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
+#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
+#define GL_TEXTURE_LOD_BIAS_EXT           0x8501
+#endif
+/* GL_ARB_texture_border_clamp */
+#ifndef GL_ARB_texture_border_clamp
+#define GL_ARB_texture_border_clamp 1
+#define GL_CLAMP_TO_BORDER_ARB            0x812D
+#endif
+/* GL_ARB_texture_mirrored_repeat (full support GL1.4) */
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_ARB_texture_mirrored_repeat 1
+#define GL_MIRRORED_REPEAT_ARB            0x8370
+#endif
+/* GL_ATI_texture_mirror_once */
+#ifndef GL_ATI_texture_mirror_once
+#define GL_ATI_texture_mirror_once 1
+#define GL_MIRROR_CLAMP_ATI               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_ATI       0x8743
+#endif
+/* GL_ARB_texture_env_dot3 */
+#ifndef GL_ARB_texture_env_dot3
+#define GL_ARB_texture_env_dot3 1
+#define GL_DOT3_RGB_ARB                   0x86AE
+#define GL_DOT3_RGBA_ARB                  0x86AF
+#endif
+/* GL_EXT_texture_env_dot3 */
+#ifndef GL_EXT_texture_env_dot3
+#define GL_EXT_texture_env_dot3 1
+#define GL_DOT3_RGB_EXT                   0x8740
+#define GL_DOT3_RGBA_EXT                  0x8741
+#endif
+/* GL_ARB_vertex_program */
+#ifndef GL_ARB_vertex_program
+#define GL_ARB_vertex_program 1
+#define GL_VERTEX_PROGRAM_ARB             0x8620
+#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB  0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB    0x8643
+#define GL_COLOR_SUM_ARB                  0x8458
+#define GL_PROGRAM_FORMAT_ASCII_ARB       0x8875
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB   0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB   0x8625
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define GL_CURRENT_VERTEX_ATTRIB_ARB      0x8626
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define GL_PROGRAM_LENGTH_ARB             0x8627
+#define GL_PROGRAM_FORMAT_ARB             0x8876
+#define GL_PROGRAM_BINDING_ARB            0x8677
+#define GL_PROGRAM_INSTRUCTIONS_ARB       0x88A0
+#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB   0x88A1
+#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define GL_PROGRAM_TEMPORARIES_ARB        0x88A4
+#define GL_MAX_PROGRAM_TEMPORARIES_ARB    0x88A5
+#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define GL_PROGRAM_PARAMETERS_ARB         0x88A8
+#define GL_MAX_PROGRAM_PARAMETERS_ARB     0x88A9
+#define GL_PROGRAM_NATIVE_PARAMETERS_ARB  0x88AA
+#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define GL_PROGRAM_ATTRIBS_ARB            0x88AC
+#define GL_MAX_PROGRAM_ATTRIBS_ARB        0x88AD
+#define GL_PROGRAM_NATIVE_ATTRIBS_ARB     0x88AE
+#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define GL_PROGRAM_ADDRESS_REGISTERS_ARB  0x88B0
+#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define GL_PROGRAM_STRING_ARB             0x8628
+#define GL_PROGRAM_ERROR_POSITION_ARB     0x864B
+#define GL_CURRENT_MATRIX_ARB             0x8641
+#define GL_TRANSPOSE_CURRENT_MATRIX_ARB   0x88B7
+#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define GL_MAX_VERTEX_ATTRIBS_ARB         0x8869
+#define GL_MAX_PROGRAM_MATRICES_ARB       0x862F
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define GL_PROGRAM_ERROR_STRING_ARB       0x8874
+#define GL_MATRIX0_ARB                    0x88C0
+#define GL_MATRIX1_ARB                    0x88C1
+#define GL_MATRIX2_ARB                    0x88C2
+#define GL_MATRIX3_ARB                    0x88C3
+#define GL_MATRIX4_ARB                    0x88C4
+#define GL_MATRIX5_ARB                    0x88C5
+#define GL_MATRIX6_ARB                    0x88C6
+#define GL_MATRIX7_ARB                    0x88C7
+#define GL_MATRIX8_ARB                    0x88C8
+#define GL_MATRIX9_ARB                    0x88C9
+#define GL_MATRIX10_ARB                   0x88CA
+#define GL_MATRIX11_ARB                   0x88CB
+#define GL_MATRIX12_ARB                   0x88CC
+#define GL_MATRIX13_ARB                   0x88CD
+#define GL_MATRIX14_ARB                   0x88CE
+#define GL_MATRIX15_ARB                   0x88CF
+#define GL_MATRIX16_ARB                   0x88D0
+#define GL_MATRIX17_ARB                   0x88D1
+#define GL_MATRIX18_ARB                   0x88D2
+#define GL_MATRIX19_ARB                   0x88D3
+#define GL_MATRIX20_ARB                   0x88D4
+#define GL_MATRIX21_ARB                   0x88D5
+#define GL_MATRIX22_ARB                   0x88D6
+#define GL_MATRIX23_ARB                   0x88D7
+#define GL_MATRIX24_ARB                   0x88D8
+#define GL_MATRIX25_ARB                   0x88D9
+#define GL_MATRIX26_ARB                   0x88DA
+#define GL_MATRIX27_ARB                   0x88DB
+#define GL_MATRIX28_ARB                   0x88DC
+#define GL_MATRIX29_ARB                   0x88DD
+#define GL_MATRIX30_ARB                   0x88DE
+#define GL_MATRIX31_ARB                   0x88DF
+#endif
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
+typedef void (APIENTRY * PGLFNVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRY * PGLFNENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
+typedef void (APIENTRY * PGLFNDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
+typedef void (APIENTRY * PGLFNPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+typedef void (APIENTRY * PGLFNBINDPROGRAMARBPROC) (GLenum target, GLuint program);
+typedef void (APIENTRY * PGLFNDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
+typedef void (APIENTRY * PGLFNGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
+typedef void (APIENTRY * PGLFNPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRY * PGLFNPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
+typedef void (APIENTRY * PGLFNPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRY * PGLFNPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
+typedef void (APIENTRY * PGLFNPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRY * PGLFNPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
+typedef void (APIENTRY * PGLFNPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRY * PGLFNPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRY * PGLFNGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
+typedef void (APIENTRY * PGLFNGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
+typedef void (APIENTRY * PGLFNGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
+typedef void (APIENTRY * PGLFNGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
+typedef GLboolean (APIENTRY * PGLFNISPROGRAMARBPROC) (GLuint program);
+#ifndef GL_ARB_fragment_program
+#define GL_ARB_fragment_program 1
+#define GL_FRAGMENT_PROGRAM_ARB           0x8804
+#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB   0x8805
+#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB   0x8806
+#define GL_PROGRAM_TEX_INDIRECTIONS_ARB   0x8807
+#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define GL_MAX_TEXTURE_COORDS_ARB         0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB    0x8872
+/* All ARB_fragment_program entry points are shared with ARB_vertex_program. */
+#endif
+/* GL_EXT_texture_compression_s3tc */
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_EXT_texture_compression_s3tc 1
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
+#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
+#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
+#endif
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRY * PGLFNGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, void *img);
+/* GL_EXT_stencil_wrap */
+#ifndef GL_EXT_stencil_wrap
+#define GL_EXT_stencil_wrap 1
+#define GL_INCR_WRAP_EXT                  0x8507
+#define GL_DECR_WRAP_EXT                  0x8508
+#endif
+/* GL_NV_fog_distance */
+#ifndef GL_NV_fog_distance
+#define GL_NV_fog_distance 1
+#define GL_FOG_DISTANCE_MODE_NV           0x855A
+#define GL_EYE_RADIAL_NV                  0x855B
+#define GL_EYE_PLANE_ABSOLUTE_NV          0x855C
+/* reuse GL_EYE_PLANE */
+#endif
+/* GL_NV_texgen_reflection */
+#ifndef GL_NV_texgen_reflection
+#define GL_NV_texgen_reflection 1
+#define GL_NORMAL_MAP_NV                  0x8511
+#define GL_REFLECTION_MAP_NV              0x8512
+#endif
+/* GL_NV_register_combiners */
+#ifndef GL_NV_register_combiners
+#define GL_NV_register_combiners 1
+#define GL_REGISTER_COMBINERS_NV          0x8522
+#define GL_VARIABLE_A_NV                  0x8523
+#define GL_VARIABLE_B_NV                  0x8524
+#define GL_VARIABLE_C_NV                  0x8525
+#define GL_VARIABLE_D_NV                  0x8526
+#define GL_VARIABLE_E_NV                  0x8527
+#define GL_VARIABLE_F_NV                  0x8528
+#define GL_VARIABLE_G_NV                  0x8529
+#define GL_CONSTANT_COLOR0_NV             0x852A
+#define GL_CONSTANT_COLOR1_NV             0x852B
+#define GL_PRIMARY_COLOR_NV               0x852C
+#define GL_SECONDARY_COLOR_NV             0x852D
+#define GL_SPARE0_NV                      0x852E
+#define GL_SPARE1_NV                      0x852F
+#define GL_DISCARD_NV                     0x8530
+#define GL_E_TIMES_F_NV                   0x8531
+#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define GL_UNSIGNED_IDENTITY_NV           0x8536
+#define GL_UNSIGNED_INVERT_NV             0x8537
+#define GL_EXPAND_NORMAL_NV               0x8538
+#define GL_EXPAND_NEGATE_NV               0x8539
+#define GL_HALF_BIAS_NORMAL_NV            0x853A
+#define GL_HALF_BIAS_NEGATE_NV            0x853B
+#define GL_SIGNED_IDENTITY_NV             0x853C
+#define GL_SIGNED_NEGATE_NV               0x853D
+#define GL_SCALE_BY_TWO_NV                0x853E
+#define GL_SCALE_BY_FOUR_NV               0x853F
+#define GL_SCALE_BY_ONE_HALF_NV           0x8540
+#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV   0x8541
+#define GL_COMBINER_INPUT_NV              0x8542
+#define GL_COMBINER_MAPPING_NV            0x8543
+#define GL_COMBINER_COMPONENT_USAGE_NV    0x8544
+#define GL_COMBINER_AB_DOT_PRODUCT_NV     0x8545
+#define GL_COMBINER_CD_DOT_PRODUCT_NV     0x8546
+#define GL_COMBINER_MUX_SUM_NV            0x8547
+#define GL_COMBINER_SCALE_NV              0x8548
+#define GL_COMBINER_BIAS_NV               0x8549
+#define GL_COMBINER_AB_OUTPUT_NV          0x854A
+#define GL_COMBINER_CD_OUTPUT_NV          0x854B
+#define GL_COMBINER_SUM_OUTPUT_NV         0x854C
+#define GL_MAX_GENERAL_COMBINERS_NV       0x854D
+#define GL_NUM_GENERAL_COMBINERS_NV       0x854E
+#define GL_COLOR_SUM_CLAMP_NV             0x854F
+#define GL_COMBINER0_NV                   0x8550
+#define GL_COMBINER1_NV                   0x8551
+#define GL_COMBINER2_NV                   0x8552
+#define GL_COMBINER3_NV                   0x8553
+#define GL_COMBINER4_NV                   0x8554
+#define GL_COMBINER5_NV                   0x8555
+#define GL_COMBINER6_NV                   0x8556
+#define GL_COMBINER7_NV                   0x8557
+/* reuse GL_TEXTURE0_ARB */
+/* reuse GL_TEXTURE1_ARB */
+/* reuse GL_ZERO */
+/* reuse GL_NONE */
+/* reuse GL_FOG */
+#endif
+typedef void (APIENTRY * PGLFNCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRY * PGLFNCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRY * PGLFNCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
+typedef void (APIENTRY * PGLFNCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
+typedef void (APIENTRY * PGLFNCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+typedef void (APIENTRY * PGLFNCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
+typedef void (APIENTRY * PGLFNFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+typedef void (APIENTRY * PGLFNGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
+typedef void (APIENTRY * PGLFNGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
+typedef void (APIENTRY * PGLFNGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
+typedef void (APIENTRY * PGLFNGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);
+/* GL_NV_register_combiners2 */
+#ifndef GL_NV_register_combiners2
+#define GL_NV_register_combiners2 1
+#define GL_PER_STAGE_CONSTANTS_NV         0x8535
+#endif
+typedef void (APIENTRY * PGLFNCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat *params);
+typedef void (APIENTRY * PGLFNGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat *params);
+/* GL_NV_texture_shader */
+#ifndef GL_NV_texture_shader
+#define GL_NV_texture_shader 1
+#define GL_OFFSET_TEXTURE_RECTANGLE_NV    0x864C
+#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV      0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV  0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV          0x86DC
+#define GL_SHADER_CONSISTENT_NV           0x86DD
+#define GL_TEXTURE_SHADER_NV              0x86DE
+#define GL_SHADER_OPERATION_NV            0x86DF
+#define GL_CULL_MODES_NV                  0x86E0
+#define GL_OFFSET_TEXTURE_MATRIX_NV       0x86E1
+#define GL_OFFSET_TEXTURE_SCALE_NV        0x86E2
+#define GL_OFFSET_TEXTURE_BIAS_NV         0x86E3
+#define GL_OFFSET_TEXTURE_2D_MATRIX_NV    GL_OFFSET_TEXTURE_MATRIX_NV
+#define GL_OFFSET_TEXTURE_2D_SCALE_NV     GL_OFFSET_TEXTURE_SCALE_NV
+#define GL_OFFSET_TEXTURE_2D_BIAS_NV      GL_OFFSET_TEXTURE_BIAS_NV
+#define GL_PREVIOUS_TEXTURE_INPUT_NV      0x86E4
+#define GL_CONST_EYE_NV                   0x86E5
+#define GL_PASS_THROUGH_NV                0x86E6
+#define GL_CULL_FRAGMENT_NV               0x86E7
+#define GL_OFFSET_TEXTURE_2D_NV           0x86E8
+#define GL_DEPENDENT_AR_TEXTURE_2D_NV     0x86E9
+#define GL_DEPENDENT_GB_TEXTURE_2D_NV     0x86EA
+#define GL_DOT_PRODUCT_NV                 0x86EC
+#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV   0x86ED
+#define GL_DOT_PRODUCT_TEXTURE_2D_NV      0x86EE
+#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define GL_HILO_NV                        0x86F4
+#define GL_DSDT_NV                        0x86F5
+#define GL_DSDT_MAG_NV                    0x86F6
+#define GL_DSDT_MAG_VIB_NV                0x86F7
+#define GL_HILO16_NV                      0x86F8
+#define GL_SIGNED_HILO_NV                 0x86F9
+#define GL_SIGNED_HILO16_NV               0x86FA
+#define GL_SIGNED_RGBA_NV                 0x86FB
+#define GL_SIGNED_RGBA8_NV                0x86FC
+#define GL_SIGNED_RGB_NV                  0x86FE
+#define GL_SIGNED_RGB8_NV                 0x86FF
+#define GL_SIGNED_LUMINANCE_NV            0x8701
+#define GL_SIGNED_LUMINANCE8_NV           0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV      0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV    0x8704
+#define GL_SIGNED_ALPHA_NV                0x8705
+#define GL_SIGNED_ALPHA8_NV               0x8706
+#define GL_SIGNED_INTENSITY_NV            0x8707
+#define GL_SIGNED_INTENSITY8_NV           0x8708
+#define GL_DSDT8_NV                       0x8709
+#define GL_DSDT8_MAG8_NV                  0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV       0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV   0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define GL_HI_SCALE_NV                    0x870E
+#define GL_LO_SCALE_NV                    0x870F
+#define GL_DS_SCALE_NV                    0x8710
+#define GL_DT_SCALE_NV                    0x8711
+#define GL_MAGNITUDE_SCALE_NV             0x8712
+#define GL_VIBRANCE_SCALE_NV              0x8713
+#define GL_HI_BIAS_NV                     0x8714
+#define GL_LO_BIAS_NV                     0x8715
+#define GL_DS_BIAS_NV                     0x8716
+#define GL_DT_BIAS_NV                     0x8717
+#define GL_MAGNITUDE_BIAS_NV              0x8718
+#define GL_VIBRANCE_BIAS_NV               0x8719
+#define GL_TEXTURE_BORDER_VALUES_NV       0x871A
+#define GL_TEXTURE_HI_SIZE_NV             0x871B
+#define GL_TEXTURE_LO_SIZE_NV             0x871C
+#define GL_TEXTURE_DS_SIZE_NV             0x871D
+#define GL_TEXTURE_DT_SIZE_NV             0x871E
+#define GL_TEXTURE_MAG_SIZE_NV            0x871F
+#endif
+/* GL_NV_texture_shader2 */
+#ifndef GL_NV_texture_shader2
+#define GL_NV_texture_shader2 1
+#define GL_DOT_PRODUCT_TEXTURE_3D_NV      0x86EF
+#endif
+/* GL_NV_texture_shader3 */
+#ifndef GL_NV_texture_shader3
+#define GL_NV_texture_shader3 1
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define GL_OFFSET_HILO_TEXTURE_2D_NV      0x8854
+#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define GL_DEPENDENT_HILO_TEXTURE_2D_NV   0x8858
+#define GL_DEPENDENT_RGB_TEXTURE_3D_NV    0x8859
+#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define GL_DOT_PRODUCT_PASS_THROUGH_NV    0x885B
+#define GL_DOT_PRODUCT_TEXTURE_1D_NV      0x885C
+#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define GL_HILO8_NV                       0x885E
+#define GL_SIGNED_HILO8_NV                0x885F
+#define GL_FORCE_BLUE_TO_ONE_NV           0x8860
+#endif
+/* GL_ATI_texture_env_combine3 */
+#ifndef GL_ATI_texture_env_combine3
+#define GL_ATI_texture_env_combine3 1
+#define GL_MODULATE_ADD_ATI               0x8744
+#define GL_MODULATE_SIGNED_ADD_ATI        0x8745
+#define GL_MODULATE_SUBTRACT_ATI          0x8746
+/* #define ONE */
+/* #define ZERO */
+#endif
+
+/*******
+ * OpenGL Official Version 
+ *  defines 
+ */
+
+/* GL_VERSION_1_3 */
+#if !defined(GL_DOT3_RGBA)
+# define GL_DOT3_RGBA                     0x8741
+#endif
+#if !defined(GL_SUBTRACT)
+# define GL_SUBTRACT                      0x84E7
+#endif
+
+
+/*********************************
+ * OpenGL GLX Extensions
+ *  defines and functions pointer
+ */
+
+
+
+/*********************************
+ * OpenGL GLX Official Version
+ *  defines and functions pointer
+ */
+
+/* GLX_VERSION_1_3 */
+typedef GLXFBConfig * (APIENTRY * PGLXFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
+typedef GLXFBConfig * (APIENTRY * PGLXFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
+typedef int           (APIENTRY * PGLXFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
+typedef XVisualInfo * (APIENTRY * PGLXFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
+typedef GLXWindow     (APIENTRY * PGLXFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+typedef void          (APIENTRY * PGLXFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
+typedef GLXPixmap     (APIENTRY * PGLXFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+typedef void          (APIENTRY * PGLXFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
+typedef GLXPbuffer    (APIENTRY * PGLXFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
+typedef void          (APIENTRY * PGLXFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef void          (APIENTRY * PGLXFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+typedef GLXContext    (APIENTRY * PGLXFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+typedef Bool          (APIENTRY * PGLXFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable   (APIENTRY * PGLXFNGLXGETCURRENTREADDRAWABLEPROC) (void);
+typedef Display *     (APIENTRY * PGLXFNGLXGETCURRENTDISPLAYPROC) (void);
+typedef int           (APIENTRY * PGLXFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
+typedef void          (APIENTRY * PGLXFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+typedef void          (APIENTRY * PGLXFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+
+
+/********************************************
+ * OpenGL Supported Extensions (ARB and EXT)
+ */
+
+typedef enum _GL_SupportedExt {
+  /* ARB */
+  ARB_FRAGMENT_PROGRAM,
+  ARB_MULTISAMPLE,
+  ARB_MULTITEXTURE,
+  ARB_POINT_PARAMETERS,
+  ARB_TEXTURE_COMPRESSION,
+  ARB_TEXTURE_CUBE_MAP,
+  ARB_TEXTURE_ENV_ADD,
+  ARB_TEXTURE_ENV_COMBINE,
+  ARB_TEXTURE_ENV_DOT3,
+  ARB_TEXTURE_BORDER_CLAMP,
+  ARB_TEXTURE_MIRRORED_REPEAT,
+  ARB_VERTEX_PROGRAM,
+  ARB_VERTEX_BLEND,
+  /* EXT */
+  EXT_FOG_COORD,
+  EXT_PALETTED_TEXTURE,
+  EXT_POINT_PARAMETERS,
+  EXT_SECONDARY_COLOR,
+  EXT_STENCIL_WRAP,
+  EXT_TEXTURE_COMPRESSION_S3TC,
+  EXT_TEXTURE_FILTER_ANISOTROPIC,
+  EXT_TEXTURE_LOD,
+  EXT_TEXTURE_LOD_BIAS,
+  EXT_TEXTURE_ENV_ADD,
+  EXT_TEXTURE_ENV_COMBINE,
+  EXT_TEXTURE_ENV_DOT3,
+  EXT_VERTEX_WEIGHTING,
+  /* NVIDIA */
+  NV_FOG_DISTANCE,
+  NV_FRAGMENT_PROGRAM,
+  NV_REGISTER_COMBINERS,
+  NV_REGISTER_COMBINERS2,
+  NV_TEXGEN_REFLECTION,
+  NV_TEXTURE_ENV_COMBINE4,
+  NV_TEXTURE_SHADER,
+  NV_TEXTURE_SHADER2,
+  NV_TEXTURE_SHADER3,
+  NV_VERTEX_PROGRAM,
+  /* ATI */
+  ATI_TEXTURE_ENV_COMBINE3,
+  ATI_TEXTURE_MIRROR_ONCE,
+  EXT_VERTEX_SHADER,
+
+  OPENGL_SUPPORTED_EXT_END
+} GL_SupportedExt;
+
+typedef enum _GL_Vendors {
+  VENDOR_WINE   = 0x0,
+  VENDOR_MESA   = 0x1,
+  VENDOR_ATI    = 0x1002,
+  VENDOR_NVIDIA = 0x10de
+} GL_Vendors;
+
+typedef enum _GL_Cards {
+  CARD_WINE  = 0x0,
+  CARD_ATI_RADEON_8500 = 0x514c,
+  CARD_ATI_RADEON_9700PRO = 0x4e44,
+  CARD_ATI_RADEON_9800PRO = 0x4e48,
+  CARD_NVIDIA_GEFORCE4_TI4600 = 0x0250,
+  CARD_NVIDIA_GEFORCEFX_5900ULTRA = 0x0330
+} GL_Cards;
+
+typedef enum _GL_VSVersion {
+  VS_VERSION_NOT_SUPPORTED = 0x0,
+  VS_VERSION_10 = 0x10,
+  VS_VERSION_11 = 0x11,
+  VS_VERSION_20 = 0x20,
+  VS_VERSION_30 = 0x30,
+  /*Force 32-bits*/
+  VS_VERSION_FORCE_DWORD = 0x7FFFFFFF
+} GL_VSVersion;
+
+typedef enum _GL_PSVersion {
+  PS_VERSION_NOT_SUPPORTED = 0x0,
+  PS_VERSION_10 = 0x10,
+  PS_VERSION_11 = 0x11,
+  PS_VERSION_12 = 0x12,
+  PS_VERSION_13 = 0x13,
+  PS_VERSION_14 = 0x14,
+  PS_VERSION_20 = 0x20,
+  PS_VERSION_30 = 0x30,
+  /*Force 32-bits*/
+  PS_VERSION_FORCE_DWORD = 0x7FFFFFFF
+} GL_PSVersion;
+
+#define MAKEDWORD_VERSION(maj, min)  ((maj & 0x0000FFFF) << 16) | (min & 0x0000FFFF)
+
+#define GL_EXT_FUNCS_GEN \
+    /** ARB Extensions **/ \
+    /* GL_ARB_texture_compression */ \
+    USE_GL_FUNC(PGLFNCOMPRESSEDTEXIMAGE2DPROC,       glCompressedTexImage2DARB); \
+    USE_GL_FUNC(PGLFNCOMPRESSEDTEXIMAGE3DPROC,       glCompressedTexImage3DARB); \
+    USE_GL_FUNC(PGLFNCOMPRESSEDTEXSUBIMAGE2DPROC,    glCompressedTexSubImage2DARB); \
+    USE_GL_FUNC(PGLFNCOMPRESSEDTEXSUBIMAGE3DPROC,    glCompressedTexSubImage3DARB); \
+    /** EXT Extensions **/ \
+    /* GL_EXT_fog_coord */ \
+    /* GL_EXT_paletted_texture */ \
+    USE_GL_FUNC(PGLFNGLCOLORTABLEEXTPROC,             glColorTableEXT); \
+    /* GL_EXT_point_parameters */ \
+    USE_GL_FUNC(PGLFNGLPOINTPARAMETERFEXTPROC,        glPointParameterfEXT); \
+    USE_GL_FUNC(PGLFNGLPOINTPARAMETERFVEXTPROC,       glPointParameterfvEXT); \
+    /* GL_EXT_secondary_color */ \
+    USE_GL_FUNC(PGLFNGLSECONDARYCOLOR3UBEXTPROC,      glSecondaryColor3ubEXT); \
+    USE_GL_FUNC(PGLFNGLSECONDARYCOLOR3FEXTPROC,       glSecondaryColor3fEXT); \
+    USE_GL_FUNC(PGLFNGLSECONDARYCOLOR3FVEXTPROC,      glSecondaryColor3fvEXT); \
+    USE_GL_FUNC(PGLFNGLSECONDARYCOLORPOINTEREXTPROC,  glSecondaryColorPointerEXT); \
+    /* GL_EXT_secondary_color */ \
+    USE_GL_FUNC(PGLFNGENPROGRAMSARBPROC,              glGenProgramsARB); \
+    USE_GL_FUNC(PGLFNBINDPROGRAMARBPROC,              glBindProgramARB); \
+    USE_GL_FUNC(PGLFNPROGRAMSTRINGARBPROC,            glProgramStringARB); \
+    USE_GL_FUNC(PGLFNDELETEPROGRAMSARBPROC,           glDeleteProgramsARB); \
+    USE_GL_FUNC(PGLFNPROGRAMENVPARAMETER4FVARBPROC,   glProgramEnvParameter4fvARB); \
+    USE_GL_FUNC(PGLFNVERTEXATTRIBPOINTERARBPROC,      glVertexAttribPointerARB); \
+    USE_GL_FUNC(PGLFNENABLEVERTEXATTRIBARRAYARBPROC,  glEnableVertexAttribArrayARB); \
+    USE_GL_FUNC(PGLFNDISABLEVERTEXATTRIBARRAYARBPROC, glDisableVertexAttribArrayARB); \
+
+#define GLX_EXT_FUNCS_GEN \
+    /** GLX_VERSION_1_3 **/ \
+    USE_GL_FUNC(PGLXFNGLXCREATEPBUFFERPROC,          glXCreatePbuffer); \
+    USE_GL_FUNC(PGLXFNGLXDESTROYPBUFFERPROC,         glXDestroyPbuffer); \
+    USE_GL_FUNC(PGLXFNGLXCREATEPIXMAPPROC,           glXCreatePixmap); \
+    USE_GL_FUNC(PGLXFNGLXDESTROYPIXMAPPROC,          glXDestroyPixmap); \
+    USE_GL_FUNC(PGLXFNGLXCREATENEWCONTEXTPROC,       glXCreateNewContext); \
+    USE_GL_FUNC(PGLXFNGLXMAKECONTEXTCURRENTPROC,     glXMakeContextCurrent); \
+    USE_GL_FUNC(PGLXFNGLXCHOOSEFBCONFIGPROC,         glXChooseFBConfig); \
+
+#undef APIENTRY
+#undef CALLBACK
+#undef WINAPI
+
+/* Redefines the constants */
+#define CALLBACK    __stdcall
+#define WINAPI      __stdcall
+#define APIENTRY    WINAPI
+
+/* Routine common to the draw primitive and draw indexed primitive routines */
+void drawPrimitive(LPDIRECT3DDEVICE9 iface,
+                    int PrimitiveType,
+                    long NumPrimitives,
+
+                    /* for Indexed: */
+                    long  StartVertexIndex,
+                    long  StartIdx,
+                    short idxBytes,
+                    const void *idxData,
+                    int   minIndex);
+
+
+/*****************************************
+ * Structures required to draw primitives 
+ */
+
+typedef struct Direct3DStridedData {
+    BYTE     *lpData;        /* Pointer to start of data               */
+    DWORD     dwStride;      /* Stride between occurances of this data */
+    DWORD     dwType;        /* Type (as in D3DVSDT_TYPE)              */
+} Direct3DStridedData;
+
+typedef struct Direct3DVertexStridedData {
+    union {
+        struct {
+             Direct3DStridedData  position;
+             Direct3DStridedData  blendWeights;
+             Direct3DStridedData  blendMatrixIndices;
+             Direct3DStridedData  normal;
+             Direct3DStridedData  pSize;
+             Direct3DStridedData  diffuse;
+             Direct3DStridedData  specular;
+             Direct3DStridedData  texCoords[8];
+        } s;
+        Direct3DStridedData input[16];  /* Indexed by constants in D3DVSDE_REGISTER */
+    } u;
+} Direct3DVertexStridedData;
+
+typedef struct _WineD3D_GLContext {
+  GLXContext   glCtx; 
+  XVisualInfo* visInfo;
+  Display*     display;
+  Drawable     drawable;
+  DWORD        ref;
+} WineD3D_Context;
+
+#define USE_GL_FUNC(type, pfn) type pfn;
+typedef struct _GL_Info {
+  unsigned bIsFilled;
+
+  DWORD  glx_version;
+  DWORD  gl_version;
+
+  GL_Vendors gl_vendor;
+  GL_Cards   gl_card;
+  DWORD  gl_driver_version;
+  CHAR   gl_renderer[255];
+  /** 
+   * CAPS Constants 
+   */
+  UINT   max_lights;
+  UINT   max_textures;
+  UINT   max_clipplanes;
+
+  GL_PSVersion ps_arb_version;
+  GL_PSVersion ps_nv_version;
+
+  GL_VSVersion vs_arb_version;
+  GL_VSVersion vs_nv_version;
+  GL_VSVersion vs_ati_version;
+  
+  BOOL supported[50];
+
+  /** OpenGL EXT and ARB functions ptr */
+  GL_EXT_FUNCS_GEN;
+  /** OpenGL GLX functions ptr */
+  GLX_EXT_FUNCS_GEN;
+  /**/
+} GL_Info;
+#undef USE_GL_FUNC
+
+
+#endif  /* __WINE_D3DCORE_GL_H */
diff -urN wine.20050419/dlls/d3d9/device.c wine.20050419.dx9/dlls/d3d9/device.c
--- wine.20050419/dlls/d3d9/device.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/device.c	2005-04-20 01:52:56.000000000 -0600
@@ -32,7 +32,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DDevice9)) {
-        IDirect3DDevice9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -57,7 +57,6 @@
     TRACE("(%p) : ReleaseRef to %ld\n", This, ref);
 
     if (ref == 0) {
-      IDirect3D9_Release((LPDIRECT3D9) This->direct3d);
       IWineD3DDevice_Release(This->WineD3DDevice);
       HeapFree(GetProcessHeap(), 0, This);
     }
@@ -88,29 +87,128 @@
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetDirect3D(LPDIRECT3DDEVICE9 iface, IDirect3D9** ppD3D9) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    TRACE("(%p) : returning %p\n", This, This->direct3d);
-    /* Inc ref count */
-    *ppD3D9 = (IDirect3D9*) This->direct3d;
-    IDirect3D9_AddRef(*ppD3D9);
-    return D3D_OK;
+    HRESULT hr = D3D_OK;
+    IWineD3D* pWineD3D;
+    
+    TRACE("(%p) Relay\n", This);
+    
+    if(NULL == ppD3D9){
+        return D3DERR_INVALIDCALL;
+    }    
+    hr = IWineD3DDevice_GetDirect3D(This->WineD3DDevice, &pWineD3D);    
+    if(hr == D3D_OK && pWineD3D != NULL)
+    {
+        IWineD3DResource_GetParent((IWineD3DResource *)pWineD3D,(IUnknown **)ppD3D9);
+        IWineD3DResource_Release((IWineD3DResource *)pWineD3D);
+    }else{
+        FIXME("Call to IWineD3DDevice_GetDirect3D failed\n");
+        *ppD3D9 = NULL;
+    }
+    TRACE("(%p) returning %p\b",This , *ppD3D9);
+    return hr;
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetDeviceCaps(LPDIRECT3DDEVICE9 iface, D3DCAPS9* pCaps) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    return IWineD3DDevice_GetDeviceCaps(This->WineD3DDevice, pCaps);
+    HRESULT hrc = D3D_OK;
+    WINED3DCAPS *pWineCaps;
+
+    TRACE("(%p) : Relay pCaps %p \n", This, pCaps);
+    if(NULL == pCaps){
+        return D3DERR_INVALIDCALL;
+    }        
+    pWineCaps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WINED3DCAPS));
+    if(pWineCaps == NULL){
+        return D3DERR_INVALIDCALL; /*well this is what MSDN says to return*/
+    }
+    
+    pWineCaps->DeviceType                        = &pCaps->DeviceType;
+    pWineCaps->AdapterOrdinal                    = &pCaps->AdapterOrdinal;
+    pWineCaps->Caps                              = &pCaps->Caps;
+    pWineCaps->Caps2                             = &pCaps->Caps2;
+    pWineCaps->Caps3                             = &pCaps->Caps3;
+    pWineCaps->PresentationIntervals             = &pCaps->PresentationIntervals;
+    pWineCaps->CursorCaps                        = &pCaps->CursorCaps;
+    pWineCaps->DevCaps                           = &pCaps->DevCaps;
+    pWineCaps->PrimitiveMiscCaps                 = &pCaps->PrimitiveMiscCaps;
+    pWineCaps->RasterCaps                        = &pCaps->RasterCaps;
+    pWineCaps->ZCmpCaps                          = &pCaps->ZCmpCaps;
+    pWineCaps->SrcBlendCaps                      = &pCaps->SrcBlendCaps;
+    pWineCaps->DestBlendCaps                     = &pCaps->DestBlendCaps;
+    pWineCaps->AlphaCmpCaps                      = &pCaps->AlphaCmpCaps;
+    pWineCaps->ShadeCaps                         = &pCaps->ShadeCaps;
+    pWineCaps->TextureCaps                       = &pCaps->TextureCaps;
+    pWineCaps->TextureFilterCaps                 = &pCaps->TextureFilterCaps;
+    pWineCaps->CubeTextureFilterCaps             = &pCaps->CubeTextureFilterCaps;
+    pWineCaps->VolumeTextureFilterCaps           = &pCaps->VolumeTextureFilterCaps;
+    pWineCaps->TextureAddressCaps                = &pCaps->TextureAddressCaps;
+    pWineCaps->VolumeTextureAddressCaps          = &pCaps->VolumeTextureAddressCaps;
+    pWineCaps->LineCaps                          = &pCaps->LineCaps;
+    pWineCaps->MaxTextureWidth                   = &pCaps->MaxTextureWidth;
+    pWineCaps->MaxTextureHeight                  = &pCaps->MaxTextureHeight;
+    pWineCaps->MaxVolumeExtent                   = &pCaps->MaxVolumeExtent;
+    pWineCaps->MaxTextureRepeat                  = &pCaps->MaxTextureRepeat;
+    pWineCaps->MaxTextureAspectRatio             = &pCaps->MaxTextureAspectRatio;
+    pWineCaps->MaxAnisotropy                     = &pCaps->MaxAnisotropy;
+    pWineCaps->MaxVertexW                        = &pCaps->MaxVertexW;
+    pWineCaps->GuardBandLeft                     = &pCaps->GuardBandLeft;
+    pWineCaps->GuardBandTop                      = &pCaps->GuardBandTop;
+    pWineCaps->GuardBandRight                    = &pCaps->GuardBandRight;
+    pWineCaps->GuardBandBottom                   = &pCaps->GuardBandBottom;
+    pWineCaps->ExtentsAdjust                     = &pCaps->ExtentsAdjust;
+    pWineCaps->StencilCaps                       = &pCaps->StencilCaps;
+    pWineCaps->FVFCaps                           = &pCaps->FVFCaps;
+    pWineCaps->TextureOpCaps                     = &pCaps->TextureOpCaps;
+    pWineCaps->MaxTextureBlendStages             = &pCaps->MaxTextureBlendStages;
+    pWineCaps->MaxSimultaneousTextures           = &pCaps->MaxSimultaneousTextures;
+    pWineCaps->VertexProcessingCaps              = &pCaps->VertexProcessingCaps;
+    pWineCaps->MaxActiveLights                   = &pCaps->MaxActiveLights;
+    pWineCaps->MaxUserClipPlanes                 = &pCaps->MaxUserClipPlanes;
+    pWineCaps->MaxVertexBlendMatrices            = &pCaps->MaxVertexBlendMatrices;
+    pWineCaps->MaxVertexBlendMatrixIndex         = &pCaps->MaxVertexBlendMatrixIndex;
+    pWineCaps->MaxPointSize                      = &pCaps->MaxPointSize;
+    pWineCaps->MaxPrimitiveCount                 = &pCaps->MaxPrimitiveCount;
+    pWineCaps->MaxVertexIndex                    = &pCaps->MaxVertexIndex;
+    pWineCaps->MaxStreams                        = &pCaps->MaxStreams;
+    pWineCaps->MaxStreamStride                   = &pCaps->MaxStreamStride;
+    pWineCaps->VertexShaderVersion               = &pCaps->VertexShaderVersion;
+    pWineCaps->MaxVertexShaderConst              = &pCaps->MaxVertexShaderConst;
+    pWineCaps->PixelShaderVersion                = &pCaps->PixelShaderVersion;
+    pWineCaps->PixelShader1xMaxValue             = &pCaps->PixelShader1xMaxValue;
+    pWineCaps->DevCaps2                          = &pCaps->DevCaps2;
+    pWineCaps->MaxNpatchTessellationLevel        = &pCaps->MaxNpatchTessellationLevel;
+    pWineCaps->MasterAdapterOrdinal              = &pCaps->MasterAdapterOrdinal;
+    pWineCaps->AdapterOrdinalInGroup             = &pCaps->AdapterOrdinalInGroup;
+    pWineCaps->NumberOfAdaptersInGroup           = &pCaps->NumberOfAdaptersInGroup;
+    pWineCaps->DeclTypes                         = &pCaps->DeclTypes;
+    pWineCaps->NumSimultaneousRTs                = &pCaps->NumSimultaneousRTs;
+    pWineCaps->StretchRectFilterCaps             = &pCaps->StretchRectFilterCaps;
+    pWineCaps->VS20Caps                          = (WINED3DVSHADERCAPS2_0 *)&pCaps->VS20Caps; /* structurally identical*/
+    pWineCaps->PS20Caps                          = (WINED3DPSHADERCAPS2_0 *)&pCaps->PS20Caps;
+    pWineCaps->VertexTextureFilterCaps           = &pCaps->VertexTextureFilterCaps;
+    pWineCaps->MaxVShaderInstructionsExecuted    = &pCaps->MaxVShaderInstructionsExecuted;
+    pWineCaps->MaxPShaderInstructionsExecuted    = &pCaps->MaxPShaderInstructionsExecuted;
+    pWineCaps->MaxVertexShader30InstructionSlots = &pCaps->MaxVertexShader30InstructionSlots;
+    pWineCaps->MaxPixelShader30InstructionSlots  = &pCaps->MaxPixelShader30InstructionSlots;
+    hrc = IWineD3DDevice_GetDeviceCaps(This->WineD3DDevice, pWineCaps);
+    HeapFree(GetProcessHeap(), 0, pWineCaps);
+    TRACE("Returning %p %p\n", This, pCaps);
+    return hrc;
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetDisplayMode(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, D3DDISPLAYMODE* pMode) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    
     TRACE("(%p) Relay\n", This);
+    
     return IWineD3DDevice_GetDisplayMode(This->WineD3DDevice, iSwapChain, pMode);
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetCreationParameters(LPDIRECT3DDEVICE9 iface, D3DDEVICE_CREATION_PARAMETERS *pParameters) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) copying to %p\n", This, pParameters);    
-    memcpy(pParameters, &This->CreateParms, sizeof(D3DDEVICE_CREATION_PARAMETERS));
-    return D3D_OK;
+    
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DDevice_GetCreationParameters(This->WineD3DDevice, pParameters);
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_SetCursorProperties(LPDIRECT3DDEVICE9 iface, UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap) {
@@ -205,7 +303,6 @@
     return IWineD3DDevice_GetGammaRamp(This->WineD3DDevice, iSwapChain, pRamp);
 }
 
-
 HRESULT  WINAPI IDirect3DDevice9Impl_CreateSurface(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, D3DFORMAT Format, BOOL Lockable, BOOL Discard, UINT Level, IDirect3DSurface9 **ppSurface,D3DRESOURCETYPE Type, UINT Usage,D3DPOOL Pool, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality,HANDLE* pSharedHandle )  {
     HRESULT hrc;
     IDirect3DSurface9Impl *object;
@@ -343,56 +440,63 @@
     return IDirect3DDevice9Impl_CreateSurface(iface,Width,Height,Format,TRUE/*Loackable*/,FALSE/*Discard*/,0/*Level*/ , ppSurface,D3DRTYPE_SURFACE, 0/*Usage (undefined/none)*/,Pool,D3DMULTISAMPLE_NONE,0/*MultisampleQuality*/,pSharedHandle);
 }
 
-/* TODO: move to wineD3D */
 HRESULT  WINAPI  IDirect3DDevice9Impl_SetRenderTarget(LPDIRECT3DDEVICE9 iface, DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    HRESULT hr = S_OK;
+    IDirect3DSurface9Impl *pSurface = (IDirect3DSurface9Impl*)pRenderTarget;
+    TRACE("(%p) Relay\n" , This);
+    return IWineD3DDevice_SetRenderTarget(This->WineD3DDevice,RenderTargetIndex,(IWineD3DSurface*)pSurface->wineD3DSurface);
+}
 
-    /* If pRenderTarget == NULL, it seems to default to back buffer */
-    if (pRenderTarget == NULL) pRenderTarget = (IDirect3DSurface9*) This->backBuffer;
+HRESULT  WINAPI  IDirect3DDevice9Impl_GetRenderTarget(LPDIRECT3DDEVICE9 iface, DWORD RenderTargetIndex, IDirect3DSurface9 **ppRenderTarget) {
+    IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    HRESULT hr = D3D_OK;
+    IWineD3DSurface *pRenderTarget;
  
-    /* If we are trying to set what we already have, don't bother */
-    if ((IDirect3DSurface9Impl*) pRenderTarget == This->renderTarget) {
-      TRACE("Trying to do a NOP SetRenderTarget operation\n");
-    } else {
-      /* Otherwise, set the render target up */
-      TRACE("(%p) : newRender@%p (default is backbuffer=(%p))\n", This, pRenderTarget, This->backBuffer);
-      hr = E_FAIL; /* not supported yet */
-    }
+    TRACE("(%p) Relay\n" , This);
 
-   return hr;
+    if(ppRenderTarget == NULL){
+        return D3DERR_INVALIDCALL;
 }
+    hr=IWineD3DDevice_GetRenderTarget(This->WineD3DDevice,RenderTargetIndex,&pRenderTarget);
 
-/* TODO: move to wineD3D */
-HRESULT  WINAPI  IDirect3DDevice9Impl_GetRenderTarget(LPDIRECT3DDEVICE9 iface, DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget) {
-    IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    TRACE("(%p)->returning (%p) default is backbuffer=(%p)\n", This, This->renderTarget, This->backBuffer);
-    *ppRenderTarget = (LPDIRECT3DSURFACE9) This->renderTarget;
-    IDirect3DSurface9Impl_AddRef((LPDIRECT3DSURFACE9) *ppRenderTarget);
-    return D3D_OK;
+    if(hr == D3D_OK && pRenderTarget != NULL){
+        IWineD3DResource_GetParent((IWineD3DResource *)pRenderTarget,(IUnknown**)ppRenderTarget);
+        IWineD3DResource_Release((IWineD3DResource *)pRenderTarget);
+    }else{
+        FIXME("Call to IWineD3DDevice_GetRenderTarget failed\n");
+        *ppRenderTarget = NULL;
+    }
+    return hr;
 }
 
-/* TODO: move to wineD3D */
 HRESULT  WINAPI  IDirect3DDevice9Impl_SetDepthStencilSurface(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9* pZStencilSurface) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    HRESULT hr = S_OK;
-    /* If we are trying to set what we already have, don't bother */
-    if ((IDirect3DSurface9Impl*) pZStencilSurface == This->stencilBufferTarget) {
-      TRACE("Trying to do a NOP SetDepthStencilSurface operation\n");
-    } else {
-      /* Otherwise, set the target up */
-      TRACE("(%p) : newDepthStencil@%p (default is stencilbuffer=(%p))\n", This, pZStencilSurface, This->depthStencilBuffer);
-      hr = E_FAIL; /* not supported yet */
-    }
-    return D3D_OK;
+    IDirect3DSurface9Impl *pSurface;
+
+    TRACE("(%p) Relay\n" , This);   
+    
+    pSurface = (IDirect3DSurface9Impl*)pZStencilSurface;    
+    return IWineD3DDevice_SetDepthStencilSurface(This->WineD3DDevice,NULL==pSurface?NULL:(IWineD3DSurface*)pSurface->wineD3DSurface);
 }
 
-/* TODO: move to wineD3D */
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetDepthStencilSurface(LPDIRECT3DDEVICE9 iface, IDirect3DSurface9** ppZStencilSurface) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    TRACE("(%p)->returning (%p) default is stencilbuffer=(%p)\n", This, This->stencilBufferTarget, This->depthStencilBuffer);
-    *ppZStencilSurface = (LPDIRECT3DSURFACE9) This->stencilBufferTarget;
-    if (NULL != *ppZStencilSurface) IDirect3DSurface9Impl_AddRef((LPDIRECT3DSURFACE9) *ppZStencilSurface);
+    HRESULT hr = D3D_OK;
+    IWineD3DSurface *pZStencilSurface;
+
+    TRACE("(%p) Relay\n" , This);
+    if(ppZStencilSurface == NULL){
+        return D3DERR_INVALIDCALL;
+    }
+    
+    hr=IWineD3DDevice_GetDepthStencilSurface(This->WineD3DDevice,&pZStencilSurface);
+    if(hr == D3D_OK && pZStencilSurface != NULL){
+        IWineD3DResource_GetParent((IWineD3DResource *)pZStencilSurface,(IUnknown**)ppZStencilSurface);
+        IWineD3DResource_Release((IWineD3DResource *)pZStencilSurface);
+    }else{
+        FIXME("Call to IWineD3DDevice_GetRenderTarget failed\n");
+        *ppZStencilSurface = NULL;        
+    }
     return D3D_OK;
 }
 
@@ -521,7 +625,6 @@
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
     IWineD3DBaseTexture *retTexture = NULL;
     HRESULT rc = D3D_OK;
-
     TRACE("(%p) Relay\n" , This);
 
     if(ppTexture == NULL){
@@ -700,6 +803,9 @@
     if(pStream == NULL){
         return D3DERR_INVALIDCALL;
     }
+    if(pStream == NULL){
+        return D3DERR_INVALIDCALL;
+    }
 
     rc = IWineD3DDevice_GetStreamSource(This->WineD3DDevice, StreamNumber, (IWineD3DVertexBuffer **)&retStream, OffsetInBytes, pStride);
     if (rc == D3D_OK  && NULL != retStream) {
@@ -745,6 +851,9 @@
     if(ppIndexData == NULL){
         return D3DERR_INVALIDCALL;
     }
+    if(ppIndexData == NULL){
+        return D3DERR_INVALIDCALL;
+    }
 
     rc = IWineD3DDevice_GetIndices(This->WineD3DDevice, &retIndexData, &tmp);
     if (rc == D3D_OK && NULL != retIndexData) {
@@ -775,6 +884,34 @@
     return IWineD3DDevice_DeletePatch(This->WineD3DDevice, Handle);
 }
 
+HRESULT WINAPI IDirect3DDevice9Impl_CreateStateBlock(LPDIRECT3DDEVICE9 iface, D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppStateBlock) {
+   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+   IDirect3DStateBlock9Impl* object;
+   HRESULT hrc = D3D_OK;
+   
+   TRACE("(%p) Relay\n", This);
+   
+   object  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DStateBlock9Impl));
+   if (NULL == object) {
+      FIXME("(%p)  Failed to allocate %d bytes\n", This, sizeof(IDirect3DStateBlock9Impl));
+      *ppStateBlock = NULL;
+      return E_OUTOFMEMORY;
+   }
+   object->lpVtbl = &Direct3DStateBlock9_Vtbl;
+   object->ref = 1;
+   
+   hrc=IWineD3DDevice_CreateStateBlock(This->WineD3DDevice,Type,&object->wineD3DStateBlock,(IUnknown*)object);
+   if(hrc != D3D_OK){
+       FIXME("(%p) Call to IWineD3DDevice_CreateStateBlock failed.\n", This);
+       HeapFree(GetProcessHeap(), 0, object);
+       *ppStateBlock = NULL;
+   } else {
+       *ppStateBlock = (IDirect3DStateBlock9*)object;
+   }
+   TRACE("(%p) returning token (ptr to stateblock) of %p\n", This, object);    
+   return hrc;
+}
+
 IDirect3DDevice9Vtbl Direct3DDevice9_Vtbl =
 {
     IDirect3DDevice9Impl_QueryInterface,
@@ -921,3 +1058,4 @@
     }
     return res;
 }
+
diff -urN wine.20050419/dlls/d3d9/directx.c wine.20050419.dx9/dlls/d3d9/directx.c
--- wine.20050419/dlls/d3d9/directx.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/directx.c	2005-04-20 02:47:47.000000000 -0600
@@ -21,7 +21,7 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
 /* IDirect3D9 IUnknown parts follow: */
 HRESULT WINAPI IDirect3D9Impl_QueryInterface(LPDIRECT3D9 iface, REFIID riid, LPVOID* ppobj)
@@ -30,7 +30,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3D9)) {
-        IDirect3D9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -76,10 +76,11 @@
 HRESULT WINAPI IDirect3D9Impl_GetAdapterIdentifier(LPDIRECT3D9 iface, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9* pIdentifier) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
     WINED3DADAPTER_IDENTIFIER adapter_id;
-
+    TRACE("(%p) Relay \n", This);
     /* dx8 and dx9 have different structures to be filled in, with incompatible 
        layouts so pass in pointers to the places to be filled via an internal 
-       structure                                                                */
+       structure
+                                              */
     adapter_id.Driver           = pIdentifier->Driver;          
     adapter_id.Description      = pIdentifier->Description;     
     adapter_id.DeviceName       = pIdentifier->DeviceName;      
@@ -96,16 +97,19 @@
 
 UINT WINAPI IDirect3D9Impl_GetAdapterModeCount(LPDIRECT3D9 iface, UINT Adapter, D3DFORMAT Format) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_GetAdapterModeCount(This->WineD3D, Adapter, Format);
 }
 
 HRESULT WINAPI IDirect3D9Impl_EnumAdapterModes(LPDIRECT3D9 iface, UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE* pMode) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_EnumAdapterModes(This->WineD3D, Adapter, Format, Mode, pMode);
 }
 
 HRESULT WINAPI IDirect3D9Impl_GetAdapterDisplayMode(LPDIRECT3D9 iface, UINT Adapter, D3DDISPLAYMODE* pMode) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay %p \n", This, This->WineD3D);
     return IWineD3D_GetAdapterDisplayMode(This->WineD3D, Adapter, pMode);
 }
 
@@ -113,6 +117,7 @@
 					      UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat,
 					      D3DFORMAT BackBufferFormat, BOOL Windowed) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_CheckDeviceType(This->WineD3D, Adapter, CheckType, DisplayFormat,
                                     BackBufferFormat, Windowed);
 }
@@ -121,6 +126,7 @@
 						  UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat,
 						  DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_CheckDeviceFormat(This->WineD3D, Adapter, DeviceType, AdapterFormat,
                                     Usage, RType, CheckFormat);
 }
@@ -129,6 +135,7 @@
 							   UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat,
 							   BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_CheckDeviceMultiSampleType(This->WineD3D, Adapter, DeviceType, SurfaceFormat,
                                                Windowed, MultiSampleType, pQualityLevels);
 }
@@ -137,23 +144,113 @@
 						       UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat,
 						       D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_CheckDepthStencilMatch(This->WineD3D, Adapter, DeviceType, AdapterFormat,
                                            RenderTargetFormat, DepthStencilFormat);
 }
 
 HRESULT  WINAPI  IDirect3D9Impl_CheckDeviceFormatConversion(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_CheckDeviceFormatConversion(This->WineD3D, Adapter, DeviceType, SourceFormat,
                                                 TargetFormat);
 }
 
 HRESULT  WINAPI  IDirect3D9Impl_GetDeviceCaps(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9* pCaps) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
-    return IWineD3D_GetDeviceCaps(This->WineD3D, Adapter, DeviceType, (WINED3DCAPS *)pCaps);
+    HRESULT hrc = D3D_OK;
+    WINED3DCAPS *pWineCaps;
+
+    TRACE("(%p) Relay %d %u %p \n", This, Adapter, DeviceType, pCaps);
+    
+    if(NULL == pCaps){
+        return D3DERR_INVALIDCALL;
+    }        
+    pWineCaps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WINED3DCAPS));
+    if(pWineCaps == NULL){
+        return D3DERR_INVALIDCALL; /*well this is what MSDN says to return*/
+    }
+
+    pWineCaps->DeviceType                        = &pCaps->DeviceType;
+    pWineCaps->AdapterOrdinal                    = &pCaps->AdapterOrdinal;
+    pWineCaps->Caps                              = &pCaps->Caps;
+    pWineCaps->Caps2                             = &pCaps->Caps2;
+    pWineCaps->Caps3                             = &pCaps->Caps3;
+    pWineCaps->PresentationIntervals             = &pCaps->PresentationIntervals;
+    pWineCaps->CursorCaps                        = &pCaps->CursorCaps;
+    pWineCaps->DevCaps                           = &pCaps->DevCaps;
+    pWineCaps->PrimitiveMiscCaps                 = &pCaps->PrimitiveMiscCaps;
+    pWineCaps->RasterCaps                        = &pCaps->RasterCaps;
+    pWineCaps->ZCmpCaps                          = &pCaps->ZCmpCaps;
+    pWineCaps->SrcBlendCaps                      = &pCaps->SrcBlendCaps;
+    pWineCaps->DestBlendCaps                     = &pCaps->DestBlendCaps;
+    pWineCaps->AlphaCmpCaps                      = &pCaps->AlphaCmpCaps;
+    pWineCaps->ShadeCaps                         = &pCaps->ShadeCaps;
+    pWineCaps->TextureCaps                       = &pCaps->TextureCaps;
+    pWineCaps->TextureFilterCaps                 = &pCaps->TextureFilterCaps;
+    pWineCaps->CubeTextureFilterCaps             = &pCaps->CubeTextureFilterCaps;
+    pWineCaps->VolumeTextureFilterCaps           = &pCaps->VolumeTextureFilterCaps;
+    pWineCaps->TextureAddressCaps                = &pCaps->TextureAddressCaps;
+    pWineCaps->VolumeTextureAddressCaps          = &pCaps->VolumeTextureAddressCaps;
+    pWineCaps->LineCaps                          = &pCaps->LineCaps;
+    pWineCaps->MaxTextureWidth                   = &pCaps->MaxTextureWidth;
+    pWineCaps->MaxTextureHeight                  = &pCaps->MaxTextureHeight;
+    pWineCaps->MaxVolumeExtent                   = &pCaps->MaxVolumeExtent;
+    pWineCaps->MaxTextureRepeat                  = &pCaps->MaxTextureRepeat;
+    pWineCaps->MaxTextureAspectRatio             = &pCaps->MaxTextureAspectRatio;
+    pWineCaps->MaxAnisotropy                     = &pCaps->MaxAnisotropy;
+    pWineCaps->MaxVertexW                        = &pCaps->MaxVertexW;
+    pWineCaps->GuardBandLeft                     = &pCaps->GuardBandLeft;
+    pWineCaps->GuardBandTop                      = &pCaps->GuardBandTop;
+    pWineCaps->GuardBandRight                    = &pCaps->GuardBandRight;
+    pWineCaps->GuardBandBottom                   = &pCaps->GuardBandBottom;
+    pWineCaps->ExtentsAdjust                     = &pCaps->ExtentsAdjust;
+    pWineCaps->StencilCaps                       = &pCaps->StencilCaps;
+    pWineCaps->FVFCaps                           = &pCaps->FVFCaps;
+    pWineCaps->TextureOpCaps                     = &pCaps->TextureOpCaps;
+    pWineCaps->MaxTextureBlendStages             = &pCaps->MaxTextureBlendStages;
+    pWineCaps->MaxSimultaneousTextures           = &pCaps->MaxSimultaneousTextures;
+    pWineCaps->VertexProcessingCaps              = &pCaps->VertexProcessingCaps;
+    pWineCaps->MaxActiveLights                   = &pCaps->MaxActiveLights;
+    pWineCaps->MaxUserClipPlanes                 = &pCaps->MaxUserClipPlanes;
+    pWineCaps->MaxVertexBlendMatrices            = &pCaps->MaxVertexBlendMatrices;
+    pWineCaps->MaxVertexBlendMatrixIndex         = &pCaps->MaxVertexBlendMatrixIndex;
+    pWineCaps->MaxPointSize                      = &pCaps->MaxPointSize;
+    pWineCaps->MaxPrimitiveCount                 = &pCaps->MaxPrimitiveCount;
+    pWineCaps->MaxVertexIndex                    = &pCaps->MaxVertexIndex;
+    pWineCaps->MaxStreams                        = &pCaps->MaxStreams;
+    pWineCaps->MaxStreamStride                   = &pCaps->MaxStreamStride;
+    pWineCaps->VertexShaderVersion               = &pCaps->VertexShaderVersion;
+    pWineCaps->MaxVertexShaderConst              = &pCaps->MaxVertexShaderConst;
+    pWineCaps->PixelShaderVersion                = &pCaps->PixelShaderVersion;
+    pWineCaps->PixelShader1xMaxValue             = &pCaps->PixelShader1xMaxValue;
+    pWineCaps->DevCaps2                          = &pCaps->DevCaps2;
+    pWineCaps->MaxNpatchTessellationLevel        = &pCaps->MaxNpatchTessellationLevel;
+    pWineCaps->MasterAdapterOrdinal              = &pCaps->MasterAdapterOrdinal;
+    pWineCaps->AdapterOrdinalInGroup             = &pCaps->AdapterOrdinalInGroup;
+    pWineCaps->NumberOfAdaptersInGroup           = &pCaps->NumberOfAdaptersInGroup;
+    pWineCaps->DeclTypes                         = &pCaps->DeclTypes;
+    pWineCaps->NumSimultaneousRTs                = &pCaps->NumSimultaneousRTs;
+    pWineCaps->StretchRectFilterCaps             = &pCaps->StretchRectFilterCaps;
+#if 0
+    pWineCaps->VS20Caps                          = &pCaps->VS20Caps;
+    pWineCaps->PS20Caps                          = &pCaps->PS20Caps;
+#endif
+    pWineCaps->VertexTextureFilterCaps           = &pCaps->VertexTextureFilterCaps;
+    pWineCaps->MaxVShaderInstructionsExecuted    = &pCaps->MaxVShaderInstructionsExecuted;
+    pWineCaps->MaxPShaderInstructionsExecuted    = &pCaps->MaxPShaderInstructionsExecuted;
+    pWineCaps->MaxVertexShader30InstructionSlots = &pCaps->MaxVertexShader30InstructionSlots;
+    pWineCaps->MaxPixelShader30InstructionSlots  = &pCaps->MaxPixelShader30InstructionSlots;
+    hrc = IWineD3D_GetDeviceCaps(This->WineD3D, Adapter, DeviceType, pWineCaps);
+    HeapFree(GetProcessHeap(), 0, pWineCaps);
+    TRACE("(%p) returning %p\n", This, pCaps);
+    return hrc;
+    
 }
 
 HMONITOR WINAPI  IDirect3D9Impl_GetAdapterMonitor(LPDIRECT3D9 iface, UINT Adapter) {
     IDirect3D9Impl *This = (IDirect3D9Impl *)iface;
+    TRACE("(%p) Relay \n", This);
     return IWineD3D_GetAdapterMonitor(This->WineD3D, Adapter);
 }
 
@@ -164,33 +261,100 @@
                                          IWineD3DSurface** ppSurface, HANDLE* pSharedHandle) {
     HRESULT res = D3D_OK;
     IDirect3DSurface9Impl *d3dSurface = NULL;
-    IDirect3DDevice9Impl* pDeviceImpl = (IDirect3DDevice9Impl*) device;
-
+    TRACE("(%p) call back\n", device);
     res = IDirect3DDevice9_CreateRenderTarget((IDirect3DDevice9 *)device, Width, Height, 
                                          (D3DFORMAT) Format, MultiSample, MultisampleQuality, Lockable, 
                                          (IDirect3DSurface9 **)&d3dSurface, pSharedHandle);
 
     if (SUCCEEDED(res)) {
         *ppSurface = d3dSurface->wineD3DSurface;
-	if (NULL == pDeviceImpl->backBuffer) {
-	  pDeviceImpl->backBuffer = d3dSurface;
-	  pDeviceImpl->renderTarget = d3dSurface;
-	  IDirect3DSurface9Impl_AddRef((LPDIRECT3DSURFACE9) pDeviceImpl->renderTarget);
-	}
     } else {
         *ppSurface = NULL;
     }
     return res;
 }
 
+HRESULT WINAPI D3D9CB_CreateAdditionalSwapChain(IUnknown *device,
+                                                WINED3DPRESENT_PARAMETERS* pPresentationParameters,
+                                                IWineD3DSwapChain ** ppSwapChain){
+    HRESULT res = D3D_OK;
+    IDirect3DSwapChain9Impl *d3dSwapChain =NULL;
+    
+    D3DPRESENT_PARAMETERS localParameters;
+        
+    localParameters.BackBufferWidth                = *(pPresentationParameters->BackBufferWidth);
+    localParameters.BackBufferHeight               = *(pPresentationParameters->BackBufferHeight);           
+    localParameters.BackBufferFormat               = *(pPresentationParameters->BackBufferFormat);           
+    localParameters.BackBufferCount                = *(pPresentationParameters->BackBufferCount);            
+    localParameters.MultiSampleType                = *(pPresentationParameters->MultiSampleType);            
+    localParameters.MultiSampleQuality             = *(pPresentationParameters->MultiSampleQuality);
+    localParameters.SwapEffect                     = *(pPresentationParameters->SwapEffect);
+    localParameters.hDeviceWindow                  = *(pPresentationParameters->hDeviceWindow);
+    localParameters.Windowed                       = *(pPresentationParameters->Windowed);
+    localParameters.EnableAutoDepthStencil         = *(pPresentationParameters->EnableAutoDepthStencil);
+    localParameters.AutoDepthStencilFormat         = *(pPresentationParameters->AutoDepthStencilFormat);
+    localParameters.Flags                          = *(pPresentationParameters->Flags);
+    localParameters.FullScreen_RefreshRateInHz     = *(pPresentationParameters->FullScreen_RefreshRateInHz);
+    localParameters.PresentationInterval           = *(pPresentationParameters->PresentationInterval);
+    
+    TRACE("(%p) rellaying\n", device);
+    /*copy the presentation parameters*/
+    res = IDirect3DDevice9_CreateAdditionalSwapChain((IDirect3DDevice9 *)device, &localParameters, (IDirect3DSwapChain9 **)&d3dSwapChain);
+    
+    if (res == D3D_OK){
+        *ppSwapChain = d3dSwapChain->wineD3DSwapChain;
+    } else {
+        *ppSwapChain = NULL;
+    }
+    /*Copy back the presentation parameters*/
+    TRACE("(%p) setting up return parameters\n", device);
+   *pPresentationParameters->BackBufferWidth               = localParameters.BackBufferWidth;
+   *pPresentationParameters->BackBufferHeight              = localParameters.BackBufferHeight;
+   *pPresentationParameters->BackBufferFormat              = localParameters.BackBufferFormat;
+   *pPresentationParameters->BackBufferCount               = localParameters.BackBufferCount;
+   *pPresentationParameters->MultiSampleType               = localParameters.MultiSampleType;
+   *pPresentationParameters->MultiSampleQuality            = localParameters.MultiSampleQuality;
+   *pPresentationParameters->SwapEffect                    = localParameters.SwapEffect;
+   *pPresentationParameters->hDeviceWindow                 = localParameters.hDeviceWindow;
+   *pPresentationParameters->Windowed                      = localParameters.Windowed;
+   *pPresentationParameters->EnableAutoDepthStencil        = localParameters.EnableAutoDepthStencil;
+   *pPresentationParameters->AutoDepthStencilFormat        = localParameters.AutoDepthStencilFormat;
+   *pPresentationParameters->Flags                         = localParameters.Flags;
+   *pPresentationParameters->FullScreen_RefreshRateInHz    = localParameters.FullScreen_RefreshRateInHz;
+   *pPresentationParameters->PresentationInterval          = localParameters.PresentationInterval;
+    
+   return res;       
+    
+}
+                                                
+
+
+/* Internal function called back during the CreateDevice to create a render target */
+HRESULT WINAPI D3D9CB_CreateDepthStencilSurface(IUnknown *device, UINT Width, UINT Height, 
+                                         D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, 
+                                         DWORD MultisampleQuality, BOOL Discard,
+                                         IWineD3DSurface** ppSurface, HANDLE* pSharedHandle) {
+    HRESULT res = D3D_OK;
+    IDirect3DSurface9Impl *d3dSurface = NULL;
+
+    res = IDirect3DDevice9_CreateDepthStencilSurface((IDirect3DDevice9 *)device, Width, Height, 
+                                         Format, MultiSample, MultisampleQuality, Discard, 
+                                         (IDirect3DSurface9 **)&d3dSurface, pSharedHandle);
+    if (res == D3D_OK) {
+        *ppSurface = d3dSurface->wineD3DSurface;
+    }
+    return res;
+}
+
 HRESULT  WINAPI  IDirect3D9Impl_CreateDevice(LPDIRECT3D9 iface, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow,
 					     DWORD BehaviourFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, 
 					     IDirect3DDevice9** ppReturnedDeviceInterface) {
 
+    /*TODO: This needs to call IWINED3D*/
     IDirect3D9Impl       *This   = (IDirect3D9Impl *)iface;
     IDirect3DDevice9Impl *object = NULL;
     WINED3DPRESENT_PARAMETERS localParameters;
-
+    TRACE("(%p) Relay \n", This);
     /* Check the validity range of the adapter parameter */
     if (Adapter >= IDirect3D9Impl_GetAdapterCount(iface)) {
         *ppReturnedDeviceInterface = NULL;
@@ -207,8 +371,6 @@
 
     object->lpVtbl = &Direct3DDevice9_Vtbl;
     object->ref = 1;
-    object->direct3d = This;
-    IDirect3D9_AddRef((LPDIRECT3D9) object->direct3d);
     *ppReturnedDeviceInterface = (IDirect3DDevice9 *)object;
     
     /* Allocate an associated WineD3DDevice object */
@@ -226,7 +388,11 @@
     localParameters.Flags                          = &pPresentationParameters->Flags;                      
     localParameters.FullScreen_RefreshRateInHz     = &pPresentationParameters->FullScreen_RefreshRateInHz; 
     localParameters.PresentationInterval           = &pPresentationParameters->PresentationInterval;       
-    return IWineD3D_CreateDevice(This->WineD3D, Adapter, DeviceType, hFocusWindow, BehaviourFlags, &localParameters, &object->WineD3DDevice, (IUnknown *)object, D3D9CB_CreateRenderTarget);
+   
+    IWineD3D_CreateDevice(This->WineD3D, Adapter, DeviceType, hFocusWindow, BehaviourFlags, &localParameters, &object->WineD3DDevice, (IUnknown *)object, D3D9CB_CreateRenderTarget, D3D9CB_CreateDepthStencilSurface, D3D9CB_CreateAdditionalSwapChain);
+      
+    TRACE("(%p) : Created Device %p\n", This, object);
+    return D3D_OK;
 }
 
 IDirect3D9Vtbl Direct3D9_Vtbl =
diff -urN wine.20050419/dlls/d3d9/pixelshader.c wine.20050419.dx9/dlls/d3d9/pixelshader.c
--- wine.20050419/dlls/d3d9/pixelshader.c	2005-01-24 05:44:01.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/pixelshader.c	2005-04-20 01:52:56.000000000 -0600
@@ -22,15 +22,16 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d_shader);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
-/* IDirect3DPixelShader9 IUnknown parts follow: */
+/*IUnknown Parts*/
 HRESULT WINAPI IDirect3DPixelShader9Impl_QueryInterface(LPDIRECT3DPIXELSHADER9 iface, REFIID riid, LPVOID* ppobj) {
     IDirect3DPixelShader9Impl *This = (IDirect3DPixelShader9Impl *)iface;
+    TRACE("(%p) Relay\n", This);
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DPixelShader9)) {
-        IDirect3DPixelShader9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -63,16 +64,22 @@
 /* IDirect3DPixelShader9 Interface follow: */
 HRESULT WINAPI IDirect3DPixelShader9Impl_GetDevice(LPDIRECT3DPIXELSHADER9 iface, IDirect3DDevice9** ppDevice) {
     IDirect3DPixelShader9Impl *This = (IDirect3DPixelShader9Impl *)iface;
-    TRACE("(%p) : returning %p\n", This, This->Device);
-    *ppDevice = (LPDIRECT3DDEVICE9) This->Device;
-    IDirect3DDevice9Impl_AddRef(*ppDevice);
+    IWineD3DDevice *myDevice = NULL;
+    
+    TRACE("(%p) : Relay\n", This);
+
+    IWineD3DPixelShader_GetDevice(This->wineD3DPixelShader, &myDevice);
+    IWineD3DDevice_GetParent(myDevice, (IUnknown **)ppDevice);
+    IWineD3DDevice_Release(myDevice);
+    TRACE("(%p) returing (%p)", This, *ppDevice);
     return D3D_OK;
+    
 }
 
 HRESULT WINAPI IDirect3DPixelShader9Impl_GetFunction(LPDIRECT3DPIXELSHADER9 iface, VOID* pData, UINT* pSizeOfData) {
     IDirect3DPixelShader9Impl *This = (IDirect3DPixelShader9Impl *)iface;
-    FIXME("(%p): stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This);
+    return IWineD3DPixelShader_GetFunction(This->wineD3DPixelShader, pData, pSizeOfData);   
 }
 
 
@@ -89,148 +96,100 @@
 /* IDirect3DDevice9 IDirect3DPixelShader9 Methods follow:  */
 HRESULT WINAPI IDirect3DDevice9Impl_CreatePixelShader(LPDIRECT3DDEVICE9 iface, CONST DWORD* pFunction, IDirect3DPixelShader9** ppShader) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
+    IDirect3DPixelShader9Impl *object;
+    HRESULT hrc = D3D_OK;
+
+    FIXME("(%p) Relay (disabled)\n", This);
+    *ppShader = NULL;
     return D3D_OK;
+    if(ppShader == NULL){
+        TRACE("(%p) Invalid call\n", This);
+        return D3DERR_INVALIDCALL;
 }
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
 
-HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9* pShader) {
-    IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    if(NULL == object){    
+        return E_OUTOFMEMORY;        
+    }else{
 
-    This->UpdateStateBlock->PixelShader = pShader;
-    This->UpdateStateBlock->Changed.pixelShader = TRUE;
-    This->UpdateStateBlock->Set.pixelShader = TRUE;
-    
-    /* Handle recording of state blocks */
-    if (This->isRecordingState) {
-      TRACE("Recording... not performing anything\n");
-      return D3D_OK;
+        object->ref    = 1;
+        object->lpVtbl = &Direct3DPixelShader9_Vtbl;
+        hrc = IWineD3DDevice_CreatePixelShader(This->WineD3DDevice, pFunction, &object->wineD3DPixelShader , (IUnknown *)object);
+        if(hrc != D3D_OK){
+            FIXME("(%p) call to IWineD3DDevice_CreatePixelShader failed\n", This);
+            HeapFree(GetProcessHeap(), 0 , object);
+            *ppShader = NULL;
+        }else{
+            *ppShader = (IDirect3DPixelShader9*) object;
     }
-    /**
-     * TODO: merge HAL shaders context switching from prototype
-     */
-    return D3D_OK;
+        
 }
 
-HRESULT WINAPI IDirect3DDevice9Impl_GetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9** ppShader) {
+    TRACE("(%p) : returning %p\n", This, *ppShader);
+    return hrc;
+}
+
+HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9* pShader) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    TRACE("(%p) : GetPixelShader returning %p\n", This, This->StateBlock->PixelShader);
-    *ppShader = This->StateBlock->PixelShader;
-    IDirect3DPixelShader9Impl_AddRef(*ppShader);
+    IDirect3DPixelShader9Impl *shader = (IDirect3DPixelShader9Impl *)pShader;
+    TRACE("(%p) Relay\n", This);
+    IWineD3DDevice_SetPixelShader(This->WineD3DDevice, shader == NULL ? NULL :shader->wineD3DPixelShader);
     return D3D_OK;
 }
 
-HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT Register, CONST float* pConstantData, UINT Vector4fCount) {
+HRESULT WINAPI IDirect3DDevice9Impl_GetPixelShader(LPDIRECT3DDEVICE9 iface, IDirect3DPixelShader9** ppShader) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    IWineD3DPixelShader *object;
 
-  if (Register + Vector4fCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetPixelShaderConstant C[%u] invalid\n", This, Register);
+    HRESULT hrc = D3D_OK;
+    TRACE("(%p) Relay\n", This);
+    if(ppShader == NULL){
+        TRACE("(%p) Invalid call\n", This);
     return D3DERR_INVALIDCALL;
   }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (Vector4fCount > 1) {
-    CONST FLOAT* f = pConstantData;
-    UINT i;
-    TRACE("(%p) : SetPixelShaderConstant C[%u..%u]=\n", This, Register, Register + Vector4fCount - 1);
-    for (i = 0; i < Vector4fCount; ++i) {
-      TRACE("{%f, %f, %f, %f}\n", f[0], f[1], f[2], f[3]);
-      f += 4;
+    
+    hrc = IWineD3DDevice_GetPixelShader(This->WineD3DDevice, &object);
+    if(hrc == D3D_OK){
+       hrc = IWineD3DPixelShader_GetParent(object, (IUnknown **)ppShader);
+       IWineD3DPixelShader_Release(object);
     }
-  } else { 
-    const FLOAT* f = (const FLOAT*) pConstantData;
-    TRACE("(%p) : SetPixelShaderConstant, C[%u]={%f, %f, %f, %f}\n", This, Register, f[0], f[1], f[2], f[3]);
+
+    TRACE("(%p) : returning %p\n", This, *ppShader);
+    return hrc;
   }
-  This->UpdateStateBlock->Changed.pixelShaderConstant = TRUE;
-  memcpy(&This->UpdateStateBlock->pixelShaderConstantF[Register], pConstantData, Vector4fCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
+
+HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT Register, CONST float* pConstantData, UINT Vector4fCount) {
+    IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    TRACE("(%p) Relay\n", This);   
+    return IWineD3DDevice_SetPixelShaderConstantF(This->WineD3DDevice, Register, pConstantData, Vector4fCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetPixelShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT Register, float* pConstantData, UINT Vector4fCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  TRACE("(%p) : C[%u] count=%u\n", This, Register, Vector4fCount);
-  if (Register + Vector4fCount > D3D_VSHADER_MAX_CONSTANTS) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  memcpy(pConstantData, &This->UpdateStateBlock->pixelShaderConstantF[Register], Vector4fCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
+    TRACE("(%p) Relay\n", This);   
+    return IWineD3DDevice_GetPixelShaderConstantF(This->WineD3DDevice, Register, pConstantData, Vector4fCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShaderConstantI(LPDIRECT3DDEVICE9 iface, UINT Register, CONST int* pConstantData, UINT Vector4iCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  if (Register + Vector4iCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetPixelShaderConstantI C[%u] invalid\n", This, Register);
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (Vector4iCount > 1) {
-    CONST int* f = pConstantData;
-    UINT i;
-    TRACE("(%p) : SetPixelShaderConstantI C[%u..%u]=\n", This, Register, Register + Vector4iCount - 1);
-    for (i = 0; i < Vector4iCount; ++i) {
-      TRACE("{%d, %d, %d, %d}\n", f[0], f[1], f[2], f[3]);
-      f += 4;
-    }
-  } else { 
-    CONST int* f = pConstantData;
-    TRACE("(%p) : SetPixelShaderConstantI, C[%u]={%i, %i, %i, %i}\n", This, Register, f[0], f[1], f[2], f[3]);
-  }
-  This->UpdateStateBlock->Changed.pixelShaderConstant = TRUE;
-  memcpy(&This->UpdateStateBlock->pixelShaderConstantI[Register], pConstantData, Vector4iCount * 4 * sizeof(int));
-  return D3D_OK;
+    TRACE("(%p) Relay\n", This);   
+    return IWineD3DDevice_SetPixelShaderConstantI(This->WineD3DDevice, Register, pConstantData, Vector4iCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetPixelShaderConstantI(LPDIRECT3DDEVICE9 iface, UINT Register, int* pConstantData, UINT Vector4iCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  TRACE("(%p) : C[%u] count=%u\n", This, Register, Vector4iCount);
-  if (Register + Vector4iCount > D3D_VSHADER_MAX_CONSTANTS) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  memcpy(pConstantData, &This->UpdateStateBlock->pixelShaderConstantI[Register], Vector4iCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DDevice_GetPixelShaderConstantI(This->WineD3DDevice, Register, pConstantData, Vector4iCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetPixelShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT Register, CONST BOOL* pConstantData, UINT BoolCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-  UINT i;
-
-  if (Register + BoolCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetPixelShaderConstantB C[%u] invalid\n", This, Register);
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (BoolCount > 1) {
-    CONST BOOL* f = pConstantData;
-    TRACE("(%p) : SetPixelShaderConstantB C[%u..%u]=\n", This, Register, Register + BoolCount - 1);
-    for (i = 0; i < BoolCount; ++i) {
-      TRACE("{%u}\n", f[i]);
-    }
-  } else { 
-    CONST BOOL* f = pConstantData;
-    TRACE("(%p) : SetPixelShaderConstantB, C[%u]={%u}\n", This, Register, f[0]);
-  }
-  This->UpdateStateBlock->Changed.pixelShaderConstant = TRUE;
-  for (i = 0; i < BoolCount; ++i) {
-    This->UpdateStateBlock->pixelShaderConstantB[Register] = pConstantData[i];
-  }
-  return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return  IWineD3DDevice_SetPixelShaderConstantB(This->WineD3DDevice, Register, pConstantData, BoolCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetPixelShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT Register, BOOL* pConstantData, UINT BoolCount) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DDevice_GetPixelShaderConstantB(This->WineD3DDevice, Register, pConstantData, BoolCount);
 }
diff -urN wine.20050419/dlls/d3d9/stateblock.c wine.20050419.dx9/dlls/d3d9/stateblock.c
--- wine.20050419/dlls/d3d9/stateblock.c	2005-01-24 05:44:01.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/stateblock.c	2005-04-20 01:52:56.000000000 -0600
@@ -22,7 +22,7 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
 /* IDirect3DStateBlock9 IUnknown parts follow: */
 HRESULT WINAPI IDirect3DStateBlock9Impl_QueryInterface(LPDIRECT3DSTATEBLOCK9 iface, REFIID riid, LPVOID* ppobj) {
@@ -30,7 +30,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DStateBlock9)) {
-        IDirect3DStateBlock9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -55,6 +55,7 @@
     TRACE("(%p) : ReleaseRef to %ld\n", This, ref);
 
     if (ref == 0) {
+        IWineD3DStateBlock_Release(This->wineD3DStateBlock);
         HeapFree(GetProcessHeap(), 0, This);
     }
     return ref;
@@ -63,25 +64,22 @@
 /* IDirect3DStateBlock9 Interface follow: */
 HRESULT WINAPI IDirect3DStateBlock9Impl_GetDevice(LPDIRECT3DSTATEBLOCK9 iface, IDirect3DDevice9** ppDevice) {
     IDirect3DStateBlock9Impl *This = (IDirect3DStateBlock9Impl *)iface;
-    TRACE("(%p) : returning %p\n", This, This->Device);
-    *ppDevice = (LPDIRECT3DDEVICE9) This->Device;
-    IDirect3DDevice9Impl_AddRef(*ppDevice);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IDirect3DResource9Impl_GetDevice((LPDIRECT3DRESOURCE9) This, ppDevice);
 }
 
 HRESULT WINAPI IDirect3DStateBlock9Impl_Capture(LPDIRECT3DSTATEBLOCK9 iface) {
     IDirect3DStateBlock9Impl *This = (IDirect3DStateBlock9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DStateBlock_Capture(This->wineD3DStateBlock);
 }
 
 HRESULT WINAPI IDirect3DStateBlock9Impl_Apply(LPDIRECT3DSTATEBLOCK9 iface) {
     IDirect3DStateBlock9Impl *This = (IDirect3DStateBlock9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DStateBlock_Apply(This->wineD3DStateBlock);
 }
 
-
 IDirect3DStateBlock9Vtbl Direct3DStateBlock9_Vtbl =
 {
     IDirect3DStateBlock9Impl_QueryInterface,
@@ -93,21 +91,36 @@
 };
 
 
-/* IDirect3DDevice9 IDirect3DStateBlock9 Methods follow: */
-HRESULT  WINAPI  IDirect3DDevice9Impl_CreateStateBlock(LPDIRECT3DDEVICE9 iface, D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB) {
-    IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
-}
+
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_BeginStateBlock(LPDIRECT3DDEVICE9 iface) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This); 
+    return IWineD3DDevice_BeginStateBlock(This->WineD3DDevice);
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_EndStateBlock(LPDIRECT3DDEVICE9 iface, IDirect3DStateBlock9** ppSB) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
+    HRESULT hr;
+    IWineD3DStateBlock* wineD3DStateBlock;    
+    IDirect3DStateBlock9Impl* object;
+	
+    TRACE("(%p) Relay\n", This); 
+    
+    /*Tell wineD3D to endstatablock before anything else (incase we run out of memory later and cause locking problems)*/
+    hr=IWineD3DDevice_EndStateBlock(This->WineD3DDevice,&wineD3DStateBlock);
+    if(hr!= D3D_OK){
+       FIXME("IWineD3DDevice_EndStateBlock returned an error\n");
+       return hr;
+    }    
+    /*allocate a new IDirectD3DStateBlock*/
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY ,sizeof(IDirect3DStateBlock9Impl));      
+    object->ref = 1;
+    object->lpVtbl = &Direct3DStateBlock9_Vtbl;
+      
+    object->wineD3DStateBlock=wineD3DStateBlock;
+  
+    *ppSB=(IDirect3DStateBlock9*)object;        
+    TRACE("(%p)Returning %p %p\n", This, *ppSB, wineD3DStateBlock);
     return D3D_OK;
 }
diff -urN wine.20050419/dlls/d3d9/swapchain.c wine.20050419.dx9/dlls/d3d9/swapchain.c
--- wine.20050419/dlls/d3d9/swapchain.c	2005-01-24 05:44:01.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/swapchain.c	2005-04-20 01:52:56.000000000 -0600
@@ -22,7 +22,7 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
 /* IDirect3DSwapChain IUnknown parts follow: */
 HRESULT WINAPI IDirect3DSwapChain9Impl_QueryInterface(LPDIRECT3DSWAPCHAIN9 iface, REFIID riid, LPVOID* ppobj)
@@ -31,7 +31,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DSwapChain9)) {
-        IDirect3DSwapChain9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
 	*ppobj = This;
         return D3D_OK;
     }
@@ -56,58 +56,78 @@
     TRACE("(%p) : ReleaseRef to %ld\n", This, ref);
 
     if (ref == 0) {
+        IWineD3DSwapChain_Release(This->wineD3DSwapChain);
         HeapFree(GetProcessHeap(), 0, This);
     }
     return ref;
 }
 
+
 /* IDirect3DSwapChain9 parts follow: */
 HRESULT WINAPI IDirect3DSwapChain9Impl_Present(LPDIRECT3DSWAPCHAIN9 iface, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion, DWORD dwFlags) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
+    TRACE("(%p) Relay\n", This);
+    IWineD3DSwapChain_Present(This->wineD3DSwapChain, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, dwFlags);    
     return D3D_OK;
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetFrontBufferData(LPDIRECT3DSWAPCHAIN9 iface, IDirect3DSurface9* pDestSurface) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    
+    TRACE("(%p) Relay\n", This);
+    return IWineD3DSwapChain_GetFrontBufferData(This->wineD3DSwapChain,  ((IDirect3DSurface9Impl *)pDestSurface)->wineD3DSurface);
+    
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetBackBuffer(LPDIRECT3DSWAPCHAIN9 iface, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    HRESULT hrc = D3D_OK;
+    IWineD3DSurface *mySurface = NULL;
+
+    TRACE("(%p) Relay\n", This);
+    
+    hrc = IWineD3DSwapChain_GetBackBuffer(This->wineD3DSwapChain, iBackBuffer, Type, &mySurface);
+    if (hrc == D3D_OK && NULL != mySurface) {
+       IWineD3DSurface_GetParent(mySurface, (IUnknown **)ppBackBuffer);
+       IWineD3DSurface_Release(mySurface);
+    }
+    return hrc;
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetRasterStatus(LPDIRECT3DSWAPCHAIN9 iface, D3DRASTER_STATUS* pRasterStatus) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This);
+    return IWineD3DSwapChain_GetRasterStatus(This->wineD3DSwapChain, pRasterStatus);       
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetDisplayMode(LPDIRECT3DSWAPCHAIN9 iface, D3DDISPLAYMODE* pMode) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This);
+    return IWineD3DSwapChain_GetDisplayMode(This->wineD3DSwapChain, pMode);    
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetDevice(LPDIRECT3DSWAPCHAIN9 iface, IDirect3DDevice9** ppDevice) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;  
-    TRACE("(%p) : returning %p\n", This, This->Device);
-    *ppDevice = (LPDIRECT3DDEVICE9) This->Device;
+    HRESULT hrc = D3D_OK;    
+    IWineD3DDevice *device = NULL;
 
-    /* Note  Calling this method will increase the internal reference count 
-       on the IDirect3DDevice9 interface. */
-    IDirect3DDevice9Impl_AddRef(*ppDevice);
-    return D3D_OK;
+    TRACE("(%p) Relay\n", This);
+
+    hrc = IWineD3DSwapChain_GetDevice(This->wineD3DSwapChain, &device);
+    if (hrc == D3D_OK && NULL != device) {
+       IWineD3DDevice_GetParent(device, (IUnknown **)ppDevice);
+       IWineD3DDevice_Release(device);
+    }
+    return hrc;
 }
 
 HRESULT WINAPI IDirect3DSwapChain9Impl_GetPresentParameters(LPDIRECT3DSWAPCHAIN9 iface, D3DPRESENT_PARAMETERS* pPresentationParameters) {
     IDirect3DSwapChain9Impl *This = (IDirect3DSwapChain9Impl *)iface;
-    FIXME("(%p) : copy\n", This); 
+    FIXME("(%p) : inplement using WINED3DPRESENT_PARAMERS\n", This);     
+    return IWineD3DSwapChain_GetPresentParameters(This->wineD3DSwapChain, pPresentationParameters);
+    /*
     memcpy(pPresentationParameters, &This->PresentParms, sizeof(D3DPRESENT_PARAMETERS));
-    return D3D_OK;
+    */    
 }
 
 
@@ -129,18 +149,69 @@
 /* IDirect3DDevice9 IDirect3DSwapChain9 Methods follow: */
 HRESULT  WINAPI  IDirect3DDevice9Impl_CreateAdditionalSwapChain(LPDIRECT3DDEVICE9 iface, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
+    IDirect3DSwapChain9Impl* object;
+    HRESULT hrc = D3D_OK;
+    WINED3DPRESENT_PARAMETERS localParameters;
+
+    TRACE("(%p) Relay\n", This);
+
+    object = HeapAlloc(GetProcessHeap(),  HEAP_ZERO_MEMORY, sizeof(*object));    
+    if (NULL == object) {
+        FIXME("Allocation of memory failed\n");
+        *pSwapChain = NULL;
+        return D3DERR_OUTOFVIDEOMEMORY;
+    }
+    object->ref = 1;
+    object->lpVtbl = &Direct3DSwapChain9_Vtbl;
+    
+    /* Allocate an associated WineD3DDevice object */
+    localParameters.BackBufferWidth                = &pPresentationParameters->BackBufferWidth;
+    localParameters.BackBufferHeight               = &pPresentationParameters->BackBufferHeight;           
+    localParameters.BackBufferFormat               = &pPresentationParameters->BackBufferFormat;           
+    localParameters.BackBufferCount                = &pPresentationParameters->BackBufferCount;            
+    localParameters.MultiSampleType                = &pPresentationParameters->MultiSampleType;            
+    localParameters.MultiSampleQuality             = &pPresentationParameters->MultiSampleQuality;         
+    localParameters.SwapEffect                     = &pPresentationParameters->SwapEffect;                 
+    localParameters.hDeviceWindow                  = &pPresentationParameters->hDeviceWindow;             
+    localParameters.Windowed                       = &pPresentationParameters->Windowed;                   
+    localParameters.EnableAutoDepthStencil         = &pPresentationParameters->EnableAutoDepthStencil;     
+    localParameters.AutoDepthStencilFormat         = &pPresentationParameters->AutoDepthStencilFormat;     
+    localParameters.Flags                          = &pPresentationParameters->Flags;                      
+    localParameters.FullScreen_RefreshRateInHz     = &pPresentationParameters->FullScreen_RefreshRateInHz; 
+    localParameters.PresentationInterval           = &pPresentationParameters->PresentationInterval;      
+    
+    
+    
+    
+    hrc = IWineD3DDevice_CreateAdditionalSwapChain(This->WineD3DDevice, &localParameters, &object->wineD3DSwapChain, (IUnknown*)object, D3D9CB_CreateRenderTarget, D3D9CB_CreateDepthStencilSurface);
+    if(hrc != D3D_OK){
+        FIXME("(%p) call to IWineD3DDevice_CreateAdditionalSwapChain failed\n", This);
+        HeapFree(GetProcessHeap(), 0 , object);
+        *pSwapChain = NULL;
+    }else{
+        *pSwapChain = (IDirect3DSwapChain9 *)object;
+    }
+    TRACE("(%p) returning %p\n", This, *pSwapChain);
     return D3D_OK;
 }
 
 HRESULT  WINAPI  IDirect3DDevice9Impl_GetSwapChain(LPDIRECT3DDEVICE9 iface, UINT iSwapChain, IDirect3DSwapChain9** pSwapChain) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    HRESULT hrc = D3D_OK;    
+    IWineD3DSwapChain *swapchain = NULL;
+
+    TRACE("(%p) Relay\n", This);
+
+    hrc = IWineD3DDevice_GetSwapChain(This->WineD3DDevice, iSwapChain, &swapchain);
+    if (hrc == D3D_OK && NULL != swapchain) {
+       IWineD3DSwapChain_GetParent(swapchain, (IUnknown **)pSwapChain);
+       IWineD3DSwapChain_Release(swapchain);
+    }
+    return hrc;                
 }
 
 UINT     WINAPI  IDirect3DDevice9Impl_GetNumberOfSwapChains(LPDIRECT3DDEVICE9 iface) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return 1;
+    TRACE("(%p) Relay\n", This);
+    return IWineD3DDevice_GetNumberOfSwapChains(This->WineD3DDevice);
 }
diff -urN wine.20050419/dlls/d3d9/tests/.cvsignore wine.20050419.dx9/dlls/d3d9/tests/.cvsignore
--- wine.20050419/dlls/d3d9/tests/.cvsignore	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/tests/.cvsignore	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,3 @@
+Makefile
+ddrawmodes.ok
+testlist.c
diff -urN wine.20050419/dlls/d3d9/tests/Makefile.in wine.20050419.dx9/dlls/d3d9/tests/Makefile.in
--- wine.20050419/dlls/d3d9/tests/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/tests/Makefile.in	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,13 @@
+TOPSRCDIR = @top_srcdir@
+TOPOBJDIR = ../../..
+SRCDIR    = @srcdir@
+VPATH     = @srcdir@
+TESTDLL   = d3d9.dll
+IMPORTS   = ddraw user32 gdi32 kernel32 d3d9 opengl
+
+CTESTS = \
+	d3d9tests.c
+
+@MAKE_TEST_RULES@
+
+### Dependencies:
diff -urN wine.20050419/dlls/d3d9/tests/d3d9tests.c wine.20050419.dx9/dlls/d3d9/tests/d3d9tests.c
--- wine.20050419/dlls/d3d9/tests/d3d9tests.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/tests/d3d9tests.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,783 @@
+/*
+ * Unit tests for ddraw functions
+ *
+ * Copyright (C) 2003 Sami Aario
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <assert.h>
+#include "wine/test.h"
+#include "ddraw.h"
+#include "d3d9.h"
+#include "d3dx9.h" /*This is fore some of the structures, all code relating to calls is included in the testsuite*/
+
+#ifdef NONAMELESSUNION
+#define UNION_MEMBER(x, y) DUMMYUNIONNAME##x.y
+#else
+#define UNION_MEMBER(x, y) y
+#endif
+
+
+
+
+typedef struct MY_CUSTOM_VERTEX
+{
+    D3DXVECTOR3 position;
+    D3DCOLOR color;
+} MY_CUSTOM_VERTEX;
+
+#define MY_CUSTOM_VERTEX_FVF (D3DFVF_XYZ|D3DFVF_DIFFUSE)
+
+
+static D3DXVECTOR3 D3DXVector3(float x, float y, float z);
+//static extern D3DXMATR* D3DXMatrixInentity   ( D3DXMATRIX *pOut );
+
+static IDirect3D9 *lpD3D9 = NULL;
+static IDirect3DDevice9* lpD3D9Device = NULL;
+static LPDIRECT3DVERTEXBUFFER9 m_pVertexBuffer = NULL;
+static WNDCLASS wc;
+static HWND hwnd;
+static float wndWidth;
+static float wndHeight;
+static int modes_cnt;
+static int modes_size;
+static LPDDSURFACEDESC modes;
+
+static D3DXMATRIX m_matProjection;
+static D3DXMATRIX m_matWorld;
+static D3DXMATRIX m_matView;
+
+    // These vars hold info on the vertices
+static     int     m_iNumVertices;     // Number of vertices that will make the shape
+static     int     m_iNumPolygons;     // Number of polygons to use
+static     float   m_fXPos;            // The starting X position of our shape
+static     float   m_fYPos;            // The starting Y position of our shape
+static     float   m_fZPos;            // The starting Z position
+
+static void createdirectdraw()
+{
+    HRESULT rc;
+
+
+    wc.style = CS_HREDRAW | CS_VREDRAW;
+    wc.lpfnWndProc = DefWindowProcA;
+    wc.cbClsExtra = 0;
+    wc.cbWndExtra = 0;
+    wc.hInstance = GetModuleHandleA(0);
+    wc.hIcon = LoadIconA(wc.hInstance, IDI_APPLICATION);
+    wc.hCursor = LoadCursorA(NULL, IDC_ARROW);
+    wc.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);
+    wc.lpszMenuName = NULL;
+    wc.lpszClassName = "TestWindowClass";
+    if(!RegisterClassA(&wc))
+        assert(0);
+        
+    wndWidth  = GetSystemMetrics(SM_CXSCREEN);
+    wndHeight = GetSystemMetrics(SM_CXSCREEN);
+    
+    
+    hwnd = CreateWindowExA(0, "TestWindowClass", "TestWindowClass",
+        WS_POPUP, 0, 0,
+        wndWidth,
+        wndHeight,
+        NULL, NULL, GetModuleHandleA(0), NULL);
+    assert(hwnd != NULL);
+    
+    ShowWindow(hwnd, SW_HIDE);
+    UpdateWindow(hwnd);
+    SetFocus(hwnd);
+    ShowCursor(TRUE); 
+
+    /*rc = DirectDrawCreate(NULL, &lpDD, NULL);*/
+                    
+    lpD3D9 = Direct3DCreate9(D3D_SDK_VERSION);        
+    ok(lpD3D9 != NULL ,"Direct3DCreate9 returned: %lx\n",rc);
+    
+    D3DDEVICE_CREATION_PARAMETERS dcp;
+    dcp.AdapterOrdinal = D3DADAPTER_DEFAULT; 
+    dcp.DeviceType = D3DDEVTYPE_HAL;          
+    dcp.hFocusWindow = hwnd;
+    dcp.BehaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
+    
+    D3DDISPLAYMODE d3ddm;
+    
+    IDirect3D9_GetAdapterDisplayMode(lpD3D9, dcp.AdapterOrdinal, &d3ddm);        
+    
+    D3DPRESENT_PARAMETERS d3dpp;
+    
+    memset(&d3dpp, 0 , sizeof(d3dpp));
+    
+    /*Creation parameters*/
+    d3dpp.BackBufferCount = 1; 
+    d3dpp.SwapEffect = 0;/*D3DSWAPEFFECT_DISCARD;*/
+    d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
+    d3dpp.EnableAutoDepthStencil = TRUE; 
+    d3dpp.AutoDepthStencilFormat = D3DFMT_D16; 
+    
+    d3dpp.BackBufferWidth = d3ddm.Width;
+    d3dpp.BackBufferHeight = d3ddm.Height;
+    d3dpp.BackBufferFormat = d3ddm.Format; 
+    d3dpp.Windowed = FALSE;
+    d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
+    d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
+        
+    IDirect3D9_CreateDevice(lpD3D9,  dcp.AdapterOrdinal,  dcp.DeviceType,  dcp.hFocusWindow, 
+        dcp.BehaviorFlags, &d3dpp, &lpD3D9Device);
+
+    D3DXMatrixIdentity(&m_matWorld);
+    D3DXMatrixIdentity(&m_matView);
+    D3DXMatrixIdentity(&m_matProjection);
+}
+/*most of the tests will be run with the viewport set to the identity matrix*/
+static void setupDevice(){
+
+    IDirect3DDevice9_SetRenderState(lpD3D9Device, D3DRS_LIGHTING, FALSE);
+    IDirect3DDevice9_SetRenderState(lpD3D9Device, D3DRS_CULLMODE, D3DCULL_NONE);
+    
+/*    IDirect3DDevice9_SetTransform(lpD3D9Device, D3DRS_CULLMODE, D3DCULL_NONE);*/
+    IDirect3DDevice9_SetRenderState(lpD3D9Device, D3DRS_CULLMODE, D3DCULL_NONE);
+    
+    /*The device needs to be setup with no perspectine since it's not needed for mosts tests
+    ideally it should be switched on for test without-perspective, test with-perspective.    
+    */
+    /*
+   D3DXMatrixPerspectiveFovLH(&m_matProjection, D3DX_PI/4.0f, 
+                                        (float)(wndWidth/wndHeight),
+                                        1.0f, 1000.0f); */
+                                        
+    IDirect3DDevice9_SetTransform(lpD3D9Device, D3DTS_PROJECTION, &m_matProjection);
+
+    D3DXVECTOR3 v1;
+    D3DXVECTOR3 v2;
+    D3DXVECTOR3 v3;
+
+    v1 = D3DXVector3(0, 0, -50);
+    v2 = D3DXVector3(0, 0, 0);
+    v3 = D3DXVector3(0, 1, 0);
+    /* D3DXVector3(0.0f, 00.0f, -50.0f) */
+    /* D3DXVector3(0.0f, 0.0f, 0.0f)    */
+   /* D3DXVector3(0.0f, 1.0f, .0f)    */
+    
+   /* D3DXMatrixLookAtLH(&m_matView, &v1, &v2, &v3); */
+                                     
+    IDirect3DDevice9_SetTransform(lpD3D9Device, D3DTS_VIEW, &m_matView);
+    
+    
+}
+#include <stdio.h>
+
+/* TODO: This needs to be a lot more generic so that it's easy to create vertex buffers with differnt sets of properties for testing */
+static void createVertexBuffer(){
+
+
+    MY_CUSTOM_VERTEX *pVertices = NULL;
+
+    m_pVertexBuffer = NULL;
+    // 3 vertices per triangle, and 2 triangles per square,
+    // and 2 squares. so we have 3*2*2 = 12 vertices.
+    m_iNumVertices = 6;
+    // 2 squares, and each square is made out of 2
+    // triangles. A triangle is a polygon, so we
+    // have 4 polygons.
+    m_iNumPolygons = 2;
+    m_fXPos = 0;
+    m_fYPos = 0;
+    m_fZPos = 0;
+
+    
+
+    /* This function is used to initialize our vertex buffer
+    * interface. It is a straight forward function, which gives
+    * you back a pointer to your initialized vertex buffer
+    * ******************************************************/
+    IDirect3DDevice9_CreateVertexBuffer(lpD3D9Device, m_iNumVertices*sizeof(MY_CUSTOM_VERTEX), D3DUSAGE_WRITEONLY, MY_CUSTOM_VERTEX_FVF, D3DPOOL_DEFAULT, &m_pVertexBuffer, NULL);
+    
+
+    /* Now we have to fill in the vertex buffer. To do that we have to
+    * lock the vertex buffer, then we fill in the vertex buffer, then we
+    * unlock it, so ...
+    * ******************************************************/
+    IDirect3DVertexBuffer9_Lock(m_pVertexBuffer, 0, 0, (void**)&pVertices, 0);
+    
+
+    /* Now we use pVertices to access our vertex buffer, and change it
+    * This time we make 12 vertices. 6 for 2 squares (quads)
+    * ******************************************************/
+    
+    /* First triangle in first quad */
+    pVertices[0].position = D3DXVector3(-.5f, -0.5f, 0.0f);
+    pVertices[1].position = D3DXVector3(.5f, -0.5f, 0.0f);
+    pVertices[2].position = D3DXVector3(-0.5f, 0.5f, 0.0f);
+
+    /* Second triangle in first quad */
+    pVertices[3].position = D3DXVector3(0.5f, 0.5f, 0.0f);
+    pVertices[4].position = D3DXVector3(0.5f, -0.5f, 0.0f);
+    pVertices[5].position = D3DXVector3(-0.5f, 0.5f, 0.0f);
+
+    #if 0
+    // First triangle in second quad
+    pVertices[6].position = D3DXVector3(-2.0f, -2.0f, 2.0f);
+    pVertices[7].position = D3DXVector3(2.0f, -2.0f, 2.0f);
+    pVertices[8].position = D3DXVector3(-2.0f, 2.0f, 2.0f);
+
+    // Second triangle in second quad
+    pVertices[9].position = D3DXVector3(2.0f, 2.0f, 2.0f);
+    pVertices[10].position = D3DXVector3(2.0f, -2.0f, 2.0f);
+    pVertices[11].position = D3DXVector3(-2.0f, 2.0f, 2.0f);
+    #endif
+    /* Ok we finished fixing the vertices' positions
+    * now we'll give them color
+
+    * We will fill in the first 6 vertices with one color
+    * and the last 6 vertices with a different color.
+    * m_iNumVertices is the total number of vertices, so
+    * divide by 2 and you fill in half the buffer with one
+    * color, and the other half with another colot
+    * ******************************************************/
+    
+    int i;
+    for(i = 0; i < (int)(m_iNumVertices); i++)
+    {
+        pVertices[i].color = D3DCOLOR_ARGB(255,0 ,0, 255);  //Blue
+    }
+#if 0
+    // Make the colors different for the second square
+    for(i = (int)(m_iNumVertices/2); i < m_iNumVertices; i++)
+    {
+        // Notice I am using a different D3DCOLOR macro
+        // this does the same thing. right click on it in
+        // VC++ 6.0 and click on Go To Definition, and see what comes up
+        pVertices[i].color = D3DCOLOR_XRGB(255, 255, 0); //Yellow
+    }
+#endif
+    /* Ok, we are done with the vertex buffer. now unlock it */
+    IDirect3DVertexBuffer9_Unlock(m_pVertexBuffer);
+                                  
+    return TRUE;
+}
+
+
+
+
+static void destroyVertexBuffer(){
+    if(m_pVertexBuffer != NULL){
+        IDirect3DVertexBuffer9_Release(m_pVertexBuffer);
+    }
+}
+
+
+#include <stdio.h>
+
+static void drawSomething(){
+/*draw something onto the iface*/
+/*just draw a primitive*/
+
+    createVertexBuffer();
+    if(D3D_OK == IDirect3DDevice9_SetFVF(lpD3D9Device, MY_CUSTOM_VERTEX_FVF)){
+        printf("ok\n");
+    };
+
+    if(D3D_OK == IDirect3DDevice9_SetStreamSource(lpD3D9Device, 0, m_pVertexBuffer, 0, sizeof(MY_CUSTOM_VERTEX))){
+            printf("ok\n");
+    }
+
+    // We are going to be scaling our object, moving it, and rotating
+    // it about the Z_Axis, so we have a matrix for Traslation
+    // Scaling, and Rotation.
+    D3DXMATRIX matS, matZ, matT;
+    
+    // We use handy D3DX functions to create our matrices
+   if(D3D_OK == D3DXMatrixScaling(&matS, 1.0f, 1.0f, 1.0f)){
+           printf("ok\n");
+   }
+    
+    /* D3DXMatrixRotationZ(&matZ, timeGetTime()/1000.0f);*/
+    // We're creating the translation matrix with variables
+    // because we want to be able to move the quads on the 
+    // screen.
+    if(D3D_OK == D3DXMatrixTranslation(&matT, m_fXPos, m_fYPos, m_fZPos)){
+            printf("ok\n");
+    }
+
+    // Multiply all teh matrices together to get the final matrix.
+    // So now m_matWorld is a combination of movement (matT), 
+    // rotation along the z axis (matR) and a scale value (matS)
+    m_matWorld = matS;/* * matZ * matT;*/
+
+    IDirect3DDevice9_Clear(lpD3D9Device, 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(0,0,30), 1.0f, 0);
+    IDirect3DDevice9_Present(lpD3D9Device, NULL,  NULL, NULL, NULL);
+    printf("Dark blue filling the window\n");
+    getchar();
+    IDirect3DDevice9_BeginScene(lpD3D9Device);
+
+    // Set the world matrix to what we calculated above. Now anything
+    // you draw after setting the world amtrix will be affected by the 
+    // transformations in m_matWorld. Try setting the world matrix
+    // to an identity and see what happens.
+    IDirect3DDevice9_SetTransform(lpD3D9Device, D3DTS_WORLD, &m_matWorld);
+
+    IDirect3DDevice9_DrawPrimitive(lpD3D9Device, D3DPT_TRIANGLELIST, 0, m_iNumPolygons);
+
+    IDirect3DDevice9_EndScene(lpD3D9Device);
+    
+    IDirect3DDevice9_Present(lpD3D9Device, NULL,  NULL, NULL, NULL);
+    printf("A light blue 'sqaure' on a darkblue background in the center of the window filling half the window\n");
+    getchar();
+    IDirect3DDevice9_Clear(lpD3D9Device, 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(30,0,30), 1.0f, 0);
+    IDirect3DDevice9_Present(lpD3D9Device, NULL,  NULL, NULL, NULL);
+    printf("A purple filling the window\n");
+    getchar();
+
+
+    #if 0    
+        /* More stests */
+        /* Test all FVF's and custom formats   */
+        /* Test colour blending operations   */
+        /* Test render targets   */
+        /* Textures   */
+        /* Materials */
+        /* Transforms */
+        /* Cube Textures   */
+        /* Volume Textures   */
+        /* Locking */
+        /* n powe of two */
+        /* viewports */        
+    #endif
+    
+    IDirect3DDevice9_SetStreamSource(lpD3D9Device, 0, NULL, 0, sizeof(MY_CUSTOM_VERTEX));
+
+    return TRUE;
+
+    
+    getchar();
+}
+static void releasedirectdraw()
+{
+    if( lpD3D9Device != NULL){
+        IDirect3DDevice9_Release(lpD3D9Device);
+    }
+	if( lpD3D9 != NULL )
+	{
+		IDirect3D9_Release(lpD3D9);
+		lpD3D9 = NULL;
+	}
+}
+
+
+#if 0
+D3DXMATRIX* D3DXMatrixIdentity   ( D3DXMATRIX *pOut ){
+
+   pOut->_11 = 1;
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+
+   pOut->_21 = 0;
+   pOut->_22 = 1;
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 1;
+   pOut->_33 = 0;
+   pOut->_34 = 0;
+
+   pOut->_41 = 0;
+   pOut->_42 = 0;
+   pOut->_43 = 0;
+   pOut->_44 = 1;
+
+   return pOut;
+}
+
+#endif
+D3DXVECTOR3 D3DXVector3(float x, float y, float z){
+  D3DXVECTOR3 This;
+  This.x = x;
+  This.y = y;
+  This.z = z;
+  return This;
+}
+
+
+
+#if 0
+static void adddisplaymode(LPDDSURFACEDESC lpddsd)
+{
+    if (!modes) 
+	modes = malloc((modes_size = 2) * sizeof(DDSURFACEDESC));
+    if (modes_cnt == modes_size) 
+	    modes = realloc(modes, (modes_size *= 2) * sizeof(DDSURFACEDESC));
+    assert(modes);
+    modes[modes_cnt++] = *lpddsd;
+}
+
+static void flushdisplaymodes()
+{
+    free(modes);
+    modes = 0;
+    modes_cnt = modes_size = 0;
+}
+
+HRESULT WINAPI enummodescallback(LPDDSURFACEDESC lpddsd, LPVOID lpContext)
+{
+    trace("Width = %li, Height = %li, Refresh Rate = %li\r\n",
+        lpddsd->dwWidth, lpddsd->dwHeight,
+        lpddsd->UNION_MEMBER(2, dwRefreshRate));
+    adddisplaymode(lpddsd);
+
+    return DDENUMRET_OK;
+}
+
+void enumdisplaymodes()
+{
+    DDSURFACEDESC ddsd;
+    HRESULT rc;
+
+    ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));
+    ddsd.dwSize = sizeof(DDSURFACEDESC);
+    ddsd.dwFlags = DDSD_CAPS;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+
+    rc = IDirectDraw_EnumDisplayModes(lpDD,
+        DDEDM_STANDARDVGAMODES, &ddsd, 0, enummodescallback);
+    ok(rc==DD_OK,"EnumDisplayModes returned: %lx\n",rc);
+}
+
+static void setdisplaymode(int i)
+{
+    HRESULT rc;
+
+    rc = IDirectDraw_SetCooperativeLevel(lpDD,
+        hwnd, DDSCL_ALLOWMODEX | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(rc==DD_OK,"SetCooperativeLevel returned: %lx\n",rc);
+    if (modes[i].dwFlags & DDSD_PIXELFORMAT)
+    {
+        if (modes[i].ddpfPixelFormat.dwFlags & DDPF_RGB)
+        {
+            rc = IDirectDraw_SetDisplayMode(lpDD,
+                modes[i].dwWidth, modes[i].dwHeight,
+                modes[i].ddpfPixelFormat.UNION_MEMBER(1, dwRGBBitCount));
+            ok(rc==DD_OK,"SetDisplayMode returned: %lx\n",rc);
+            rc = IDirectDraw_RestoreDisplayMode(lpDD);
+            ok(rc==DD_OK,"RestoreDisplayMode returned: %lx\n",rc);
+            
+        }
+    }
+}
+
+static void createsurface()
+{
+    DDSURFACEDESC ddsd;
+    DDSCAPS ddscaps;
+    HRESULT rc;
+    
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE |
+        DDSCAPS_FLIP |
+        DDSCAPS_COMPLEX;
+    ddsd.dwBackBufferCount = 1;
+    rc = IDirectDraw_CreateSurface(lpDD, &ddsd, &lpDDSPrimary, NULL );
+    ok(rc==DD_OK,"CreateSurface returned: %lx\n",rc);
+    ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
+    rc = IDirectDrawSurface_GetAttachedSurface(lpDDSPrimary, &ddscaps, &lpDDSBack);
+    ok(rc==DD_OK,"GetAttachedSurface returned: %lx\n",rc);
+}
+
+static void destroysurface()
+{
+    if( lpDDSPrimary != NULL )
+    {
+        IDirectDrawSurface_Release(lpDDSPrimary);
+        lpDDSPrimary = NULL;
+    }
+}
+
+static void testsurface()
+{
+    const char* testMsg = "ddraw device context test";
+    HDC hdc;
+    HRESULT rc;
+    
+    rc = IDirectDrawSurface_GetDC(lpDDSBack, &hdc);
+    ok(rc==DD_OK, "IDirectDrawSurface_GetDC returned: %lx\n",rc);
+    SetBkColor(hdc, RGB(0, 0, 255));
+    SetTextColor(hdc, RGB(255, 255, 0));
+    TextOut(hdc, 0, 0, testMsg, lstrlen(testMsg));
+    IDirectDrawSurface_ReleaseDC(lpDDSBack, hdc);
+    ok(rc==DD_OK, "IDirectDrawSurface_ReleaseDC returned: %lx\n",rc);
+    
+    while (1)
+    {
+        rc = IDirectDrawSurface_Flip(lpDDSPrimary, NULL, DDFLIP_WAIT);
+        ok(rc==DD_OK || rc==DDERR_SURFACELOST, "IDirectDrawSurface_BltFast returned: %lx\n",rc);
+
+        if (rc == DD_OK)
+        {
+            break;
+        }
+        else if (rc == DDERR_SURFACELOST)
+        {
+            rc = IDirectDrawSurface_Restore(lpDDSPrimary);
+            ok(rc==DD_OK, "IDirectDrawSurface_Restore returned: %lx\n",rc);
+        }
+    }
+}
+
+static void testdisplaymodes()
+{
+    int i;
+
+    for (i = 0; i < modes_cnt; ++i)
+    {
+        setdisplaymode(i);
+        createsurface();
+        testsurface();
+        destroysurface();
+    }
+}
+#endif
+
+START_TEST(d3d9tests)
+{
+    createdirectdraw();
+    #if 0
+    enumdisplaymodes();
+    testdisplaymodes();
+    flushdisplaymodes();
+    #endif
+    setupDevice();
+    getchar();
+    drawSomething();
+    getchar();
+    releasedirectdraw();
+}
+
+
+
+#if 0
+
+/* **************************************************************
+*   DirectX 9 Test suite for Wine
+*   Copyright 
+*   2005       Oliver Stieber
+*
+*
+*
+*
+*
+*
+*
+*
+*
+*   Features:
+*
+*   
+*   When something on the todo list is compleate move it to the features list
+*   TODO:
+*   Device Creation
+*   Device Capabilities (manual checking required?)
+*   Creating surfaces
+*   Surface locking
+*   Creating textures
+*   Texture locking
+*   Clear
+*   Present
+*   Reset
+*
+**************************************************************** */
+
+/*Basic RGBA additive colours and alpha as bitwise definitions*/
+
+#DEFINE RED      (1 << 0)
+#DEFINE GREEN    (1 << 1)
+#DEFINE BLUE     (1 << 2)
+#DEFINE ALPHA    (1 << 3)
+#DEFINE YELLOW   (RED   | GREEN)
+#DEFINE CYAN     (GREEN | BLUE)
+#DEFINE MAGENTA  (RED   | BLUE)
+#DEFINE BLACK     0
+#DEFINE WHITE    (RED | GREEN | BLUE)
+
+/*ARGB Definitiona*/
+#DEFINE ARGB_RED     (1 << 1)
+#DEFINE ARGB_GREEN   (1 << 2)
+#DEFINE ARGB_BLUE    (1 << 3)
+#DEFINE ARGB_ALPHA   (1 << 0)
+
+
+#DEFINE YELLOW   (ARGB_RED   | ARGB_GREEN)
+#DEFINE CYAN     (ARGB_GREEN | ARGB_BLUE)
+#DEFINE MAGENTA  (ARGB_RED   | ARGB_BLUE)
+#DEFINE BLACK     0
+#DEFINE WHITE    (ARGB_RED | ARGB_GREEN | ARGB_BLUE)
+
+/*Basic definiations for diffent colour formats*/
+#DEFINE MAKE_R8G8B8A8(r, g, b, a) ( r | (g << 8)  | (b << 16) | (a << 24))
+#DEFINE MAKE_R4G4B4A4(r, g, b, a) ( r | (g << 4)  | (b << 8)  | (a << 16))
+
+
+#DEFINE MAKE_A8R8G8B8(a, r, g, b) ( a | (r << 8) | ( g << 16) | (b << 24))
+
+#DEFINE MAKE_R8G8B8(r, g, b) MAKE_R8G8B8A8(r, g, b, 0) /*This may not be correct?*/
+#DEFINE MAKE_R8G8B8X8(r, g, b)  MAKE_R8G8B8(r, g, b
+
+/*Macros to go from 1bit to many bits
+
+
+*/
+
+#DEFINE RED_BIT(c)   ((c & 1) )
+#DEFINE GREEN_BIT(c) ((c & 2) >> 1)
+#DEFINE BLUE_BIT(c)  ((c & 4) >> 2)
+#DEFINE ALPHA_BIT(c) ((c & 8) >> 3)
+
+#DEFINE CONVERT_TO_8(v) (v | (v << 1) | (v << 2) | (v << 3) | (v << 4) | (v << 5) | (v << 6) | (v << 7))
+#DEFINE CONVERT_TO_4(v) (v | (v << 1) | (v << 2) | (v << 3))
+
+#DEFINE BITCOLOUR_TO_RGBA8(c) ( MAKE_R8G8B8A8(CONVERT_TO_8(RED_BIT(c))
+                                        ,CONVERT_TO_8(GREEN_BIT(c))
+                                        ,CONVERT_TO_8(BLUE_BIT(c)
+                                        ,CONVERT_TO_8(ALPHA_BIT(c)))
+                                        
+#DEFINE BITCOLOUR_TO_RGBA4(c) ( MAKE_R4G4B4A4(CONVERT_TO_4(RED_BIT(c))
+                                        ,CONVERT_TO_4(GREEN_BIT(c))
+                                        ,CONVERT_TO_4(BLUE_BIT(c)
+                                        ,CONVERT_TO_4(ALPHA_BIT(c)))
+
+
+typdef enum TEXTURESTYPES {
+    PASS
+    FAIL
+    PASSCHECK
+    FAILCHECK
+    PASSCHECKALPHA
+    FAILCHECKALPHA    
+} TEXTURESTYPES;
+
+MAX_TEXTURE_TYPES=FAILCHECKALPHA +1;
+
+int * checkpatterns[MAX_TEXTURE_TYPES];
+int * checkpatterns[PASS] = { 1, GREEN };
+int * checkpatterns[FAIL] = { 1, RED };
+int * checkpatterns[PASSCHECK] = { 2, GREEN, BLACK 
+                                    , BLACK, GREEN};
+int * checkpatterns[FAILCHECK] = { 2, RED, BLACK 
+                                    , BLACK, RED};
+                                    
+int * checkpatterns[PASSCHECKALPHA] = { 2, BLACK , RED 
+                                           GREEN ,BLACK}
+int * checkpatterns[FAILCHECKALPHA] = { 2, BLACK       , GREEN 
+                                         , RED | ALPHA , RED | ALPHA};
+                                    
+
+
+/*
+make a basic texture using one of the check patterns
+*/
+void * CreateTexture(TEXTURESTYPES type, int width, int height, int format){
+
+    if(height != width){
+        /*fail, nopow2 textures arn't supported at the moment*/
+        return NULL;
+    }
+    int width;    
+    int checkWidth = width / 2;
+    
+    if( type < 0 || type >= MAX_TEXTURE_TYPES ){
+        /*fail out of range*/
+        return NULL;
+    }
+    int bpp = 32;
+    
+    void * result = HeapAlloc(GetProcessHeap(), 0 , width * height * (bpp >> 3));
+    
+    int* pattern = checkPatterns[type];
+    
+    int checks = width >> 4; /*make each check 16x16*/
+    /*should adjust by the pattern width or something*/
+    if(checks >= 0 ){
+        checks = 2;
+    }
+    
+    if(pattern[0] == 1){
+        checks = 1;
+    }
+    
+    int checkwidth = width/checks;
+    char* data = result;
+    
+    for(y = 0 ; y < height; y ++){
+        for(u = 0 ; u < checks; u ++){
+            colour = BITCOLOUR_TO_RGBA8(pattern[(u % pattern[0]) + (y / checkwidth) % pattern[0]) * pattern[0]]);
+            for(x = 0; x < checkwidth; x++){
+                (*data++)=colour;
+            }
+        }
+    }
+    
+    return result;    
+}
+
+typedef struct Parameter {
+    union {
+        int intV;
+        float floatV;
+        void* pV;
+    } value;
+    char* name;
+} Parameter;
+
+void * jobs;
+
+run(TEST_CASES test){
+/*The test is just going to consist of a lot of functions to run in order that return pass or fail*/
+/*We need to do some setting up of parametes*/
+    for(i = 0 ; i < totaljobs; i++){
+        if(jobs[i](parameters)  == FAIL){
+            return FAIL;
+        }
+    }
+
+
+}
+
+int createWindowInThread(Parameter* parameters){
+    /*Create a window with it's event loop in a seperate thread (this allows for the runction to return, leaving the window intact)*/
+    setIParameter(parameters,"HWND", hwnd);
+    
+}
+
+int initilize(Parameter * parameters){
+    return PASS;
+}
+
+
+void setIParameter(Parameter* parameters, char* parametername, int value){
+    /*if the parameter doesn't exist create it*/
+}
+
+void setFParameter(Parameter* parameters, char* parametername, float value){
+    /*if the parameter doesn't exist create it*/
+}
+
+void createIParameter(Parameter* parameters, char* parametername, int value){
+
+}
+void createFParameter(Pa
+
+#endif
diff -urN wine.20050419/dlls/d3d9/texture.c wine.20050419.dx9/dlls/d3d9/texture.c
--- wine.20050419/dlls/d3d9/texture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/texture.c	2005-04-20 01:52:56.000000000 -0600
@@ -212,7 +212,6 @@
     IDirect3DTexture9Impl_AddDirtyRect
 };
 
-
 /* IDirect3DDevice9 IDirect3DTexture9 Methods follow: */
 HRESULT  WINAPI  IDirect3DDevice9Impl_CreateTexture(LPDIRECT3DDEVICE9 iface, UINT Width, UINT Height, UINT Levels, DWORD Usage,
                                                     D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle) {
diff -urN wine.20050419/dlls/d3d9/vertexdeclaration.c wine.20050419.dx9/dlls/d3d9/vertexdeclaration.c
--- wine.20050419/dlls/d3d9/vertexdeclaration.c	2005-03-02 05:16:11.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/vertexdeclaration.c	2005-04-20 01:52:56.000000000 -0600
@@ -22,7 +22,7 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
 /* IDirect3DVertexDeclaration9 IUnknown parts follow: */
 HRESULT WINAPI IDirect3DVertexDeclaration9Impl_QueryInterface(LPDIRECT3DVERTEXDECLARATION9 iface, REFIID riid, LPVOID* ppobj) {
@@ -30,7 +30,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DVertexDeclaration9)) {
-        IDirect3DVertexDeclaration9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -124,13 +124,8 @@
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
     IDirect3DVertexDeclaration9Impl *pDeclImpl = (IDirect3DVertexDeclaration9Impl *)pDecl;
     HRESULT hr = S_OK;
-
-    This->UpdateStateBlock->vertexDecl = NULL;
     if (NULL != pDecl) {
       hr = IWineD3DDevice_SetVertexDeclaration(This->WineD3DDevice, pDeclImpl->wineD3DVertexDeclaration);
-      if (SUCCEEDED(hr)) {
-	This->UpdateStateBlock->vertexDecl = (IDirect3DVertexDeclaration9Impl*) pDecl;
-      }
     }
     return hr;
 }
@@ -139,15 +134,19 @@
     IDirect3DDevice9Impl* This = (IDirect3DDevice9Impl*) iface;
     IWineD3DVertexDeclaration* pTest = NULL;
     HRESULT hr = S_OK;
-    IDirect3DVertexDeclaration9Impl* pCur = This->StateBlock->vertexDecl;
 
     if (NULL == ppDecl) {
       return D3DERR_INVALIDCALL;
     }
     *ppDecl = NULL;
     hr = IWineD3DDevice_GetVertexDeclaration(This->WineD3DDevice, &pTest);
-    if (SUCCEEDED(hr) && (NULL == pCur || pCur->wineD3DVertexDeclaration == pTest)) {
-      *ppDecl = (IDirect3DVertexDeclaration9*) pCur;
+    if(NULL != pTest){
+        IWineD3DResource_GetParent(pTest, (IUnknown **)ppDecl);
+        IWineD3DResource_Release(pTest);
+    }else{
+        *ppDecl = (IDirect3DVertexDeclaration9*)NULL;
     }
+    
+    TRACE("(%p) : returning %p\n", This, *ppDecl);
     return hr;
 }
diff -urN wine.20050419/dlls/d3d9/vertexshader.c wine.20050419.dx9/dlls/d3d9/vertexshader.c
--- wine.20050419/dlls/d3d9/vertexshader.c	2005-01-24 05:44:01.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/vertexshader.c	2005-04-20 01:52:56.000000000 -0600
@@ -22,7 +22,7 @@
 #include "config.h"
 #include "d3d9_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d_shader);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9);
 
 /* IDirect3DVertexShader9 IUnknown parts follow: */
 HRESULT WINAPI IDirect3DVertexShader9Impl_QueryInterface(LPDIRECT3DVERTEXSHADER9 iface, REFIID riid, LPVOID* ppobj) {
@@ -30,7 +30,7 @@
 
     if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IDirect3DVertexShader9)) {
-        IDirect3DVertexShader9Impl_AddRef(iface);
+        IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
@@ -55,7 +55,9 @@
     TRACE("(%p) : ReleaseRef to %ld\n", This, ref);
 
     if (ref == 0) {
+        IWineD3DVertexShader_Release(This->wineD3DVertexShader);
         HeapFree(GetProcessHeap(), 0, This);
+        
     }
     return ref;
 }
@@ -63,16 +65,22 @@
 /* IDirect3DVertexShader9 Interface follow: */
 HRESULT WINAPI IDirect3DVertexShader9Impl_GetDevice(LPDIRECT3DVERTEXSHADER9 iface, IDirect3DDevice9** ppDevice) {
     IDirect3DVertexShader9Impl *This = (IDirect3DVertexShader9Impl *)iface;
-    TRACE("(%p) : returning %p\n", This, This->Device);
-    *ppDevice = (LPDIRECT3DDEVICE9) This->Device;
-    IDirect3DDevice9Impl_AddRef(*ppDevice);
+    IWineD3DDevice *myDevice = NULL;
+    
+    TRACE("(%p) : Relay\n", This);
+
+    IWineD3DVertexShader_GetDevice(This->wineD3DVertexShader, &myDevice);
+    IWineD3DDevice_GetParent(myDevice, (IUnknown **)ppDevice);
+    IWineD3DDevice_Release(myDevice);
+    TRACE("(%p) returing (%p)", This, *ppDevice);
     return D3D_OK;
 }
 
 HRESULT WINAPI IDirect3DVertexShader9Impl_GetFunction(LPDIRECT3DVERTEXSHADER9 iface, VOID* pData, UINT* pSizeOfData) {
     IDirect3DVertexShader9Impl *This = (IDirect3DVertexShader9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DVertexShader_GetFunction(This->wineD3DVertexShader, pData, pSizeOfData);
 }
 
 
@@ -89,148 +97,92 @@
 /* IDirect3DDevice9 IDirect3DVertexShader9 Methods follow: */
 HRESULT WINAPI IDirect3DDevice9Impl_CreateVertexShader(LPDIRECT3DDEVICE9 iface, CONST DWORD* pFunction, IDirect3DVertexShader9** ppShader) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
+    HRESULT hrc = D3D_OK;
+    IDirect3DVertexShader9Impl *object;
+    
+    FIXME("(%p) : Relay (disabled) \n", This);
+    *ppShader = NULL;
     return D3D_OK;
+    /* Setup a stub object for now */
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+    TRACE("(%p) : pFunction(%p), ppShader(%p)\n", This, pFunction, ppShader);
+    if (NULL == object) {
+        FIXME("Allocation of memory failed\n");
+        *ppShader = NULL;
+        return D3DERR_OUTOFVIDEOMEMORY;
+    }
+
+    object->ref = 1;
+    object->lpVtbl = &Direct3DVertexShader9_Vtbl;
+    hrc= IWineD3DDevice_CreateVertexShader(This->WineD3DDevice, pFunction, &object->wineD3DVertexShader, (IUnknown *)object);
+
+    if (FAILED(hrc)) {
+        /* free up object */
+        FIXME("Call to IWineD3DDevice_CreateVertexShader failed\n");
+        HeapFree(GetProcessHeap(), 0, object);
+        *ppShader = NULL;
+    }else{
+        *ppShader = (IDirect3DVertexShader9 *)object;
+    }
+
+    TRACE("(%p) : returning %p\n", This, *ppShader);
+    return hrc;
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetVertexShader(LPDIRECT3DDEVICE9 iface, IDirect3DVertexShader9* pShader) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-    This->UpdateStateBlock->VertexShader = pShader;
-    This->UpdateStateBlock->Changed.vertexShader = TRUE;
-    This->UpdateStateBlock->Set.vertexShader = TRUE;
-    
-    /* Handle recording of state blocks */
-    if (This->isRecordingState) {
-      TRACE("Recording... not performing anything\n");
-      return D3D_OK;
-    }
-    /**
-     * TODO: merge HAL shaders context switching from prototype
-     */
+    TRACE("(%p) : Relay (disabled) \n", This);
     return D3D_OK;
+    return IWineD3DDevice_SetVertexShader(This->WineD3DDevice, pShader==NULL?NULL:((IDirect3DVertexShader9Impl *)pShader)->wineD3DVertexShader);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetVertexShader(LPDIRECT3DDEVICE9 iface, IDirect3DVertexShader9** ppShader) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    TRACE("(%p) : GetVertexShader returning %p\n", This, This->StateBlock->VertexShader);
-    *ppShader = This->StateBlock->VertexShader;
-    IDirect3DVertexShader9Impl_AddRef(*ppShader);
-    return D3D_OK;
+    IWineD3DVertexShader *pShader;
+    HRESULT hrc = D3D_OK;
+    hrc = IWineD3DDevice_GetVertexShader(This->WineD3DDevice, &pShader);
+    if(hrc == D3D_OK){
+       hrc = IWineD3DVertexShader_GetParent(pShader, (IUnknown **)ppShader);
+       IWineD3DVertexShader_Release(pShader);       
+    }    
+    TRACE("(%p) : returning %p\n", This, *ppShader);
+    return hrc;
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetVertexShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT Register, CONST float* pConstantData, UINT Vector4fCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  if (Register + Vector4fCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetVertexShaderConstant C[%u] invalid\n", This, Register);
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (Vector4fCount > 1) {
-    CONST FLOAT* f = pConstantData;
-    UINT i;
-    TRACE("(%p) : SetVertexShaderConstant C[%u..%u]=\n", This, Register, Register + Vector4fCount - 1);
-    for (i = 0; i < Vector4fCount; ++i) {
-      TRACE("{%f, %f, %f, %f}\n", f[0], f[1], f[2], f[3]);
-      f += 4;
-    }
-  } else { 
-    const FLOAT* f = (const FLOAT*) pConstantData;
-    TRACE("(%p) : SetVertexShaderConstant, C[%u]={%f, %f, %f, %f}\n", This, Register, f[0], f[1], f[2], f[3]);
-  }
-  This->UpdateStateBlock->Changed.vertexShaderConstant = TRUE;
-  memcpy(&This->UpdateStateBlock->vertexShaderConstantF[Register], pConstantData, Vector4fCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_SetVertexShaderConstantF(This->WineD3DDevice, Register, pConstantData, Vector4fCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetVertexShaderConstantF(LPDIRECT3DDEVICE9 iface, UINT Register, float* pConstantData, UINT Vector4fCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  TRACE("(%p) : C[%u] count=%u\n", This, Register, Vector4fCount);
-  if (Register + Vector4fCount > D3D_VSHADER_MAX_CONSTANTS) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  memcpy(pConstantData, &This->UpdateStateBlock->vertexShaderConstantF[Register], Vector4fCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_GetVertexShaderConstantF(This->WineD3DDevice, Register, pConstantData, Vector4fCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetVertexShaderConstantI(LPDIRECT3DDEVICE9 iface, UINT Register, CONST int* pConstantData, UINT Vector4iCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-
-  if (Register + Vector4iCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetVertexShaderConstantI C[%u] invalid\n", This, Register);
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (Vector4iCount > 1) {
-    CONST int* f = pConstantData;
-    UINT i;
-    TRACE("(%p) : SetVertexShaderConstantI C[%u..%u]=\n", This, Register, Register + Vector4iCount - 1);
-    for (i = 0; i < Vector4iCount; ++i) {
-      TRACE("{%d, %d, %d, %d}\n", f[0], f[1], f[2], f[3]);
-      f += 4;
-    }
-  } else { 
-    CONST int* f = pConstantData;
-    TRACE("(%p) : SetVertexShaderConstantI, C[%u]={%i, %i, %i, %i}\n", This, Register, f[0], f[1], f[2], f[3]);
-  }
-  This->UpdateStateBlock->Changed.vertexShaderConstant = TRUE;
-  memcpy(&This->UpdateStateBlock->vertexShaderConstantI[Register], pConstantData, Vector4iCount * 4 * sizeof(int));
-  return D3D_OK;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_SetVertexShaderConstantI(This->WineD3DDevice, Register, pConstantData, Vector4iCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetVertexShaderConstantI(LPDIRECT3DDEVICE9 iface, UINT Register, int* pConstantData, UINT Vector4iCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_GetVertexShaderConstantI(This->WineD3DDevice, Register, pConstantData, Vector4iCount);
 
-  TRACE("(%p) : C[%u] count=%u\n", This, Register, Vector4iCount);
-  if (Register + Vector4iCount > D3D_VSHADER_MAX_CONSTANTS) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  memcpy(pConstantData, &This->UpdateStateBlock->vertexShaderConstantI[Register], Vector4iCount * 4 * sizeof(FLOAT));
-  return D3D_OK;
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_SetVertexShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT Register, CONST BOOL* pConstantData, UINT BoolCount) {
   IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-  UINT i;
-
-  if (Register + BoolCount > D3D_VSHADER_MAX_CONSTANTS) {
-    ERR("(%p) : SetVertexShaderConstantB C[%u] invalid\n", This, Register);
-    return D3DERR_INVALIDCALL;
-  }
-  if (NULL == pConstantData) {
-    return D3DERR_INVALIDCALL;
-  }
-  if (BoolCount > 1) {
-    CONST BOOL* f = pConstantData;
-    TRACE("(%p) : SetVertexShaderConstantB C[%u..%u]=\n", This, Register, Register + BoolCount - 1);
-    for (i = 0; i < BoolCount; ++i) {
-      TRACE("{%u}\n", f[i]);
-    }
-  } else { 
-    CONST BOOL* f = pConstantData;
-    TRACE("(%p) : SetVertexShaderConstantB, C[%u]={%u}\n", This, Register, f[0]);
-  }
-  This->UpdateStateBlock->Changed.vertexShaderConstant = TRUE;
-  for (i = 0; i < BoolCount; ++i) {
-    This->UpdateStateBlock->vertexShaderConstantB[Register] = pConstantData[i];
-  }
-  return D3D_OK;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_SetVertexShaderConstantB(This->WineD3DDevice, Register, pConstantData, BoolCount);
 }
 
 HRESULT WINAPI IDirect3DDevice9Impl_GetVertexShaderConstantB(LPDIRECT3DDEVICE9 iface, UINT Register, BOOL* pConstantData, UINT BoolCount) {
     IDirect3DDevice9Impl *This = (IDirect3DDevice9Impl *)iface;
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    TRACE("(%p) : Relay\n", This);
+    return IWineD3DDevice_GetVertexShaderConstantB(This->WineD3DDevice, Register, pConstantData, BoolCount);
+
 }
diff -urN wine.20050419/dlls/d3d9/volume.c wine.20050419.dx9/dlls/d3d9/volume.c
--- wine.20050419/dlls/d3d9/volume.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/volume.c	2005-04-20 01:52:56.000000000 -0600
@@ -114,6 +114,8 @@
 
     TRACE("(%p) Relay\n", This);
 
+    TRACE("(%p) Relay\n", This); 
+
     /* As d3d8 and d3d9 structures differ, pass in ptrs to where data needs to go */
     wined3ddesc.Format              = &pDesc->Format;
     wined3ddesc.Type                = &pDesc->Type;
@@ -155,6 +157,7 @@
 };
 
 
+
 /* Internal function called back during the CreateVolumeTexture */
 HRESULT WINAPI D3D9CB_CreateVolume(IUnknown  *pDevice, UINT Width, UINT Height, UINT Depth, 
                                    WINED3DFORMAT  Format, D3DPOOL Pool, DWORD Usage,
diff -urN wine.20050419/dlls/d3d9/volumetexture.c wine.20050419.dx9/dlls/d3d9/volumetexture.c
--- wine.20050419/dlls/d3d9/volumetexture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3d9/volumetexture.c	2005-04-20 01:52:56.000000000 -0600
@@ -157,6 +157,8 @@
 
     TRACE("(%p) Relay\n", This);
 
+    TRACE("(%p) Relay\n", This); 
+
     /* As d3d8 and d3d9 structures differ, pass in ptrs to where data needs to go */
     wined3ddesc.Format              = &pDesc->Format;
     wined3ddesc.Type                = &pDesc->Type;
@@ -243,6 +245,8 @@
 
     TRACE("(%p) Relay\n", This);
 
+    TRACE("(%p) Relay\n", This); 
+
     /* Allocate the storage for the device */
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirect3DVolumeTexture9Impl));
     if (NULL == object) {
diff -urN wine.20050419/dlls/d3dx9/.cvsignore wine.20050419.dx9/dlls/d3dx9/.cvsignore
--- wine.20050419/dlls/d3dx9/.cvsignore	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/.cvsignore	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,3 @@
+Makefile
+d3dx8.dll.dbg.c
+d3dx8.spec.def
diff -urN wine.20050419/dlls/d3dx9/Makefile.in wine.20050419.dx9/dlls/d3dx9/Makefile.in
--- wine.20050419/dlls/d3dx9/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/Makefile.in	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,17 @@
+TOPSRCDIR = @top_srcdir@
+TOPOBJDIR = ../..
+SRCDIR    = @srcdir@
+VPATH     = @srcdir@
+MODULE    = d3dx9.dll
+IMPORTS   = d3d9 user32 gdi32 kernel32
+EXTRAINCL = @X_CFLAGS@
+EXTRALIBS = -ldxguid -luuid @X_LIBS@ @X_PRE_LIBS@ @XLIB@ @X_EXTRA_LIBS@ @OPENGL_LIBS@
+
+C_SRCS = \
+	d3dx9_main.c \
+	d3dxbuffer.c \
+	font.c
+
+@MAKE_DLL_RULES@
+
+### Dependencies:
diff -urN wine.20050419/dlls/d3dx9/d3dx9.spec wine.20050419.dx9/dlls/d3dx9/d3dx9.spec
--- wine.20050419/dlls/d3dx9/d3dx9.spec	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/d3dx9.spec	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,60 @@
+@ stdcall D3DXCreateBuffer(long ptr)
+@ stdcall D3DXCreateFontA(ptr long long long long long long long long long ptr ptr)
+@ stdcall D3DXGetFVFVertexSize(long)
+@ stdcall D3DXAssembleShader(ptr long long ptr ptr ptr)
+@ stdcall D3DXAssembleShaderFromFileA(ptr long ptr ptr ptr)
+@ stdcall D3DXAssembleShaderFromFileW(ptr long ptr ptr ptr)
+@ stdcall D3DXCreateTextureFromFile(ptr ptr ptr)
+@ stdcall D3DXMatrixPerspectiveFovLH(ptr double double double double)
+@ stdcall D3DXVec4Add(ptr ptr ptr)
+@ stdcall D3DXVec3Add(ptr ptr ptr)
+@ stdcall D3DXVec2Add(ptr ptr ptr)
+@ stdcall D3DXVec4Subtract(ptr ptr ptr)
+@ stdcall D3DXVec3Subtract(ptr ptr ptr)
+@ stdcall D3DXVec2Subtract(ptr ptr ptr)
+@ stdcall D3DXVec2Dot(ptr ptr)
+@ stdcall D3DXVec3Dot(ptr ptr)
+@ stdcall D3DXVec4Dot(ptr ptr)
+@ stdcall D3DXVec4Cross(ptr ptr ptr ptr)
+@ stdcall D3DXVec3Cross(ptr ptr ptr)
+@ stdcall D3DXVec4Scale(ptr ptr double)
+@ stdcall D3DXVec3Scale(ptr ptr double)
+@ stdcall D3DXVec2Scale(ptr ptr double)
+@ stdcall D3DXVec2LengthSq(ptr)
+@ stdcall D3DXVec2Length(ptr)
+@ stdcall D3DXVec3LengthSq(ptr)
+@ stdcall D3DXVec3Length(ptr)
+@ stdcall D3DXVec4LengthSq(ptr)
+@ stdcall D3DXVec4Length(ptr)
+@ stdcall D3DXVec3Normalize(ptr ptr)
+@ stdcall D3DXMatrixTranslation(ptr double double double)
+@ stdcall D3DXMatrixDeterminant(ptr)
+@ stdcall D3DXMatrixInverse(ptr ptr ptr)
+@ stdcall D3DXMatrixRotationYawPitchRoll(ptr double double double)
+@ stdcall D3DXMatrixRotationQuaternion(ptr ptr)
+@ stdcall D3DXMatrixRotationAxis(ptr ptr double)
+@ stdcall D3DXMatrixReflect(ptr ptr)
+@ stdcall D3DXMatrixDecompose(ptr ptr ptr ptr)
+@ stdcall D3DXMatrixLookAtRH(ptr ptr ptr ptr)
+@ stdcall D3DXMatrixLookAtLH(ptr ptr ptr ptr)
+@ stdcall D3DXFloat32To16Array(ptr ptr long)
+@ stdcall D3DXFloat16To32Array(ptr ptr long)
+@ stdcall D3DXColorSubtract(ptr ptr ptr)
+@ stdcall D3DXColorScale(ptr ptr double)
+@ stdcall D3DXColorNegative(ptr ptr)
+@ stdcall D3DXColorModulate(ptr ptr ptr)
+@ stdcall D3DXColorLerp(ptr ptr ptr double)
+@ stdcall D3DXColorAdjustSaturation(ptr ptr double)
+@ stdcall D3DXColorAdjustContrast(ptr ptr double)
+@ stdcall D3DXColorAdd(ptr ptr ptr)
+@ stdcall D3DXPlaneNormalize(ptr ptr)
+@ stdcall D3DXPlaneScale(ptr ptr double)
+@ stdcall D3DXPlaneLength(ptr)
+@ stdcall D3DXMatrixShadow(ptr ptr ptr)
+@ stdcall D3DXMatrixScaling(ptr double double double)
+@ stdcall D3DXMatrixRotationZ(ptr double)
+@ stdcall D3DXMatrixRotationY(ptr double)
+@ stdcall D3DXMatrixRotationX(ptr double)
+@ stdcall D3DXMatrixMultiply(ptr ptr ptr)
+@ stdcall D3DXMatrixOrthoLH(ptr double double double double)
+@ stdcall D3DXMatrixOrthoRH(ptr double double double double)
\ No newline at end of file
diff -urN wine.20050419/dlls/d3dx9/d3dx9_main.c wine.20050419.dx9/dlls/d3dx9/d3dx9_main.c
--- wine.20050419/dlls/d3dx9/d3dx9_main.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/d3dx9_main.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,1861 @@
+/*
+ * Direct3D X 9 main file
+ *
+ * Copyright (C) 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "wine/debug.h"
+#include <d3d9.h>
+#include <d3dx9.h>
+#include "d3dx9core_private.h"
+#include <d3dx9math.h>
+
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+typedef enum _predefinedtextures {
+WINE_PDT_DEFAULT = 0,
+WINE_PDT_CROSS,
+CHECK_COMPLEX,
+CHECK_BIG,
+WINE_PDT_NONE    = 0xffffff
+}predefinedtextures;
+
+HRESULT WINAPI D3DXCreateTextureFromFile(LPDIRECT3DDEVICE9 pDevice, LPSTR pSrcFile,  LPDIRECT3DTEXTURE9 *ppTexture){
+/**
+It may be a 'good' idea to give this function some 'magic' values for testing that load 
+predefiend textures
+Create a texture, this ones just going to be a x and not a 
+
+
+**/
+   int predfinedTexture = CHECK_BIG;
+  LPDIRECT3DSURFACE9 pSurface;
+
+  IDirect3DDevice9_CreateTexture(pDevice, 256,256,1,0,D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, ppTexture, NULL);
+  IDirect3DTexture9_GetSurfaceLevel(*ppTexture, 0, &pSurface);
+  
+  if((int)pSrcFile < 0){
+  predfinedTexture = -((int)pSrcFile);
+  }
+  /*Draw a multi coloured cross on the texture*/
+  switch (predfinedTexture){
+  /*could test colour rect here too*/
+  case WINE_PDT_NONE:
+  break;
+  case CHECK_BIG:
+  
+  {
+  /*This is a variation of a checkerboard using 4 bits (or 16 different check patterens)*/
+  /*I'm going to make the squares 8x8 so that the pattern repeats twice on the board, there should be 4 checks of each combination of RGBA*/
+    D3DLOCKED_RECT lockedRect;
+    int *data;
+    int u,v,x;
+
+    IDirect3DSurface9_LockRect(pSurface, &lockedRect, NULL, 0);  
+    data = (int*)(lockedRect.pBits);
+    for(u = 0; u < 256; u ++){    
+        for(v = 0; v < 8 ; v ++){
+            int check = (v  + (u  >> 5)) & 0x01; /*This is my check colour (1 bit per pixel!)*/ 
+            int colour = (check&1?255:0) | (check&1?255:0) << 8 | (check&1?255:0) << 16 | (check&1?255:0) << 24;    
+            /*I could do this in 8x8 blocks which may get mmx'ed and be nice and quick
+            the other option is to do a streight run
+            */      
+            for( x = 0 ; x < 32 ; x ++){
+                *data=colour;
+                data++;
+            }        
+        }
+    }
+  }  
+  IDirect3DSurface9_UnlockRect(pSurface);
+  
+  break;
+  
+  case CHECK_COMPLEX:
+  {
+  /*This is a variation of a checkerboard using 4 bits (or 16 different check patterens)*/
+  /*I'm going to make the squares 8x8 so that the pattern repeats twice on the board, there should be 4 checks of each combination of RGBA*/
+    D3DLOCKED_RECT lockedRect;
+    int *data;
+    int u,v,x;
+
+    IDirect3DSurface9_LockRect(pSurface, &lockedRect, NULL, 0);  
+    data = (int*)(lockedRect.pBits);
+    for(u = 0; u < 256; u ++){    
+        for(v = 0; v < 32 ; v ++){
+            int check = (v  + ((u  >> 4) << 2)) & 0x0F; /*This is my check colour (1 bit per pixel!)*/ 
+            int colour = (check&1?255:0) | (check&2?255:0) << 8 | (check&4?255:0) << 16 | (check&8?255:0) << 24;    
+            /*I could do this in 8x8 blocks which may get mmx'ed and be nice and quick
+            the other option is to do a streight run
+            */      
+            for( x = 0 ; x < 8 ; x ++){
+                *data=colour;
+                data++;
+            }        
+        }
+    }
+  }  
+  IDirect3DSurface9_UnlockRect(pSurface);
+  
+  break;
+  case WINE_PDT_CROSS:
+  default:
+  {
+    D3DLOCKED_RECT lockedRect;
+    int x;  
+    int *data;
+    int colour  =255 | 255 << 8 | 255 << 16 | 255 << 24;
+    int colourr =255 |  255 << 24;
+    int colourg = 255 << 8  | 255 << 24;
+    int colourb = 255 << 16 | 255 << 24;
+
+    IDirect3DSurface9_LockRect(pSurface, &lockedRect, NULL, 0);  
+    data = (int*)(lockedRect.pBits);
+    /*Draw an X on the texture*/
+    for(x =0;x<128;x++){
+      data[x + x*256] = colour;
+      data[255-x + x*256] = colourr;
+      data[x + (256*255)-x*256]  = colourg;
+      data[255-x + (256*255)-x*256] = colourb;
+    }  
+  IDirect3DSurface9_UnlockRect(pSurface);
+  }
+  }
+  return D3D_OK;
+}
+
+HRESULT WINAPI D3DXCreateBuffer(DWORD NumBytes, LPD3DXBUFFER* ppBuffer) {
+  ID3DXBufferImpl *object;
+
+  object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ID3DXBufferImpl));
+  if (NULL == object) {
+    *ppBuffer = (LPD3DXBUFFER)NULL;
+    return E_OUTOFMEMORY;
+  }
+  object->lpVtbl = &D3DXBuffer_Vtbl;
+  object->ref = 1;
+  object->bufferSize = NumBytes;
+  object->buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NumBytes);
+  if (NULL == object->buffer) {
+    HeapFree(GetProcessHeap(), 0, object);
+    *ppBuffer = (LPD3DXBUFFER)NULL;
+    return E_OUTOFMEMORY;
+  }
+  *ppBuffer = (LPD3DXBUFFER)object;
+  return D3D_OK;
+}
+
+HRESULT WINAPI D3DXCreateFont(LPDIRECT3DDEVICE9       pDevice,  
+        UINT                    Height,
+        UINT                    Width,
+        UINT                    Weight,
+        UINT                    MipLevels,
+        BOOL                    Italic,
+        DWORD                   CharSet,
+        DWORD                   OutputPrecision,
+        DWORD                   Quality,
+        DWORD                   PitchAndFamily,
+        LPCSTR                  pFaceName,
+        LPD3DXFONT*             ppFont) { 
+  ID3DXFontImpl* object;
+  FIXME("(void): stub\n");
+  object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ID3DXFontImpl));
+  object->lpVtbl = &D3DXFont_Vtbl;
+  object->ref = 1;  
+  object->device = pDevice;
+  return D3D_OK;
+}
+#if 0
+
+HRESULT WINAPI 
+    D3DXCreateFontA(
+        LPDIRECT3DDEVICE9       pDevice,  
+        UINT                    Height,
+        UINT                    Width,
+        UINT                    Weight,
+        UINT                    MipLevels,
+        BOOL                    Italic,
+        DWORD                   CharSet,
+        DWORD                   OutputPrecision,
+        DWORD                   Quality,
+        DWORD                   PitchAndFamily,
+        LPCSTR                  pFaceName,
+        LPD3DXFONT*             ppFont){
+	
+}{
+  ID3DXFontImpl* object;
+  object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ID3DXFontImpl));
+  object->lpVtbl = &D3DXFont_Vtbl;
+  object->ref = 1;
+  object->device = pDevice;
+  IDirect3DDevice9_AddRef(pDevice);
+  
+  *LPD3DXFONT = (LPD3DXFONT)object;
+  FIXME("(void): stub\n");
+  return D3D_OK;
+}
+
+HRESULT WINAPI 
+    D3DXCreateFontW(
+        LPDIRECT3DDEVICE9       pDevice,  
+        UINT                    Height,
+        UINT                    Width,
+        UINT                    Weight,
+        UINT                    MipLevels,
+        BOOL                    Italic,
+        DWORD                   CharSet,
+        DWORD                   OutputPrecision,
+        DWORD                   Quality,
+        DWORD                   PitchAndFamily,
+        LPSTR                   pFaceName,
+        LPD3DXFONT*             ppFont){
+  ID3DXFontImpl* object;
+  object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ID3DXFontImpl));
+  object->lpVtbl = &D3DXFont_Vtbl;
+  object->ref = 1;
+  *LPD3DXFONT = (LPD3DXFONT)object;
+  FIXME("(void): stub\n");
+  /*I need an WtoA function and then call the unicode version of this function.*/
+  return D3D_OK;
+	
+}
+#endif 
+
+
+
+UINT WINAPI D3DXGetFVFVertexSize(DWORD FVF) {
+  FIXME("(void): stub\n");
+  return 0;
+}
+
+HRESULT WINAPI D3DXAssembleShader(LPCVOID pSrcData, UINT SrcDataLen, DWORD Flags, 
+			   LPD3DXBUFFER* ppConstants, 
+			   LPD3DXBUFFER* ppCompiledShader,
+			   LPD3DXBUFFER* ppCompilationErrors) {
+  FIXME("(void): stub\n");
+  return D3D_OK;
+}
+
+HRESULT WINAPI D3DXAssembleShaderFromFileA(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors) {
+  FIXME("(void): stub\n");
+  return D3D_OK;
+}
+
+HRESULT WINAPI D3DXAssembleShaderFromFileW(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors) {
+  FIXME("(void): stub\n");
+  return D3D_OK;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixAffineTransformation(D3DXMATRIX *pOut,
+                                                  FLOAT Scaling,
+                                                  const D3DXVECTOR3 *pRotationCenter,
+                                                  const D3DXQUATERNION *pRotation,
+                                                  const D3DXVECTOR3 *pTranslation
+){
+/*
+This function calculates the affine transformation matrix with the following formula, with matrix concatenation evaluated in left-to-right order: 
+
+    pOut = Scaling * (pRotationCenter)^-1 * pRotation * pRotationCenter * pTranslation
+
+
+where:
+
+
+    pOut = output matrix (pOut)
+
+
+    Scaling = scaling matrix (Scaling)
+
+
+    pRotationCenter = center of rotation matrix (pRotationCenter)
+
+
+    pRotation = rotation matrix (pRotation)
+
+
+    pTranslation = translation matrix (pTranslation)
+
+*/
+  FIXME("(void): stub\n");
+  return pOut;
+}
+
+
+D3DXMATRIX *WINAPI D3DXMatrixAffineTransformation2D(      
+                                                      D3DXMATRIX *pOut,
+                                                      FLOAT Scaling,
+                                                      CONST D3DXVECTOR2 *pRotationCenter,
+                                                      FLOAT Rotation,
+                                                      CONST D3DXVECTOR2 *pTranslation
+){
+
+/*
+This function calculates the affine transformation matrix with the following formula, with matrix concatenation evaluated in left-to-right order: 
+
+    Mout = Ms * (Mrc)^-1 * Mr * Mrc * Mt
+
+
+where:
+
+
+    Mout = output matrix (pOut)
+
+
+    Ms = scaling matrix (Scaling)
+
+
+    Mrc = center of rotation matrix (pRotationCenter)
+
+
+    Mr = rotation matrix (Rotation)
+
+
+    Mt = translation matrix (pTranslation)
+    */
+
+  FIXME("(void): stub\n");
+  return pOut;
+}
+
+HRESULT WINAPI D3DXMatrixDecompose(      
+    D3DXVECTOR3 *pOutScale,
+    D3DXQUATERNION *pOutRotation,
+    D3DXVECTOR3 *pOutTranslation,
+    const D3DXMATRIX *pM
+){
+
+   FIXME("stub\n");
+   return  S_OK;
+}
+
+
+FLOAT WINAPI D3DXMatrixDeterminant(      
+    CONST D3DXMATRIX *pM
+){
+
+    return
+      pM->_14 * pM->_23 * pM->_32 * pM->_41-pM->_13 * pM->_24 * pM->_32 * pM->_41-pM->_14 * pM->_22 * pM->_33 * pM->_41+pM->_12 * pM->_24 * pM->_33 * pM->_41+
+      pM->_13 * pM->_22 * pM->_34 * pM->_41-pM->_12 * pM->_23 * pM->_34 * pM->_41-pM->_14 * pM->_23 * pM->_31 * pM->_42+pM->_13 * pM->_24 * pM->_31 * pM->_42+
+      pM->_14 * pM->_21 * pM->_33 * pM->_42-pM->_11 * pM->_24 * pM->_33 * pM->_42-pM->_13 * pM->_21 * pM->_34 * pM->_42+pM->_11 * pM->_23 * pM->_34 * pM->_42+
+      pM->_14 * pM->_22 * pM->_31 * pM->_43-pM->_12 * pM->_24 * pM->_31 * pM->_43-pM->_14 * pM->_21 * pM->_32 * pM->_43+pM->_11 * pM->_24 * pM->_32 * pM->_43+
+      pM->_12 * pM->_21 * pM->_34 * pM->_43-pM->_11 * pM->_22 * pM->_34 * pM->_43-pM->_13 * pM->_22 * pM->_31 * pM->_44+pM->_12 * pM->_23 * pM->_31 * pM->_44+
+      pM->_13 * pM->_21 * pM->_32 * pM->_44-pM->_11 * pM->_23 * pM->_32 * pM->_44-pM->_12 * pM->_21 * pM->_33 * pM->_44+pM->_11 * pM->_22 * pM->_33 * pM->_44;
+  
+}
+
+
+
+
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH(D3DXMATRIX *pOut,
+                                              FLOAT fovy,
+                                              FLOAT aspect,
+                                              FLOAT zn,
+                                              FLOAT zf){
+
+  FLOAT yscale;
+  FLOAT xscale;
+
+  
+  
+  yscale  =  1.0f/tan(fovy/2.0f);
+  
+
+  xscale   = aspect * yscale;
+
+  pOut->_11 = xscale;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+
+  pOut->_21 = 0;
+  pOut->_22 = yscale;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = zf/(zf-zn);
+  pOut->_34 = 1;
+
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = -zn*zf/(zf-zn);
+  pOut->_44 = 0;
+   
+  return pOut;
+   
+}  
+D3DXMATRIX *WINAPI D3DXMatrixPerspectiveFovRH(      
+    D3DXMATRIX *pOut,
+    FLOAT fovy,
+    FLOAT Aspect,
+    FLOAT zn,
+    FLOAT zf
+){
+
+
+FLOAT yscale;
+  FLOAT xscale;
+
+  
+  
+  yscale  =  1.0f/tan(fovy/2.0f);
+  
+
+  xscale   = Aspect * yscale;
+
+  pOut->_11 = xscale;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+
+  pOut->_21 = 0;
+  pOut->_22 = yscale;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = zf/(zn-zf);
+  pOut->_34 = -1;
+
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = zn*zf/(zn-zf);
+  pOut->_44 = 0;
+   
+  return pOut;
+  
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixPerspectiveLH(      
+    D3DXMATRIX *pOut,
+    FLOAT w,
+    FLOAT h,
+    FLOAT zn,
+    FLOAT zf
+){
+/*
+2*zn/w  0       0              0
+0       2*zn/h  0              0
+0       0       zf/(zf-zn)     1
+0       0       zn*zf/(zn-zf)  0
+*/
+   return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixPerspectiveOffCenterLH(      
+    D3DXMATRIX *pOut,
+    FLOAT l,
+    FLOAT r,
+    FLOAT b,
+    FLOAT t,
+    FLOAT zn,
+    FLOAT zf
+){
+/*
+2*zn/(r-l)   0            0              0
+0            2*zn/(t-b)   0              0
+(l+r)/(l-r)  (t+b)/(b-t)  zf/(zf-zn)     1
+0            0            zn*zf/(zn-zf)  0
+*/
+   return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixPerspectiveOffCenterRH(      
+    D3DXMATRIX *pOut,
+    FLOAT l,
+    FLOAT r,
+    FLOAT b,
+    FLOAT t,
+    FLOAT zn,
+    FLOAT zf
+){
+/*
+
+2*zn/(r-l)   0            0                0
+0            2*zn*(t-b)   0                0
+(l+r)/(r-l)  (t+b)/(t-b)  zf/(zn-zf)      -1
+0            0            zn*zf/(zn-zf)    0
+*/
+   return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixPerspectiveRH(      
+    D3DXMATRIX *pOut,
+    FLOAT w,
+    FLOAT h,
+    FLOAT zn,
+    FLOAT zf
+){
+/*
+2*zn/w  0       0              0
+0       2*zn/h  0              0
+0       0       zf/(zn-zf)    -1
+0       0       zn*zf/(zn-zf)  0
+*/
+   return pOut;
+}
+
+#if 0
+D3DXMATRIX *D3DXMatrixIdentity(D3DXMATRIX* pOut)
+{
+   pOut->_11 = 1;
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+
+   pOut->_21 = 0;
+   pOut->_22 = 1;
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 1;
+   pOut->_33 = 0;
+   pOut->_34 = 0;
+
+   pOut->_41 = 0;
+   pOut->_42 = 0;
+   pOut->_43 = 0;
+   pOut->_44 = 1;
+
+   return pOut;
+
+}
+
+BOOL D3DXMatrixIsIdentity(      
+    CONST D3DXMATRIX *pM
+){
+return (pM->_11 == 1 &&
+       pM->_12 == 0 &&
+       pM->_13 == 0 &&
+       pM->_14 == 0 &&
+       pM->_21 == 0 &&
+       pM->_22 == 1 &&
+       pM->_23 == 0 &&
+       pM->_24 == 0 &&
+       pM->_31 == 0 &&
+       pM->_32 == 0 &&
+       pM->_33 == 1 &&
+       pM->_34 == 0 &&
+       pM->_41 == 0 &&
+       pM->_42 == 0 &&
+       pM->_43 == 0 &&
+       pM->_44 == 1) ? TRUE:FALSE;       
+       
+}
+#endif
+
+D3DXMATRIX *WINAPI D3DXMatrixMultiplyTranspose(      
+    D3DXMATRIX* pOut,
+    const D3DXMATRIX* pM1,
+    const D3DXMATRIX* pM2
+){
+  /* pOut= T(M1*M2), justdo a matrix mulication but with ab's on the out put swaped for ba's.*/
+   FIXME("stub\n");
+   return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixMultiply(      
+    D3DXMATRIX *pOut,
+    CONST D3DXMATRIX *pM1,
+    CONST D3DXMATRIX *pM2
+){
+
+
+
+
+   pOut->_11 = pM1->_11 * pM2->_11 + pM1->_12 * pM2->_21 +  pM1->_13 * pM2->_31 + pM1->_14 * pM2->_41;
+   pOut->_12 = pM1->_11 * pM2->_12 + pM1->_12 * pM2->_22 +  pM1->_13 * pM2->_32 + pM1->_14 * pM2->_42;
+   pOut->_13 = pM1->_11 * pM2->_13 + pM1->_12 * pM2->_23 +  pM1->_13 * pM2->_33 + pM1->_14 * pM2->_43;
+   pOut->_14 = pM1->_11 * pM2->_14 + pM1->_12 * pM2->_24 +  pM1->_13 * pM2->_34 + pM1->_14 * pM2->_44;
+   
+   pOut->_21 = pM1->_21 * pM2->_11 + pM1->_22 * pM2->_21 +  pM1->_23 * pM2->_31 + pM1->_24 * pM2->_41;
+   pOut->_22 = pM1->_21 * pM2->_12 + pM1->_22 * pM2->_22 +  pM1->_23 * pM2->_32 + pM1->_24 * pM2->_42;
+   pOut->_23 = pM1->_21 * pM2->_13 + pM1->_22 * pM2->_23 +  pM1->_23 * pM2->_33 + pM1->_24 * pM2->_43;
+   pOut->_24 = pM1->_21 * pM2->_14 + pM1->_22 * pM2->_24 +  pM1->_23 * pM2->_34 + pM1->_24 * pM2->_44;
+   
+   pOut->_31 = pM1->_31 * pM2->_11 + pM1->_32 * pM2->_21 +  pM1->_33 * pM2->_31 + pM1->_34 * pM2->_41;
+   pOut->_32 = pM1->_31 * pM2->_12 + pM1->_32 * pM2->_22 +  pM1->_33 * pM2->_32 + pM1->_34 * pM2->_42;
+   pOut->_33 = pM1->_31 * pM2->_13 + pM1->_32 * pM2->_23 +  pM1->_33 * pM2->_33 + pM1->_34 * pM2->_43;
+   pOut->_34 = pM1->_31 * pM2->_14 + pM1->_32 * pM2->_24 +  pM1->_33 * pM2->_34 + pM1->_34 * pM2->_44;
+   
+   pOut->_41 = pM1->_41 * pM2->_11 + pM1->_42 * pM2->_21 +  pM1->_43 * pM2->_31 + pM1->_44 * pM2->_41;
+   pOut->_42 = pM1->_41 * pM2->_12 + pM1->_42 * pM2->_22 +  pM1->_43 * pM2->_32 + pM1->_44 * pM2->_42;
+   pOut->_43 = pM1->_41 * pM2->_13 + pM1->_42 * pM2->_23 +  pM1->_43 * pM2->_33 + pM1->_44 * pM2->_43;
+   pOut->_44 = pM1->_41 * pM2->_14 + pM1->_42 * pM2->_24 +  pM1->_43 * pM2->_34 + pM1->_44 * pM2->_44;
+
+   return pOut;
+   
+}
+
+
+
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationX(      
+    D3DXMATRIX *pOut,
+    FLOAT Angle
+){
+/*I hope the handedness is correct, MSDN doesn't say*/
+
+  pOut->_11 = 1;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14=  0;
+  
+  pOut->_21 = 0;
+  pOut->_22 = cos(Angle);
+  pOut->_23 = sin(Angle);
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = -sin(Angle);
+  pOut->_33 = cos(Angle);
+  pOut->_34=  0;
+  
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = 0;
+  pOut->_44=  1;/*is this 1*/
+  
+  return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationY(      
+    D3DXMATRIX *pOut,
+    FLOAT Angle
+){
+
+  pOut->_11 = cos(Angle);
+  pOut->_12 = 0;
+  pOut->_13 = sin(Angle);
+  pOut->_14 = 0;
+  
+  pOut->_21 = 0;
+  pOut->_22 = 1;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+
+  pOut->_31 = -sin(Angle);
+  pOut->_32 = 0;
+  pOut->_33 = cos(Angle);
+  pOut->_34 = 0;
+  
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = 0;
+  pOut->_44 = 1;/*is this 1*/
+  return pOut;  
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationZ(      
+    D3DXMATRIX *pOut,
+    FLOAT Angle
+){
+ /*MSDN doesn't tell me which way arond this is!!*/
+ 
+  FIXME("Matrix rotation z\n");
+  pOut->_11 = cos(Angle);
+  pOut->_12 = sin(Angle);
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+
+  pOut->_21 = -sin(Angle);
+  pOut->_22 = cos(Angle);
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = 1;
+  pOut->_34 = 0;
+  
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = 0;
+  pOut->_44 = 1;/*is this 1*/
+  
+  return pOut;
+}
+
+
+
+
+/*timeGetTime*/
+
+D3DXMATRIX *WINAPI D3DXMatrixScaling(      
+    D3DXMATRIX *pOut,
+    FLOAT sx,
+    FLOAT sy,
+    FLOAT sz
+){
+  FIXME("Creating a scaling matrix\n");
+  pOut->_11 = sx;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+
+  pOut->_21 = 0;
+  pOut->_22 = sy;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = sz;
+  pOut->_34 = 0;
+  
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = 0;
+  pOut->_44 = 1;
+    
+  return pOut;
+}
+
+
+
+D3DXMATRIX *WINAPI D3DXMatrixShadow(      
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR4 *pLight,
+    CONST D3DXPLANE *pPlane
+){
+   FIXME("stub\n");
+  
+
+  /*
+  D3DXPLANE P = D3DXPlaneNormalize( &P, pPlane);
+  L = Light;
+  d = dot(P, L)
+
+  P.a * L.x + d  P.a * L.y      P.a * L.z      P.a * L.w  
+  P.b * L.x      P.b * L.y + d  P.b * L.z      P.b * L.w  
+  P.c * L.x      P.c * L.y      P.c * L.z + d  P.c * L.w  
+  P.d * L.x      P.d * L.y      P.d * L.z      P.d * L.w + d
+  */
+
+    return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixTransformation(      
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR3 *pScalingCenter,
+    CONST D3DXQUATERNION *pScalingRotation,
+    CONST D3DXVECTOR3 *pScaling,
+    CONST D3DXVECTOR3 *pRotationCenter,
+    CONST D3DXQUATERNION *pRotation,
+    CONST D3DXVECTOR3 *pTranslation
+){
+
+/*
+This function calculates the transformation matrix with the following formula, with matrix concatenation evaluated in left-to-right order: 
+
+    Mout = (Msc)-1 * (Msr)-1 * Ms * Msr * Msc * (Mrc)-1 * Mr * Mrc * Mt
+
+
+where:
+
+
+    Mout = output matrix (pOut)
+
+
+    Msc = scaling center matrix (pScalingCenter)
+
+
+    Msr = scaling rotation matrix (pScalingRotation)
+
+
+    Ms = scaling matrix (pScaling)
+
+
+    Mrc = center of rotation matrix (pRotationCenter)
+
+
+    Mr = rotation matrix (pRotation)
+
+
+    Mt = translation matrix (pTranslation)
+*/
+   FIXME("stub\n");
+   return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixTransformation2D(      
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR2 *pScalingCenter,
+    FLOAT *pScalingRotation,
+    CONST D3DXVECTOR2 *pScaling,
+    CONST D3DXVECTOR2 *pRotationCenter,
+    FLOAT Rotation,
+    CONST D3DXVECTOR2 *pTranslation
+){
+/*
+This function calculates the transformation matrix with the following formula, with matrix concatenation evaluated in left-to-right order: 
+
+    Mout = (Msc)-1 * (Msr)-1 * Ms * Msr * Msc * (Mrc)-1 * Mr * Mrc * Mt
+
+
+where:
+
+
+    Mout = output matrix (pOut)
+
+
+    Msc = scaling center matrix (pScalingCenter)
+
+
+    Msr = scaling rotation matrix (pScalingRotation)
+
+
+    Ms = scaling matrix (pScaling)
+
+
+    Mrc = center of rotation matrix (pRotationCenter)
+
+
+    Mr = rotation matrix (Rotation)
+
+
+    Mt = translation matrix (pTranslation)
+*/
+   FIXME("stub\n");
+   return pOut;
+}
+
+
+D3DXMATRIX *WINAPI D3DXMatrixTranspose(      
+    D3DXMATRIX *pOut,
+    CONST D3DXMATRIX *pM
+){
+
+   pOut->_11 = pM->_11;
+   pOut->_12 = pM->_21;
+   pOut->_13 = pM->_31;
+   pOut->_14 = pM->_41;
+
+   pOut->_21 = pM->_12;
+   pOut->_22 = pM->_22;
+   pOut->_23 = pM->_32;
+   pOut->_24 = pM->_42;
+
+   pOut->_31 = pM->_13;
+   pOut->_32 = pM->_23;
+   pOut->_33 = pM->_33;
+   pOut->_34 = pM->_43;
+
+   pOut->_41 = pM->_14;
+   pOut->_42 = pM->_24;
+   pOut->_43 = pM->_34;
+   pOut->_44 = pM->_44;
+
+   return pOut;
+
+}
+
+/*Not in Microsoft library*/
+float D3DXPlaneLength(CONST D3DXPLANE *pP){
+  return sqrt(pP->a * pP->a + pP->b * pP->b + pP->c * pP->c + pP->d * pP->d);
+}
+
+D3DXPLANE *D3DXPlaneScale(
+    D3DXPLANE *pOut,
+    CONST D3DXPLANE *pP,
+    FLOAT s
+){
+  pOut->a = pP->a * s;
+  pOut->b = pP->b * s;
+  pOut->c = pP->c * s;
+  pOut->d = pP->d * s;
+  return pOut;
+}
+
+D3DXPLANE *WINAPI D3DXPlaneNormalize(
+    D3DXPLANE *pOut,
+    CONST D3DXPLANE *pP
+){
+  /*|D3DXPLANE| */
+  
+  float d = D3DXPlaneLength(pP);
+  if(d == 0 ){
+   pOut->a = 0;
+   pOut->b = 0;
+   pOut->c = 0;
+   pOut->d = 0;
+  }else{
+    return D3DXPlaneScale(pOut, pP, 1.0f/d);
+  }
+  return pOut;
+}
+
+D3DXPLANE *WINAPI D3DXPlaneTransform(      
+    D3DXPLANE *pOut,
+    CONST D3DXPLANE *pP,
+    CONST D3DXMATRIX *pM
+){
+/*
+D3DXPLANE   planeNew;
+D3DXPLANE   plane(0,1,1,0);
+D3DXPlaneNormalize(&plane, &plane);
+
+D3DXMATRIX  matrix;
+D3DXMatrixScaling(&matrix, 1.0f,2.0f,3.0f); 
+D3DXMatrixInverse(&matrix, NULL, &matrix);
+D3DXMatrixTranspose(&matrix, &matrix);
+D3DXPlaneTransform(&planeNew, &plane, &matrix);
+
+
+
+A plane is described by ax + by + cz + dw = 0. The first plane is created with (a,b,c,d) = (0,1,1,0), which is a plane described by y + z = 0. After scaling, the new plane contains (a,b,c,d) = (0, 0.353f, 0.235f, 0), which shows the new plane to be described by 0.353y + 0.235z = 0.
+
+
+The parameter pM contains the inverse transpose of the transformation matrix. The inverse transpose is required by this method so that the normal vector of the transformed plane can be correctly transformed as well.
+*/
+   return pOut;
+}
+
+
+D3DXPLANE *WINAPI D3DXPlaneTransformArray(      
+    D3DXPLANE *pOut,
+    UINT OutStride,
+    CONST D3DXPLANE* pP,
+    UINT PStride,
+    CONST D3DXMATRIX* pM,
+    UINT n
+){
+   /*http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_04/directx/graphics/reference/d3dx/functions/math/d3dxmatrixshadow.asp*/
+   return pOut;
+}
+
+
+D3DXQUATERNION *WINAPI D3DXQuaternionBaryCentric(      
+    D3DXQUATERNION *pOut,
+    CONST D3DXQUATERNION *pQ1,
+    CONST D3DXQUATERNION *pQ2,
+    CONST D3DXQUATERNION *pQ3,
+    FLOAT f,
+    FLOAT g
+){
+/*http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_04/directx/graphics/reference/d3dx/functions/math/d3dxmatrixshadow.asp*/
+    return pOut;
+}
+
+D3DXQUATERNION *D3DXQuaternionConjugate(      
+    D3DXQUATERNION *pOut,
+    CONST D3DXQUATERNION *pQ
+){
+    return pOut;
+}
+
+FLOAT D3DXQuaternionDot(      
+    CONST D3DXQUATERNION *pQ1,
+    CONST D3DXQUATERNION *pQ2
+){
+    return 0.0f;
+}
+
+
+
+
+D3DXCOLOR *D3DXColorAdd(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC1,
+    CONST D3DXCOLOR *pC2
+){    
+   /*I think they mean this!*/
+   pOut->r = (pC1->r + pC2->r) * 0.5f;
+   pOut->g = (pC1->g + pC2->g) * 0.5f;
+   pOut->b = (pC1->b + pC2->b) * 0.5f;
+   return pOut;
+   
+}
+
+
+D3DXCOLOR *WINAPI D3DXColorAdjustContrast(      
+    D3DXCOLOR *pOut,
+    const D3DXCOLOR *pC,
+    FLOAT c
+){
+  
+   pOut->r = 0.5f + c * (pC->r - 0.5f);
+   pOut->g = 0.5f + c * (pC->g - 0.5f);
+   pOut->b = 0.5f + c * (pC->b - 0.5f);
+   pOut->a = pC->a; 
+   return pOut;
+}
+/*** Based upon MSDN, based on the NTSC standard described in ITU-R Recommendation BT.709***/
+#define NOSAT(pC) (pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f)
+
+D3DXCOLOR *WINAPI D3DXColorAdjustSaturation(      
+    D3DXCOLOR *pOut,
+    const D3DXCOLOR *pC,
+    FLOAT s
+){
+  
+  float grey = NOSAT(pC);  
+  pOut->r = grey + s * (pC->r - grey);
+  pOut->g = grey + s * (pC->g - grey);
+  pOut->b = grey + s * (pC->b - grey);
+  pOut->a = pC->a;
+  return pOut;
+}
+
+
+/*Linear interplot*/
+D3DXCOLOR *D3DXColorLerp(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC1,
+    CONST D3DXCOLOR *pC2,
+    FLOAT s
+){
+  
+  pOut->r = pC1->r + s * (pC2->r - pC1->r);
+  pOut->g = pC1->g + s * (pC2->g - pC1->g);
+  pOut->b = pC1->b + s * (pC2->b - pC1->b);
+  pOut->a = pC1->a + s * (pC2->a - pC1->a);
+  return pOut;
+}
+
+D3DXCOLOR *D3DXColorModulate(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC1,
+    CONST D3DXCOLOR *pC2
+){
+
+  pOut->r = pC1->r * pC2->r;
+  pOut->g = pC1->g * pC2->g;
+  pOut->b = pC1->b * pC2->b;
+  pOut->a = pC1->a * pC2->a;
+  return pOut;
+}
+
+D3DXCOLOR *D3DXColorNegative(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC
+){
+   
+  pOut->r = 1.0f - pC->r;
+  pOut->g = 1.0f - pC->g;
+  pOut->b = 1.0f - pC->b;
+  pOut->a = pC->a;
+   
+  return pOut;
+}
+
+
+D3DXCOLOR *D3DXColorScale(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC,
+    FLOAT s
+){
+  pOut->r = pC->r * s;
+  pOut->g = pC->g * s;
+  pOut->b = pC->b * s;
+  pOut->a = pC->a * s;
+  return pOut;
+}
+
+
+D3DXCOLOR *D3DXColorSubtract(      
+    D3DXCOLOR *pOut,
+    CONST D3DXCOLOR *pC1,
+    CONST D3DXCOLOR *pC2
+){    
+   /*I think they mean |r1 - r2| who knows*/
+   pOut->r = (pC1->r - pC2->r);
+   pOut->g = (pC1->g - pC2->g);
+   pOut->b = (pC1->b - pC2->b);
+   pOut->a = (pC1->a - pC2->a);
+   
+   if(pOut->r < 0 ) pOut->r = -pOut->r;
+   if(pOut->g < 0 ) pOut->g = -pOut->g;
+   if(pOut->b < 0 ) pOut->b = -pOut->b;
+   if(pOut->a < 0 ) pOut->a = -pOut->a;
+   
+   return pOut;
+   
+}
+
+#if 0
+HRESULT WINAPI D3DXCreateMatrixStack(      
+    DWORD Flags,
+    LPD3DXMATRIXSTACK *ppStack
+){
+   FIXME("stub\n");
+   return D3D_OK;
+}
+#endif
+
+
+
+FLOAT *WINAPI D3DXFloat16To32Array(      
+    FLOAT *pOut,
+    const D3DXFLOAT16 *pIn,
+    UINT n
+){
+/*MSDN is kind and doesn't want to tell us what a float16 is (I expect it's a fixed 8.8 not a float!)*/
+   #if 0
+   int i;
+   for(i=0;i<n;i++){
+     pOut[i] = ((FLOAT)pIn[i]->Value)*;
+   }
+   #endif
+   return pOut;
+}
+
+D3DXFLOAT16 *WINAPI D3DXFloat32To16Array(      
+    D3DXFLOAT16* pOut,
+    CONST FLOAT* pIn,
+    UINT n
+){
+  #if 0
+   int i;
+   for(i=0;i<n;i++){
+     pOut[i]->Value = (WORD)pIn[i];
+   }
+   #endif
+   return pOut;   
+}
+
+
+FLOAT WINAPI D3DXFresnelTerm(      
+    FLOAT CosTheta,
+    FLOAT RefractionIndex
+){
+/*
+To find the Fresnel term (F):
+
+
+If A is angle of incidence and B is the angle of refraction, then
+
+F = 0.5 * [tan2(A - B) / tan2(A + B) + sin2(A - B) / sin2(A + B)]
+  = 0.5 * sin2(A - B) / sin2(A + B) * [cos2(A + B) / cos2(A - B) + 1]
+
+Let r   = sina(A) / sin(B)      (the relative refractive index)
+Let c   = cos(A)
+Let g   = (r2 + c2 - 1)1/2
+
+
+Then, expanding using the trig identities and simplifying, you get:
+
+F = 0.5 * (g + c)2 / (g - c)2 * ([c(g + c) - 1]2 / [c(g - c) + 1]2 + 1)
+
+
+*/
+   FIXME("stub\n");
+   return 0.0f;
+}
+
+
+
+D3DXMATRIX *WINAPI D3DXMatrixLookAtLH(
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR3 *pEye,
+    CONST D3DXVECTOR3 *pAt,
+    CONST D3DXVECTOR3 *pUp
+){
+
+/*
+zaxis = normal(At - Eye)
+xaxis = normal(cross(Up, zaxis))
+yaxis = cross(zaxis, xaxis)
+
+ xaxis.x           yaxis.x           zaxis.x          0
+ xaxis.y           yaxis.y           zaxis.y          0
+ xaxis.z           yaxis.z           zaxis.z          0
+-dot(xaxis, eye)  -dot(yaxis, eye)  -dot(zaxis, eye)  1
+*/
+
+  D3DXVECTOR3 tmp;
+  D3DXVECTOR3 zaxis;
+  D3DXVECTOR3 xaxis;
+  D3DXVECTOR3 yaxis;
+  
+  D3DXVec3Normalize(&zaxis,D3DXVec3Subtract(&tmp, pAt, pEye));
+  D3DXVec3Normalize(&xaxis,D3DXVec3Cross(&tmp, pUp, &zaxis));
+  D3DXVec3Cross(&yaxis, &zaxis, &xaxis);
+
+  pOut->_11 = xaxis.x;
+  pOut->_12 = yaxis.x;
+  pOut->_13 = zaxis.x;
+  pOut->_14 = 0;
+
+  pOut->_21 = xaxis.y;
+  pOut->_22 = yaxis.y;
+  pOut->_23 = zaxis.y;
+  pOut->_24 = 0;
+
+
+  pOut->_31 = xaxis.z;
+  pOut->_32 = yaxis.z;
+  pOut->_33 = zaxis.z;
+  pOut->_34 = 0;
+
+  pOut->_41 = -D3DXVec3Dot(&xaxis, pEye);
+  pOut->_42 = -D3DXVec3Dot(&yaxis, pEye);
+  pOut->_43 = -D3DXVec3Dot(&zaxis, pEye);
+  pOut->_44 = 1;
+  
+  return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixLookAtRH(
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR3 *pEye,
+    CONST D3DXVECTOR3 *pAt,
+    CONST D3DXVECTOR3 *pUp
+){
+
+/*
+zaxis = normal(Eye - At)
+xaxis = normal(cross(Up, zaxis))
+yaxis = cross(zaxis, xaxis)
+
+ xaxis.x           yaxis.x           zaxis.x          0
+ xaxis.y           yaxis.y           zaxis.y          0
+ xaxis.z           yaxis.z           zaxis.z          0
+-dot(xaxis, eye)  -dot(yaxis, eye)  -dot(zaxis, eye)  1
+*/
+
+
+  D3DXVECTOR3 tmp;
+  D3DXVECTOR3 zaxis;
+  D3DXVECTOR3 xaxis;
+  D3DXVECTOR3 yaxis;
+
+  D3DXVec3Normalize(&zaxis,D3DXVec3Subtract(&tmp, pEye, pAt));
+  D3DXVec3Normalize(&xaxis,D3DXVec3Cross(&tmp, pUp, &zaxis));
+  D3DXVec3Cross(&yaxis, &zaxis, &xaxis);
+
+  pOut->_11 = xaxis.x;
+  pOut->_12 = yaxis.x;
+  pOut->_13 = zaxis.x;
+  pOut->_14 = 0;
+
+  pOut->_21 = xaxis.y;
+  pOut->_22 = yaxis.y;
+  pOut->_23 = zaxis.y;
+  pOut->_24 = 0;
+
+
+  pOut->_31 = xaxis.z;
+  pOut->_32 = yaxis.z;
+  pOut->_33 = zaxis.z;
+  pOut->_34 = 0;
+
+  pOut->_41 = -D3DXVec3Dot(&xaxis, pEye);
+  pOut->_42 = -D3DXVec3Dot(&yaxis, pEye);
+  pOut->_43 = -D3DXVec3Dot(&zaxis, pEye);
+  pOut->_44 = 1;
+  
+  FIXME("stub\n");
+  return pOut;
+}
+
+
+
+
+FLOAT D3DXPlaneDot(      
+    CONST D3DXPLANE *pP,
+    CONST D3DXVECTOR4 *pV
+){
+   return pP->a  * pV->x +
+       pP->b  * pV->y +
+       pP->c  * pV->z +
+       pP->d  * pV->w;
+
+}
+
+
+FLOAT D3DXPlaneDotCoord(      
+    CONST D3DXPLANE *pP,
+    CONST D3DXVECTOR3 *pV
+){
+   return pP->a  * pV->x +
+       pP->b  * pV->y +
+       pP->c  * pV->z +
+       pP->d;
+}
+
+FLOAT D3DXPlaneDotNormal(      
+    CONST D3DXPLANE *pP,
+    CONST D3DXVECTOR3 *pV
+){
+   return pP->a  * pV->x +
+       pP->b  * pV->y +
+       pP->c  * pV->z;
+}
+
+
+D3DXPLANE *WINAPI D3DXPlaneFromPointNormal(      
+    D3DXPLANE *pOut,
+    CONST D3DXVECTOR3 *pPoint,
+    CONST D3DXVECTOR3 *pNormal
+){
+   return pOut;
+}
+
+D3DXPLANE *WINAPI D3DXPlaneFromPoints(      
+    D3DXPLANE *pOut,
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2,
+    CONST D3DXVECTOR3 *pV3
+){
+   return pOut;
+}
+
+D3DXVECTOR3 *WINAPI D3DXPlaneIntersectLine(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXPLANE *pP,
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2
+){
+   return pOut;
+}
+
+
+
+D3DXMATRIX *WINAPI D3DXMatrixReflect(      
+    D3DXMATRIX *pOut,
+    CONST D3DXPLANE *pPlane
+){
+  D3DXPLANE ptmp;
+  D3DXPlaneNormalize(&ptmp,pPlane);
+    
+  pOut->_11 = -2 * ptmp.a * ptmp.a + 1;
+  pOut->_12 = -2 * ptmp.b * ptmp.a;
+  pOut->_13 = -2 * ptmp.c * ptmp.a;
+  pOut->_14 = 0;
+
+  pOut->_21 = -2 * ptmp.a * ptmp.b;
+  pOut->_22 = -2 * ptmp.b * ptmp.b + 1;
+  pOut->_23 = -2 * ptmp.c * ptmp.b;
+  pOut->_24 = 0;
+
+  pOut->_31 = -2 * ptmp.a * ptmp.c;
+  pOut->_32 = -2 * ptmp.b * ptmp.c;
+  pOut->_33 = -2 * ptmp.b * ptmp.c;
+  pOut->_34 = 0;
+
+  pOut->_41 = -2 * ptmp.b * ptmp.c;
+  pOut->_42 = -2 * ptmp.b * ptmp.d;
+  pOut->_43 = -2 * ptmp.c * ptmp.d;
+  pOut->_44 = 1;
+
+  return pOut;
+  
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationAxis(      
+    D3DXMATRIX *pOut,
+    CONST D3DXVECTOR3 *pV,
+    FLOAT Angle
+){
+FIXME("stub\n");
+return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationQuaternion(
+    D3DXMATRIX *pOut,
+    CONST D3DXQUATERNION *pQ
+){
+  FIXME("stub\n");
+  return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixRotationYawPitchRoll(      
+    D3DXMATRIX *pOut,
+    FLOAT Yaw,
+    FLOAT Pitch,
+    FLOAT Roll
+){
+
+ D3DXMATRIX rotz;
+ D3DXMATRIX roty;
+ D3DXMATRIX rotx;
+ D3DXMATRIX mTmp; 
+
+ D3DXMatrixRotationZ(&rotz,Roll);
+ D3DXMatrixRotationX(&rotx,Pitch);
+ D3DXMatrixRotationY(&roty,Yaw);
+ D3DXMatrixMultiply(&mTmp,&rotz,&rotx);
+ return D3DXMatrixMultiply(pOut,&mTmp,&roty);
+
+}
+
+
+D3DXMATRIX *WINAPI D3DXMatrixInverse(      
+    D3DXMATRIX *pOut,
+    FLOAT *pDeterminant,
+    CONST D3DXMATRIX *pM
+){
+#if 0
+
+    pM->_11 = pM->_23*pM->_34*pM->_42 - pM->_24*pM->_33*pM->_42 + pM->_24*pM->_32*pM->_43 - pM->_22*pM->_34*pM->_43 - pM->_23*pM->_32*pM->_44 + pM->_22*pM->_33*pM->_44;
+    pM->_12 = pM->_14*pM->_33*pM->_42 - pM->_13*pM->_34*pM->_42 - pM->_14*pM->_32*pM->_43 + pM->_12*pM->_34*pM->_43 + pM->_13*pM->_32*pM->_44 - pM->_12*pM->_33*pM->_44;
+    pM->_13 = pM->_13*pM->_24*pM->_42 - pM->_14*pM->_23*pM->_42 + pM->_14*pM->_22*pM->_43 - pM->_12*pM->_24*pM->_43 - pM->_13*pM->_22*pM->_44 + pM->_12*pM->_23*pM->_44;
+    pM->_14 = pM->_14*pM->_23*pM->_32 - pM->_13*pM->_24*pM->_32 - pM->_14*pM->_22*pM->_33 + pM->_12*pM->_24*pM->_33 + pM->_13*pM->_22*pM->_34 - pM->_12*pM->_23*pM->_34;
+    pM->_21 = pM->_24*pM->_33*pM->_41 - pM->_23*pM->_34*pM->_41 - pM->_24*pM->_31*pM->_43 + pM->_21*pM->_34*pM->_43 + pM->_23*pM->_31*pM->_44 - pM->_21*pM->_33*pM->_44;
+    pM->_22 = pM->_13*pM->_34*pM->_41 - pM->_14*pM->_33*pM->_41 + pM->_14*pM->_31*pM->_43 - pM->_11*pM->_34*pM->_43 - pM->_13*pM->_31*pM->_44 + pM->_11*pM->_33*pM->_44;
+    pM->_23 = pM->_14*pM->_23*pM->_41 - pM->_13*pM->_24*pM->_41 - pM->_14*pM->_21*pM->_43 + pM->_11*pM->_24*pM->_43 + pM->_13*pM->_21*pM->_44 - pM->_11*pM->_23*pM->_44;
+    pM->_24 = pM->_13*pM->_24*pM->_31 - pM->_14*pM->_23*pM->_31 + pM->_14*pM->_21*pM->_33 - pM->_11*pM->_24*pM->_33 - pM->_13*pM->_21*pM->_34 + pM->_11*pM->_23*pM->_34;
+    pM->_31 = pM->_22*pM->_34*pM->_41 - pM->_24*pM->_32*pM->_41 + pM->_24*pM->_31*pM->_42 - pM->_21*pM->_34*pM->_42 - pM->_22*pM->_31*pM->_44 + pM->_21*pM->_32*pM->_44;
+    pM->_32 = pM->_14*pM->_32*pM->_41 - pM->_12*pM->_34*pM->_41 - pM->_14*pM->_31*pM->_42 + pM->_11*pM->_34*pM->_42 + pM->_12*pM->_31*pM->_44 - pM->_11*pM->_32*pM->_44;
+    pM->_33 = pM->_12*pM->_24*pM->_41 - pM->_14*pM->_22*pM->_41 + pM->_14*pM->_21*pM->_42 - pM->_11*pM->_24*pM->_42 - pM->_12*pM->_21*pM->_44 + pM->_11*pM->_22*pM->_44;
+    pM->_34 = pM->_14*pM->_22*pM->_31 - pM->_12*pM->_24*pM->_31 - pM->_14*pM->_21*pM->_32 + pM->_11*pM->_24*pM->_32 + pM->_12*pM->_21*pM->_34 - pM->_11*pM->_22*pM->_34;
+    pM->_41 = pM->_23*pM->_32*pM->_41 - pM->_22*pM->_33*pM->_41 - pM->_23*pM->_31*pM->_42 + pM->_21*pM->_33*pM->_42 + pM->_22*pM->_31*pM->_43 - pM->_21*pM->_32*pM->_43;
+    pM->_42 = pM->_12*pM->_33*pM->_41 - pM->_13*pM->_32*pM->_41 + pM->_13*pM->_31*pM->_42 - pM->_11*pM->_33*pM->_42 - pM->_12*pM->_31*pM->_43 + pM->_11*pM->_32*pM->_43;
+    pM->_43 = pM->_13*pM->_22*pM->_41 - pM->_12*pM->_23*pM->_41 - pM->_13*pM->_21*pM->_42 + pM->_11*pM->_23*pM->_42 + pM->_12*pM->_21*pM->_43 - pM->_11*pM->_22*pM->_43;
+    pM->_44 = pM->_12*pM->_23*pM->_31 - pM->_13*pM->_22*pM->_31 + pM->_13*pM->_21*pM->_32 - pM->_11*pM->_23*pM->_32 - pM->_12*pM->_21*pM->_33 + pM->_11*pM->_22*pM->_33;
+    
+    scale(1/m1.determinant());
+#endif
+  FIXME("stub\n");
+  return pOut;
+
+}
+
+
+
+D3DXMATRIX *WINAPI D3DXMatrixTranslation(      
+    D3DXMATRIX *pOut,
+    FLOAT x,
+    FLOAT y,
+    FLOAT z
+){
+
+/*I think it's something like this?*/
+   pOut->_11 = 1;
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+
+   pOut->_21 = 0;
+   pOut->_22 = 1;
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 0;
+   pOut->_33 = 1;
+   pOut->_34 = 0;
+
+   pOut->_41 = x;
+   pOut->_42 = y;
+   pOut->_43 = z;
+   pOut->_44 = 1;
+
+   return pOut; 
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixOrthoLH(
+    D3DXMATRIX *pOut,
+    FLOAT w,
+    FLOAT h,
+    FLOAT zn,
+    FLOAT zf
+){
+
+/*I'm not texting for a div0 at the moment because MSDN doesn't tell me what I should do (if anything!)
+
+if(zn == zf){
+}
+
+*/
+
+  pOut->_11 = 2/w;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+  
+  pOut->_21 = 0;
+  pOut->_22 = 2/h;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = 1/(zf-zn);
+  pOut->_34 = 0;
+
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = zn/(zn-zf);
+  pOut->_44 = 1;
+
+  return pOut;
+}
+
+
+D3DXMATRIX *WINAPI D3DXMatrixOrthoRH(
+    D3DXMATRIX *pOut,
+    FLOAT w,
+    FLOAT h,
+    FLOAT zn,
+    FLOAT zf
+){
+/*I'm not texting for a div0 at the moment because MSDN doesn't tell me what I should do (if anything!)
+
+if(zn == zf){
+}
+
+*/
+  pOut->_11 = 2/w;
+  pOut->_12 = 0;
+  pOut->_13 = 0;
+  pOut->_14 = 0;
+  
+  pOut->_21 = 0;
+  pOut->_22 = 2/h;
+  pOut->_23 = 0;
+  pOut->_24 = 0;
+
+  pOut->_31 = 0;
+  pOut->_32 = 0;
+  pOut->_33 = 1/(zn-zf);
+  pOut->_34 = 0;
+
+  pOut->_41 = 0;
+  pOut->_42 = 0;
+  pOut->_43 = zn/(zn-zf);
+  pOut->_44 = 1;
+
+  return pOut;
+}
+
+D3DXMATRIX *WINAPI D3DXMatrixOrthoOffCenterLH(      
+    D3DXMATRIX *pOut,
+    FLOAT l,
+    FLOAT r,
+    FLOAT b,
+    FLOAT t,
+    FLOAT zn,
+    FLOAT zf
+){
+/* MSDN doesn't say what to do with a div/0
+if(zf == zn){
+}
+*/
+   pOut->_11 = 2.0 / (r - 1.0);
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+
+   pOut->_21 = 0;
+   pOut->_22 = 2.0 / (t - b);
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 0;
+   pOut->_33 = 1.0 / (zf - zf);
+   pOut->_34 = 0;
+
+   pOut->_41 = (1.0 + r) / (1.0 - r);
+   pOut->_42 = (t + b) / (b - t);
+   pOut->_43 = zn / (zn - zf);
+   pOut->_44 = 1;
+
+   return pOut;
+}
+
+
+D3DXMATRIX *WINAPI D3DXMatrixOrthoOffCenterRH(      
+    D3DXMATRIX *pOut,
+    FLOAT l,
+    FLOAT r,
+    FLOAT b,
+    FLOAT t,
+    FLOAT zn,
+    FLOAT zf
+){
+/* MSDN doesn't say what to do with a div/0
+if(zf == zn){
+}
+*/
+   pOut->_11 = 2.0 / (r - 1.0);
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+ 
+   pOut->_21 = 0;
+   pOut->_22 = 2.0 / (t - b);
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 0;
+   pOut->_33 = 1.0 / (zn - zf);
+   pOut->_34 = 0;
+
+   pOut->_41 = (1.0 + r) / (1.0 - r);
+   pOut->_42 = (t + b) / (b - t);
+   pOut->_43 = zn / (zn - zf);
+   pOut->_44 = 1;
+
+   return pOut;
+}
+
+
+
+
+
+/*I think this normalized on the magnitude, but I'm not sure!*/
+D3DXVECTOR3 *WINAPI D3DXVec3Normalize(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXVECTOR3 *pV
+){
+  float d = D3DXVec3Length(pV);
+  if(d == 0 ){
+   pOut->x = 0;
+   pOut->y = 0;
+   pOut->z = 0;   
+  }else{
+    return D3DXVec3Scale(pOut, pV, 1.0f/d);
+  }
+  return pOut;
+}
+
+
+float D3DXVec3Length(CONST D3DXVECTOR3 *pV){
+   return sqrt(pV->x * pV->y + pV->x * pV->x + pV->z * pV->z);
+}
+
+
+float D3DXVec3LengthSq(CONST D3DXVECTOR3 *pV){
+   return pV->x * pV->y + pV->x * pV->x + pV->z * pV->z;
+}
+
+float D3DXVec2Length(CONST D3DXVECTOR2 *pV){
+   return sqrt(pV->x * pV->y + pV->x * pV->x);
+}
+
+
+float D3DXVec2LengthSq(CONST D3DXVECTOR2 *pV){
+   return pV->x * pV->y + pV->x * pV->x;
+}
+
+float D3DXVec4Length(CONST D3DXVECTOR4 *pV){
+   return sqrt(pV->x * pV->y + pV->x * pV->x + pV->z * pV->z + pV->w * pV->w);
+}
+
+
+float D3DXVec4LengthSq(CONST D3DXVECTOR4 *pV){
+   return pV->x * pV->y + pV->x * pV->x + pV->z * pV->z + pV->w * pV->w;
+}
+
+
+
+D3DXVECTOR2 *D3DXVec2Scale(      
+    D3DXVECTOR2 *pOut,
+    CONST D3DXVECTOR2 *pV,
+    FLOAT s
+){
+
+  pOut->x = pV->x * s;
+  pOut->y = pV->y * s;  
+  
+  return pOut;
+}
+
+
+D3DXVECTOR3 *D3DXVec3Scale(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXVECTOR3 *pV,
+    FLOAT s
+){
+
+  pOut->x = pV->x * s;
+  pOut->y = pV->y * s;
+  pOut->z = pV->z * s;
+  
+  return pOut;
+}
+
+
+
+D3DXVECTOR4 *D3DXVec4Scale(      
+    D3DXVECTOR4 *pOut,
+    CONST D3DXVECTOR4 *pV,
+    FLOAT s
+){
+
+  pOut->x = pV->x * s;
+  pOut->y = pV->y * s;
+  pOut->z = pV->z * s;
+  pOut->w = pV->w * s;  
+  
+  return pOut;
+}
+
+
+D3DXVECTOR2 *D3DXVec2Add(      
+    D3DXVECTOR2 *pOut,
+    CONST D3DXVECTOR2 *pV1,
+    CONST D3DXVECTOR2 *pV2
+){
+
+   pOut->x = pV1->x + pV2->x;
+   pOut->y = pV1->y + pV2->y;
+   return pOut;
+}
+
+
+D3DXVECTOR3 *D3DXVec3Add(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2
+){
+
+   pOut->x = pV1->x + pV2->x;
+   pOut->y = pV1->y + pV2->y;
+   pOut->z = pV1->z + pV2->z;
+   return pOut;
+}
+
+
+D3DXVECTOR4 *D3DXVec4Add(      
+    D3DXVECTOR4 *pOut,
+    CONST D3DXVECTOR4 *pV1,
+    CONST D3DXVECTOR4 *pV2
+){
+
+   pOut->x = pV1->x + pV2->x;
+   pOut->y = pV1->y + pV2->y;
+   pOut->z = pV1->z + pV2->z;
+   pOut->w = pV1->w + pV2->w;
+   return pOut;
+}
+
+
+D3DXVECTOR3 *D3DXVec3Cross(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2
+){
+   /* MSDN says not MATRIX[3,3] = v[3,1]a * v[3,1]b */
+   pOut->x = pV1->y * pV2->z - pV1->z * pV2->y;
+   pOut->y = pV1->z * pV2->x - pV1->x * pV2->z;
+   pOut->z = pV1->x * pV2->y - pV1->y * pV2->x;
+   return pOut;
+}
+
+
+D3DXVECTOR4 *WINAPI D3DXVec4Cross(      
+    D3DXVECTOR4 *pOut,
+    CONST D3DXVECTOR4 *pV1,
+    CONST D3DXVECTOR4 *pV2,
+    CONST D3DXVECTOR4 *pV3
+){
+/*MSDN doesn't give any clues to what they mean by this 'cross' product*/
+/*
+| X   Y   Z  T |
+| Ux Uy  Uz Ut |
+| Vx Vy  Vz Vt |
+| Wx Wy  Wz Wt |
+
+   pOut->_1 = 
+   pOut->_2 = 
+   pOut->_3 = 
+   pOut->_4 = 
+   */
+   
+   FIXME("stub\n");
+   return pOut;
+}
+
+
+
+/*http://mathworld.wolfram.com/DotProduct.html*/
+FLOAT D3DXVec2Dot(      
+    CONST D3DXVECTOR2 *pV1,
+    CONST D3DXVECTOR2 *pV2
+){
+   return pV1->x * pV2->x + pV1->y * pV2->y;
+}
+
+FLOAT D3DXVec3Dot(      
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2
+){
+   return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
+}
+
+
+FLOAT D3DXVec4Dot(      
+    CONST D3DXVECTOR4 *pV1,
+    CONST D3DXVECTOR4 *pV2
+){
+   return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
+}
+
+
+
+D3DXVECTOR2 *D3DXVec2Subtract(      
+    D3DXVECTOR2 *pOut,
+    CONST D3DXVECTOR2 *pV1,
+    CONST D3DXVECTOR2 *pV2
+){
+   pOut->x = pV1->x - pV2->x;
+   pOut->y = pV1->y - pV2->y;
+   return pOut;
+}
+
+
+D3DXVECTOR3 *D3DXVec3Subtract(      
+    D3DXVECTOR3 *pOut,
+    CONST D3DXVECTOR3 *pV1,
+    CONST D3DXVECTOR3 *pV2
+){
+
+   pOut->x = pV1->x - pV2->x;
+   pOut->y = pV1->y - pV2->y;
+   pOut->z = pV1->z - pV2->z;
+   return pOut;
+}
+
+
+D3DXVECTOR4 *D3DXVec4Subtract(
+    D3DXVECTOR4 *pOut,
+    CONST D3DXVECTOR4 *pV1,
+    CONST D3DXVECTOR4 *pV2
+){
+
+   pOut->x = pV1->x - pV2->x;
+   pOut->y = pV1->y - pV2->y;
+   pOut->z = pV1->z - pV2->z;
+   pOut->w = pV1->w - pV2->w;
+   return pOut;
+}
diff -urN wine.20050419/dlls/d3dx9/d3dx9core_private.h wine.20050419.dx9/dlls/d3dx9/d3dx9core_private.h
--- wine.20050419/dlls/d3dx9/d3dx9core_private.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/d3dx9core_private.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,97 @@
+/*
+ * Direct3D X 8 private include file
+ *
+ * Copyright 2002 Raphael Junqueira
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __WINE_D3DX8CORE_PRIVATE_H
+#define __WINE_D3DX8CORE_PRIVATE_H
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "d3dx9core.h"
+
+/* Interfaces */
+typedef struct ID3DXBufferImpl ID3DXBufferImpl;
+typedef struct ID3DXFontImpl   ID3DXFontImpl;
+
+/* ----------- */
+/* ID3DXBuffer */
+/* ----------- */
+
+/*****************************************************************************
+ * Predeclare the interface implementation structures
+ */
+extern ID3DXBufferVtbl D3DXBuffer_Vtbl;
+
+
+/*****************************************************************************
+ * ID3DXBufferImpl implementation structure
+ */
+struct ID3DXBufferImpl
+{
+  /* IUnknown fields */
+  ID3DXBufferVtbl *lpVtbl;
+  DWORD          ref;
+
+  /* ID3DXBuffer fields */
+  DWORD         *buffer;
+  DWORD          bufferSize;
+};
+
+/* IUnknown: */
+extern HRESULT WINAPI ID3DXBufferImpl_QueryInterface(LPD3DXBUFFER iface, REFIID refiid, LPVOID *obj);
+extern ULONG WINAPI   ID3DXBufferImpl_AddRef(LPD3DXBUFFER iface);
+extern ULONG WINAPI   ID3DXBufferImpl_Release(LPD3DXBUFFER iface);
+
+/* ID3DXBuffer: */
+extern LPVOID WINAPI ID3DXBufferImpl_GetBufferPointer(LPD3DXBUFFER iface);
+extern DWORD WINAPI  ID3DXBufferImpl_GetBufferSize(LPD3DXBUFFER iface);
+
+/* --------- */
+/* ID3DXFont */
+/* --------- */
+
+/*****************************************************************************
+ * Predeclare the interface implementation structures
+ */
+extern ID3DXFontVtbl D3DXFont_Vtbl;
+
+/*****************************************************************************
+ * ID3DXFontImpl implementation structure
+ */
+struct ID3DXFontImpl
+{
+  /* IUnknown fields */
+  ID3DXFontVtbl *lpVtbl;
+  DWORD          ref;
+
+  /* ID3DXFont fields */
+  LPDIRECT3DDEVICE9 device;
+};
+
+/* IUnknown: */
+extern HRESULT WINAPI ID3DXFontImpl_QueryInterface(LPD3DXFONT iface, REFIID refiid, LPVOID *obj);
+extern ULONG WINAPI   ID3DXFontImpl_AddRef(LPD3DXFONT iface);
+extern ULONG WINAPI   ID3DXFontImpl_Release(LPD3DXFONT iface);
+
+/* ID3DXFont: */
+/*extern INT WINAPI     ID3DXFontImpl_DrawTextA(LPCSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color); */
+
+#endif /*__WINE_D3DX8CORE_PRIVATE_H */
diff -urN wine.20050419/dlls/d3dx9/d3dxbuffer.c wine.20050419.dx9/dlls/d3dx9/d3dxbuffer.c
--- wine.20050419/dlls/d3dx9/d3dxbuffer.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/d3dxbuffer.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,87 @@
+/*
+ * ID3DXBuffer implementation
+ *
+ * Copyright 2002 Raphael Junqueira
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "wingdi.h"
+#include "wine/debug.h"
+
+#include "d3d9.h"
+#include "d3dx9core_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+
+/* ID3DXBuffer IUnknown parts follow: */
+HRESULT WINAPI ID3DXBufferImpl_QueryInterface(LPD3DXBUFFER iface, REFIID riid, LPVOID* ppobj) {
+  ID3DXBufferImpl *This = (ID3DXBufferImpl *)iface;
+  
+  if (IsEqualGUID(riid, &IID_IUnknown)
+      || IsEqualGUID(riid, &IID_ID3DXBuffer)) {
+    ID3DXBufferImpl_AddRef(iface);
+    *ppobj = This;
+    return D3D_OK;
+  }
+
+  WARN("(%p)->(%s,%p),not found\n",This,debugstr_guid(riid),ppobj);
+  return E_NOINTERFACE;
+}
+
+ULONG WINAPI ID3DXBufferImpl_AddRef(LPD3DXBUFFER iface) {
+  ID3DXBufferImpl *This = (ID3DXBufferImpl *)iface;
+  TRACE("(%p) : AddRef from %ld\n", This, This->ref);
+  return ++(This->ref);
+}
+
+ULONG WINAPI ID3DXBufferImpl_Release(LPD3DXBUFFER iface) {
+  ID3DXBufferImpl *This = (ID3DXBufferImpl *)iface;
+  ULONG ref = --This->ref;
+  TRACE("(%p) : ReleaseRef to %ld\n", This, This->ref);
+  if (ref == 0) {
+    HeapFree(GetProcessHeap(), 0, This->buffer);
+    HeapFree(GetProcessHeap(), 0, This);
+  }
+  return ref;
+}
+
+/* ID3DXBuffer Interface follow: */
+LPVOID WINAPI ID3DXBufferImpl_GetBufferPointer(LPD3DXBUFFER iface) {
+  ID3DXBufferImpl *This = (ID3DXBufferImpl *)iface;
+  return This->buffer;
+}
+
+DWORD WINAPI ID3DXBufferImpl_GetBufferSize(LPD3DXBUFFER iface) {
+  ID3DXBufferImpl *This = (ID3DXBufferImpl *)iface;
+  return This->bufferSize;
+}
+
+ID3DXBufferVtbl D3DXBuffer_Vtbl =
+{
+    ID3DXBufferImpl_QueryInterface,
+    ID3DXBufferImpl_AddRef,
+    ID3DXBufferImpl_Release,
+    ID3DXBufferImpl_GetBufferPointer,
+    ID3DXBufferImpl_GetBufferSize
+};
diff -urN wine.20050419/dlls/d3dx9/font.c wine.20050419.dx9/dlls/d3dx9/font.c
--- wine.20050419/dlls/d3dx9/font.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/d3dx9/font.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,152 @@
+/*
+ * ID3DXfont implementation
+ *
+ * Copyright 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "wingdi.h"
+#include "wine/debug.h"
+
+#include "d3d9.h"
+#include "d3dx9core_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+
+/* ID3DXBuffer IUnknown parts follow: */
+HRESULT WINAPI ID3DXFontImpl_QueryInterface(LPD3DXFONT iface, REFIID riid, LPVOID* ppobj) {
+  ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+  
+  if (IsEqualGUID(riid, &IID_IUnknown)
+      || IsEqualGUID(riid, &IID_ID3DXBuffer)) {
+    ID3DXFontImpl_AddRef(iface);
+    *ppobj = This;
+    return D3D_OK;
+  }
+
+  WARN("(%p)->(%s,%p),not found\n",This,debugstr_guid(riid),ppobj);
+  return E_NOINTERFACE;
+}
+
+ULONG WINAPI ID3DXFontImpl_AddRef(LPD3DXFONT iface) {
+  ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+  TRACE("(%p) : AddRef from %ld\n", This, This->ref);
+  return ++(This->ref);
+}
+
+ULONG WINAPI ID3DXFontImpl_Release(LPD3DXFONT iface) {
+  ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+  ULONG ref = --This->ref;
+  TRACE("(%p) : ReleaseRef to %ld\n", This, This->ref);
+  if (ref == 0) {
+  /*TODO: relese the device if we have one*/
+    if(This->device != NULL){
+      IDirect3DDevice9_Release(This->device);
+    }
+    HeapFree(GetProcessHeap(), 0, This);
+  }
+  return ref;
+}
+
+
+
+/* ID3DXFont Interface follow: */
+
+
+HRESULT WINAPI ID3DXFontImpl_GetDevice(LPD3DXFONT iface, LPDIRECT3DDEVICE9* ppDevice){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   TRACE("(%p) : rturning %p \n", This, This->device);
+   *ppDevice = This->device;   
+   IDirect3DDevice9_AddRef(*ppDevice);
+   return S_OK;
+}
+
+HRESULT WINAPI ID3DXFontImpl_GetLogFont(LPD3DXFONT iface, PLOGFONTA pLogFont){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   FIXME("(%p) : stub\n", This);
+   return D3D_OK;
+}
+
+HRESULT WINAPI ID3DXFontImpl_Begin(LPD3DXFONT iface){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   FIXME("(%p) : stub\n", This);
+   return D3D_OK;
+}
+
+INT WINAPI ID3DXFontImpl_DrawTextA(LPD3DXFONT iface, LPCSTR pString, INT Count,
+                                       LPRECT pRect, DWORD Format,  D3DCOLOR Color){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   /*IWineD3D needs to have a writeText function that just wraps up the openGl text functions*/
+   FIXME("(%p) : stub\n", This);
+   return D3D_OK;
+}
+
+INT WINAPI ID3DXFontImpl_DrawTextW(LPD3DXFONT iface, LPCWSTR pString, INT Count,
+                                       LPRECT pRect, DWORD Format,  D3DCOLOR Color){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   /*IWineD3D needs to have a writeText function that just wraps up the openGl text functions*/
+   FIXME("(%p) : stub\n", This);
+   return D3D_OK;
+}
+
+
+
+HRESULT WINAPI ID3DXFontImpl_End(LPD3DXFONT iface){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   FIXME("(%p) : stub\n", This);
+   return D3D_OK;
+}
+
+
+HRESULT WINAPI ID3DXFontImpl_OnLostDevice(LPD3DXFONT iface){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   FIXME("(%p) : stub\n", This);
+   return S_OK;
+}
+
+HRESULT WINAPI ID3DXFontImpl_OnResetDevice(LPD3DXFONT iface){
+   ID3DXFontImpl *This = (ID3DXFontImpl *)iface;
+   FIXME("(%p) : stub\n", This);
+   return S_OK;
+}
+
+
+
+
+
+ID3DXFontVtbl D3DXFont_Vtbl =
+{
+    ID3DXFontImpl_QueryInterface,
+    ID3DXFontImpl_AddRef,
+    ID3DXFontImpl_Release,
+    ID3DXFontImpl_GetDevice,
+    ID3DXFontImpl_GetLogFont,
+    ID3DXFontImpl_Begin,
+    ID3DXFontImpl_DrawTextA,
+    ID3DXFontImpl_DrawTextW,
+    ID3DXFontImpl_End,    
+    ID3DXFontImpl_OnLostDevice,
+    ID3DXFontImpl_OnResetDevice
+   
+};
diff -urN wine.20050419/dlls/ddraw/ddraw/user.c wine.20050419.dx9/dlls/ddraw/ddraw/user.c
--- wine.20050419/dlls/ddraw/ddraw/user.c	2005-03-07 04:01:10.000000000 -0700
+++ wine.20050419.dx9/dlls/ddraw/ddraw/user.c	2005-04-20 06:35:28.000000000 -0600
@@ -162,8 +162,8 @@
     This->caps.dwCKeyCaps |= CKEY_CAPS;
     This->caps.dwFXCaps |= FX_CAPS;
     This->caps.dwPalCaps |= DDPCAPS_8BIT | DDPCAPS_PRIMARYSURFACE;
-    This->caps.dwVidMemTotal = 16*1024*1024;
-    This->caps.dwVidMemFree = 16*1024*1024;
+    This->caps.dwVidMemTotal = 96*1024*1024;
+    This->caps.dwVidMemFree = 80*1024*1024;
     This->caps.dwSVBCaps |= BLIT_CAPS;
     This->caps.dwSVBCKeyCaps |= CKEY_CAPS;
     This->caps.dwSVBFXCaps |= FX_CAPS;
diff -urN wine.20050419/dlls/wined3d/Makefile.in wine.20050419.dx9/dlls/wined3d/Makefile.in
--- wine.20050419/dlls/wined3d/Makefile.in	2005-03-03 06:57:15.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/Makefile.in	2005-04-20 01:52:56.000000000 -0600
@@ -5,7 +5,7 @@
 MODULE    = wined3d.dll
 IMPORTS   = user32 gdi32 advapi32 kernel32
 EXTRAINCL = @X_CFLAGS@
-EXTRALIBS = -ldxguid -luuid @X_LIBS@ @X_PRE_LIBS@ @XLIB@ @X_EXTRA_LIBS@ @OPENGL_LIBS@
+EXTRALIBS = -luuid @X_LIBS@ @X_PRE_LIBS@ @XLIB@ @X_EXTRA_LIBS@ @OPENGL_LIBS@
 
 C_SRCS = \
 	basetexture.c \
@@ -14,10 +14,12 @@
 	directx.c \
 	drawprim.c \
 	indexbuffer.c \
+	pixelshader.c \
 	query.c \
 	resource.c \
 	stateblock.c \
 	surface.c \
+	swapchain.c \
 	texture.c \
 	utils.c \
 	vertexbuffer.c \
diff -urN wine.20050419/dlls/wined3d/cubetexture.c wine.20050419.dx9/dlls/wined3d/cubetexture.c
--- wine.20050419/dlls/wined3d/cubetexture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/cubetexture.c	2005-04-20 05:17:56.000000000 -0600
@@ -75,7 +75,7 @@
     TRACE("(%p) : Releasing from %ld\n", This, This->resource.ref);
     ref = InterlockedDecrement(&This->resource.ref);
     if (ref == 0) {
-        int i,j;
+        int i,j;        
         for (i = 0; i < This->baseTexture.levels; i++) {
           for (j = 0; j < 6; j++) { 
             if (This->surfaces[j][i] != NULL) {
@@ -84,7 +84,12 @@
             }
           }
         }
-        IWineD3DBaseTextureImpl_CleanUp((IWineD3DBaseTexture *) iface);
+        if(This->baseTexture.textureName != 0){
+            ENTER_GL();
+            TRACE("Deleting texture %d\n", This->baseTexture.textureName);
+            glDeleteTextures(1, &This->baseTexture.textureName);
+            LEAVE_GL(); 
+        }
         HeapFree(GetProcessHeap(), 0, This);
     } else {
         IUnknown_Release(This->resource.parent);  /* Released the reference to the d3dx object */
@@ -127,18 +132,32 @@
     TRACE("(%p) : About to load texture: dirtified(%d)\n", This, This->baseTexture.dirty);
 
     IWineD3DCubeTexture_BindTexture(iface);
-        
-    ENTER_GL();
-    /* If were dirty then reload the surfaces */
-    if(This->baseTexture.dirty != FALSE) {
-        for (i = 0; i < This->baseTexture.levels; i++) {
-          for (j = 0; j < 6; j++)
-              IWineD3DSurface_LoadTexture((IWineD3DSurface *) This->surfaces[j][i], cube_targets[j], i);
+    #if 0 /* TODO: context manager support */
+     IWineD3DContextManager_PushState(This->contextManager, GL_TEXTURE_CUBE_MAP_ARB, ENABLED, NOW /* make sure the state is applied now */);
+    #else    
+    glEnable(GL_TEXTURE_CUBE_MAP_ARB);
+    #endif    
+    /* TODO: remove the use of (IWineD3DSurfaceImpl *)
+    *  (put the texturename in the cubetexture!)
+    */
+    for (i = 0; i < This->baseTexture.levels; i++) {
+      if (i == 0 && This->baseTexture.textureName != 0 && This->baseTexture.dirty == FALSE) {
+
+        glBindTexture(GLTEXTURECUBEMAP, This->baseTexture.textureName);
+        TRACE("Texture %p given name %d\n", This,  This->baseTexture.textureName);
+          if (This->baseTexture.textureName == 0) {
+            glGenTextures(1, &This->baseTexture.textureName);
+            TRACE("Texture %p given name %d\n", This, This->baseTexture.textureName);
+            glBindTexture(GLTEXTURECUBEMAP, This->baseTexture.textureName);
+	   }
         }
         /* No longer dirty */
         This->baseTexture.dirty = FALSE;
     }
     LEAVE_GL();
+    #if 0 /* TODO: context manager support */
+     IWineD3DContextManager_PopState(This->contextManager, GL_TEXTURE_CUBE_MAP_ARB, DISABLED, DELAYED);
+    #endif   
     return ;
 }
 
@@ -304,3 +323,4 @@
     IWineD3DCubeTextureImpl_UnlockRect,
     IWineD3DCubeTextureImpl_AddDirtyRect
 };
+
diff -urN wine.20050419/dlls/wined3d/device.c wine.20050419.dx9/dlls/wined3d/device.c
--- wine.20050419/dlls/wined3d/device.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/device.c	2005-04-20 05:31:50.000000000 -0600
@@ -21,14 +21,46 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+
 #include "config.h"
 #include "wined3d_private.h"
 
+/* TODO: repalce with iface usage! NOTE: this macro is used by other macros such as GL_SUPPORT */
+#if 0
+#define GLINFO_LOCATION  (IWineD3D_GetGlInfo(This->wineD3D))
+#else
+#define GLINFO_LOCATION ((IWineD3DImpl *)(This->wineD3D))->gl_info
+#endif
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
-WINE_DECLARE_DEBUG_CHANNEL(d3d_caps);
-WINE_DECLARE_DEBUG_CHANNEL(d3d_fps);
 WINE_DECLARE_DEBUG_CHANNEL(d3d_shader);
-#define GLINFO_LOCATION ((IWineD3DImpl *)(This->wineD3D))->gl_info
+WINE_DECLARE_DEBUG_CHANNEL(d3d_surface);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_timings);
+
+/* x11drv GDI escapes */
+#define X11DRV_ESCAPE 6789
+enum x11drv_escape_codes
+{
+    X11DRV_GET_DISPLAY,   /* get X11 display for a DC */
+    X11DRV_GET_DRAWABLE,  /* get current drawable for a DC */
+    X11DRV_GET_FONT,      /* get current X font for a DC */
+};
+
+/* retrieve the X display to use on a given DC */
+inline static Display *get_display( HDC hdc )
+{
+    Display *display;
+    enum x11drv_escape_codes escape = X11DRV_GET_DISPLAY;
+
+    if (!ExtEscape( hdc, X11DRV_ESCAPE, sizeof(escape), (LPCSTR)&escape,
+                    sizeof(display), (LPSTR)&display )) display = NULL;
+    return display;
+}
+
+
+/* Memory tracking and object counting */
+ int emmulated_textureram = 256*1024*1024;
+
+
 
 /* helper macros */
 #define D3DMEMCHECK(object, ppResult) if(NULL == object){ *ppResult = NULL; WARN("Out of memory\n"); return D3DERR_OUTOFVIDEOMEMORY;}
@@ -80,7 +112,7 @@
     float colRGBA[] = {0.0, 0.0, 0.0, 0.0};
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
-    /* Light settings are affected by the model view in OpenGL, the View transform in direct3d*/
+    /* Light settings are affected by the model view in OpenGL, the View transform in direct3d */
     glMatrixMode(GL_MODELVIEW);
     glPushMatrix();
     glLoadMatrixf((float *) &This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
@@ -170,7 +202,7 @@
     BOOL changeTexture = TRUE;
 
     TRACE("-----------------------> Updating the texture at stage %ld to have new texture state information\n", Stage);
-    for (i = 1; i < HIGHEST_TEXTURE_STATE; i++) {
+    for (i = 1; i <= HIGHEST_TEXTURE_STATE; i++) {
 
         BOOL skip = FALSE;
 
@@ -186,21 +218,21 @@
            skip = TRUE;
            break;
 
-        /* Performance: If the texture states only impact settings for the texture unit 
+        /* Performance: If the texture states only impact settings for the texture unit
              (compared to the texture object) then there is no need to reapply them. The
-             only time they need applying is the first time, since we cheat and put the  
-             values into the stateblock without applying.                                
+             only time they need applying is the first time, since we cheat and put the
+             values into the stateblock without applying.
              Per-texture unit: texture function (eg. combine), ops and args
-                               texture env color                                               
-                               texture generation settings                               
+                               texture env color
+                               texture generation settings
            Note: Due to some special conditions there may be a need to do particular ones
              of these, which is what the Flags allows                                     */
-        case D3DTSS_COLOROP:       
+        case D3DTSS_COLOROP:
         case D3DTSS_TEXCOORDINDEX:
             if (!(Flags == REAPPLY_ALL)) skip=TRUE;
             break;
 
-        case D3DTSS_ALPHAOP:       
+        case D3DTSS_ALPHAOP:
             if (!(Flags & REAPPLY_ALPHAOP)) skip=TRUE;
             break;
 
@@ -225,6 +257,9 @@
         }
     }
 
+    for (i = 1; i <= HIGHEST_SAMPLER_STATE;i++) {
+      IWineD3DDevice_SetSamplerState(iface, Stage, i, This->stateBlock->samplerState[Stage][i]);
+    }
     /* Note the D3DRS value applies to all textures, but GL has one
      *  per texture, so apply it now ready to be used!
      */
@@ -232,26 +267,23 @@
     glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, &col[0]);
     checkGLcall("glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color);");
 
-    TRACE("-----------------------> Updated the texture at stage %ld to have new texture state information\n", Stage);   
+    TRACE("-----------------------> Updated the texture at stage %ld to have new texture state information\n", Stage);
 }
 
 /**********************************************************
  * IUnknown parts follows
  **********************************************************/
-
-HRESULT WINAPI IWineD3DDeviceImpl_QueryInterface(IWineD3DDevice *iface,REFIID riid,LPVOID *ppobj)
+HRESULT WINAPI IWineD3DDeviceImpl_QueryInterface(IWineD3DDevice *iface, REFIID riid, LPVOID *ppobj)
 {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     /* FIXME: This needs to extend an IWineD3DBaseObject */
-    
     TRACE("(%p)->(%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    if (IsEqualGUID(riid, &IID_IUnknown)        
+    if (IsEqualGUID(riid, &IID_IUnknown)
         || IsEqualGUID(riid, &IID_IWineD3DDevice)) {
         IUnknown_AddRef(iface);
         *ppobj = This;
         return D3D_OK;
     }
-    
     return E_NOINTERFACE;
 }
 
@@ -263,21 +295,72 @@
     return refCount;
 }
 
+
 ULONG WINAPI IWineD3DDeviceImpl_Release(IWineD3DDevice *iface) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    ULONG refCount = InterlockedDecrement(&This->ref);
-
-    TRACE("(%p) : Releasing from %ld\n", This, refCount + 1);
-
+    ULONG refCount;
+    TRACE("(%p) : Releasing from %ld\n", This, This->ref);
+    refCount = InterlockedDecrement(&This->ref);
     if (!refCount) {
-        /* TODO: Clean up all the surfaces and textures! */
-        /* FIXME: Create targets and state blocks in d3d8 */        
-        if (((IWineD3DImpl *)This->wineD3D)->dxVersion > 8) { /*We don't create a state block in d3d8 yet*/
+        /* Clean up all the surfaces and textures! */
+        /* FIXME: Create targets and stablocks in d3d8 */
+        /* TODO: repalce impl usage with IWineD3D_GetVersion */
+        if (((IWineD3DImpl *)This->wineD3D)->dxVersion > 8) { /* We don't create a state block in d3d8 yet */
             /* NOTE: You must release the parent if the objects was created via a callback
+            * Some of thease objects are going to callback to the device and day that they have been relesed.
+            * I'm not sure what the best way to prevent a deadlock is, either tell the objets not to callback,
+            * tell the callback function not to do anything (this is better since it's internal to the device object)
+            * try to make the functions 100% atomic so that it doesn't matter (this is the best solution but trickier, and we'd also need more critical sections), because we should be using itterators on the collections so long as the itterators can cope we're ok?
             ** ***************************/
-            IWineD3DStateBlock_Release((IWineD3DStateBlock *)This->stateBlock);
+            /* Release all of the swapchains, except the implicite swapchain */
+            int i;
+            IUnknown* stencilBufferParent;
+            IUnknown* swapChainParent;
+
+            /* NOTE: Don't release swapchain 0 here, it's 'special' */
+            for(i = 1; i < This->numberOfSwapChains; i++){
+                /*  TODO: don't access swapchains[x] directly! */
+                IWineD3DSwapChain_Release(This->swapchains[i]);
+            }
+ 
+            /* Release the buffers (with sanity checks)*/
+            if(This->stencilBufferTarget != NULL && (IWineD3DSurface_Release(This->stencilBufferTarget) >0)){
+                if(This->depthStencilBuffer != This->stencilBufferTarget)
+                    FIXME("(%p) Something's still holding the depthStencilBuffer\n",This);
+            }
+
+            if(IWineD3DSurface_Release(This->renderTarget) >0){
+                 /* This check is a bit silly, itshould be in swapchain_release FIXME("(%p) Something's still holding the renderTarget\n",This); */
+            }
+
+            IWineD3DSurface_GetParent(This->depthStencilBuffer, &stencilBufferParent);
+            IUnknown_Release(stencilBufferParent);          /* once for the get parent */
+            if(IUnknown_Release(stencilBufferParent)  >0){  /* the second time for when it was created */
+                FIXME("(%p) Something's still holding the depthStencilBuffer\n",This);
+            }
+
+            /* Release the update stateblock */
+            if(IWineD3DStateBlock_Release((IWineD3DStateBlock *)This->updateStateBlock) > 0){
+                if(This->updateStateBlock != This->stateBlock)
+                    FIXME("(%p) Something's still holding the Update stateblock\n",This);
+            }
+
+            /* Release the stateblock */
+            if(IWineD3DStateBlock_Release((IWineD3DStateBlock *)This->stateBlock) > 0){
+                    FIXME("(%p) Something's still holding the Update stateblock\n",This);
+            }
+
+            /* Swapchain 0 is special because it's created in startup with a hanging parent, so we have to release it's parent now */
+            /*  TODO: don't access swapchains[x] directly!, check that there are no-more swapchains left for this device! */
+            IWineD3DSwapChain_GetParent(This->swapchains[0], &swapChainParent);
+            IUnknown_Release(swapChainParent);           /* once for the get parent */
+            if(IUnknown_Release(swapChainParent)  > 0){  /* the second time for when it was created */
+                FIXME("(%p) Something's still holding the implicite swapchain\n",This);
+            }
+
         }
         IWineD3D_Release(This->wineD3D);
+        TRACE("freed device  %p \n",This);
         HeapFree(GetProcessHeap(), 0, This);
     }
     return refCount;
@@ -293,14 +376,14 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexBuffer(IWineD3DDevice *iface, UINT Size, DWORD Usage, 
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexBuffer(IWineD3DDevice *iface, UINT Size, DWORD Usage,
                              DWORD FVF, D3DPOOL Pool, IWineD3DVertexBuffer** ppVertexBuffer, HANDLE *sharedHandle,
                              IUnknown *parent) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DVertexBufferImpl *object;
     WINED3DFORMAT Format = WINED3DFMT_VERTEXDATA; /* Dummy format for now */
     D3DCREATERESOURCEOBJECTINSTANCE(object, VertexBuffer, D3DRTYPE_VERTEXBUFFER)
-    
+
     object->resource.size             = Size;
     object->resource.allocatedMemory  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, object->resource.size);
     object->FVF                       = FVF;
@@ -311,20 +394,20 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateIndexBuffer(IWineD3DDevice *iface, UINT Length, DWORD Usage, 
+HRESULT WINAPI IWineD3DDeviceImpl_CreateIndexBuffer(IWineD3DDevice *iface, UINT Length, DWORD Usage,
                                                     WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DIndexBuffer** ppIndexBuffer,
                                                     HANDLE *sharedHandle, IUnknown *parent) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DIndexBufferImpl *object;
     TRACE("(%p) Creating index buffer\n", This);
-    
+
     /* Allocate the storage for the device */
     D3DCREATERESOURCEOBJECTINSTANCE(object,IndexBuffer,D3DRTYPE_INDEXBUFFER)
-    
+
     object->resource.size                   = Length;
     object->resource.allocatedMemory        = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,object->resource.size);
 
-    TRACE("(%p) : Len=%d, Use=%lx, Format=(%u,%s), Pool=%d - Memory@%p, Iface@%p\n", This, Length, Usage, Format, 
+    TRACE("(%p) : Len=%d, Use=%lx, Format=(%u,%s), Pool=%d - Memory@%p, Iface@%p\n", This, Length, Usage, Format,
                            debug_d3dformat(Format), Pool, object, object->resource.allocatedMemory);
     *ppIndexBuffer = (IWineD3DIndexBuffer *) object;
 
@@ -332,52 +415,142 @@
 }
 
 HRESULT WINAPI IWineD3DDeviceImpl_CreateStateBlock(IWineD3DDevice* iface, D3DSTATEBLOCKTYPE Type, IWineD3DStateBlock** ppStateBlock, IUnknown *parent) {
-  
+
     IWineD3DDeviceImpl     *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DStateBlockImpl *object;
+    unsigned int i;
+    unsigned int j;
 
     D3DCREATEOBJECTINSTANCE(object, StateBlock)
-    object->blockType     = Type; 
+    object->blockType     = Type;
 
     /* Special case - Used during initialization to produce a placeholder stateblock
           so other functions called can update a state block                         */
-    if (Type == (D3DSTATEBLOCKTYPE) 0) {
+    if (Type == (D3DSTATEBLOCKTYPE)0) {
         /* Don't bother increasing the reference count otherwise a device will never
-           be freed due to circular dependencies                                   */
+           be freed due to circular dependencies                                     */
         return D3D_OK;
     }
 
-    /* Otherwise, might as well set the whole state block to the appropriate values */
-    IWineD3DDevice_AddRef(iface);
-    memcpy(object, This->stateBlock, sizeof(IWineD3DStateBlockImpl));
-    FIXME("unfinished - needs to set up changed and set attributes\n");
-    return D3D_OK;
+    /* Otherwise, might as well set the whole state block to the appropriate values  */
+    /* don't do this it will overight ref count &co too!? */
+    if( This->stateBlock != NULL){
+       memcpy(object, This->stateBlock, sizeof(IWineD3DStateBlockImpl));
+    } else {
+       memset(object->streamFreq, 1, sizeof(object->streamFreq));
+    }
+
+    /* Reset the ref and type after kluging it */
+    object->wineD3DDevice = This;
+    object->ref           = 1;
+    object->blockType     = Type;
+
+    TRACE("Updating changed flags appropriate for type %d\n", Type);
+
+    if (Type == D3DSBT_ALL) {
+        TRACE("ALL => Pretend everything has changed\n");
+        memset(&object->changed, TRUE, sizeof(This->stateBlock->changed));
+    } else if (Type == D3DSBT_PIXELSTATE) {
+
+        memset(&object->changed, FALSE, sizeof(This->stateBlock->changed));
+        /* TODO: Pixel Shader Constants */
+        object->changed.pixelShader = TRUE;
+        for (i = 0; i < NUM_SAVEDPIXELSTATES_R; i++) {
+            object->changed.renderState[SavedPixelStates_R[i]] = TRUE;
+        }
+        for (j = 0; j < GL_LIMITS(textures); i++) {
+            for (i = 0; i < NUM_SAVEDPIXELSTATES_T; i++) {
+                object->changed.textureState[j][SavedPixelStates_T[i]] = TRUE;
+            }
+        }
+        FIXME("Setting sampler block changes states\n");
+        for (j = 0 ; j < 16; j++){
+            for (i =0; i < NUM_SAVEDPIXELSTATES_S;i++){
+
+                object->changed.samplerState[j][SavedPixelStates_S[i]] = TRUE;
+            }
+        }
+    } else if (Type == D3DSBT_VERTEXSTATE) {
+
+        memset(&object->changed, FALSE, sizeof(This->stateBlock->changed));
+
+        /* TODO: Vertex Shader Constants */
+        object->changed.vertexShader = TRUE;
+        for (i = 0; i < NUM_SAVEDVERTEXSTATES_R; i++) {
+            object->changed.renderState[SavedVertexStates_R[i]] = TRUE;
+        }
+        for (j = 0; j < GL_LIMITS(textures); i++) {
+            for (i = 0; i < NUM_SAVEDVERTEXSTATES_T; i++) {
+                object->changed.textureState[j][SavedVertexStates_T[i]] = TRUE;
+            }
+        }
+        FIXME("Setting sampler block changes states\n");
+        for (j = 0 ; j < 16; j++){
+            for (i =0; i < NUM_SAVEDVERTEXSTATES_S;i++){
+                object->changed.samplerState[j][SavedVertexStates_S[i]] = TRUE;
+            }
+        }
+
+    /* Duplicate light chain */
+    {
+        PLIGHTINFOEL *src = NULL;
+        PLIGHTINFOEL *dst = NULL;
+        PLIGHTINFOEL *newEl = NULL;
+        src = This->stateBlock->lights;
+        object->lights = NULL;
+
+
+        while (src) {
+            newEl = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PLIGHTINFOEL));
+            if (newEl == NULL) return D3DERR_OUTOFVIDEOMEMORY;
+            memcpy(newEl, src, sizeof(PLIGHTINFOEL));
+            newEl->prev = dst;
+            newEl->changed = TRUE;
+            newEl->enabledChanged = TRUE;
+            if (dst == NULL) {
+                object->lights = newEl;
+            } else {
+                dst->next = newEl;
+            }
+            dst = newEl;
+            src = src->next;
+        }
+
+     }
+
+    } else {
+        FIXME("Unrecognized state block type %d\n", Type);
 }
 
+    TRACE("(%p) returning token (ptr to stateblock) of %p\n", This, object);
+    return D3D_OK;
+}
 
 /* ************************************
 MSDN:
 [in] Render targets are not lockable unless the application specifies TRUE for Lockable. Note that lockable render targets reduce performance on some graphics hardware.
 
 Discard
- [in] Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise. 
+ [in] Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.
 
 If this flag is set, the contents of the depth stencil buffer will be invalid after calling either IDirect3DDevice9::Present or IDirect3DDevice9::SetDepthStencilSurface with a different depth surface.
 
 ******************************** */
- 
-HRESULT  WINAPI IWineD3DDeviceImpl_CreateSurface(IWineD3DDevice *iface, UINT Width, UINT Height, WINED3DFORMAT Format, BOOL Lockable, BOOL Discard, UINT Level, IWineD3DSurface **ppSurface,D3DRESOURCETYPE Type, DWORD Usage, D3DPOOL Pool, D3DMULTISAMPLE_TYPE MultiSample ,DWORD MultisampleQuality, HANDLE* pSharedHandle, IUnknown *parent) {
-    IWineD3DDeviceImpl  *This = (IWineD3DDeviceImpl *)iface;    
-    IWineD3DSurfaceImpl *object; /*NOTE: impl ref allowed since this is a create function */
-    unsigned int pow2Width, pow2Height;
 
+HRESULT  WINAPI IWineD3DDeviceImpl_CreateSurface(IWineD3DDevice *iface, UINT Width, UINT Height, WINED3DFORMAT Format, BOOL Lockable, BOOL Discard, UINT Level, IWineD3DSurface **ppSurface,D3DRESOURCETYPE Type, DWORD Usage, D3DPOOL Pool, D3DMULTISAMPLE_TYPE MultiSample ,DWORD MultisampleQuality, HANDLE* pSharedHandle, IUnknown *parent) {
+    IWineD3DDeviceImpl  *This = (IWineD3DDeviceImpl *)iface;
+    IWineD3DSurfaceImpl *object; /* NOTE: impl ref allowed since this is a create function */
+    unsigned int pow2Width  = Width;
+    unsigned int pow2Height = Height;
+    unsigned int pow2Size   = 1;
+    int surfacecount;
     TRACE("(%p) Create surface\n",This);
-    
-    /** FIXME: Check ranges on the inputs are valid 
+
+    /** FIXME: Check ranges on the inputs are valid
      * MSDN
      *   MultisampleQuality
      *    [in] Quality level. The valid range is between zero and one less than the level
-     *    returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType. 
+     *    returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType.
      *    Passing a larger value returns the error D3DERR_INVALIDCALL. The MultisampleQuality
      *    values of paired render targets, depth stencil surfaces, and the MultiSample type
      *    must all match.
@@ -386,7 +559,7 @@
 
     /**
     * TODO: Discard MSDN
-    * [in] Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise. 
+    * [in] Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.
     *
     * If this flag is set, the contents of the depth stencil buffer will be
     * invalid after calling either IDirect3DDevice9::Present or  * IDirect3DDevice9::SetDepthStencilSurface
@@ -394,44 +567,54 @@
     *
     *This flag has the same behavior as the constant, D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL, in D3DPRESENTFLAG.
     ***************************/
-  
-    if(MultisampleQuality < 0) { 
-        FIXME("Invalid multisample level %ld \n", MultisampleQuality);  
+
+    if(MultisampleQuality < 0) {
+        FIXME("Invalid multisample level %ld \n", MultisampleQuality);
         return D3DERR_INVALIDCALL; /* TODO: Check that this is the case! */
     }
-    
+
     if(MultisampleQuality > 0){
-        FIXME("MultisampleQuality set to %ld, bstituting 0  \n" , MultisampleQuality);  
+        FIXME("MultisampleQuality set to %ld, bstituting 0  \n" , MultisampleQuality);
         MultisampleQuality=0;
     }
 
     /* Non-power2 support */
+    /* Find the neriest pow2 match */
+    for(pow2Size = 1 ; pow2Size < Width ; pow2Size<<=1);
+      pow2Width = pow2Size;
 
-    /* Find the nearest pow2 match */
-    pow2Width = pow2Height = 1;
-    while (pow2Width < Width) pow2Width <<= 1;
-    while (pow2Height < Height) pow2Height <<= 1;
+    for(pow2Size = 1 ; pow2Size < Height ; pow2Size<<=1);
+      pow2Height = pow2Size;
 
-    /* TODO: support for non-power 2 textures */
     if(pow2Width > Width || pow2Height > Height){
         /** TODO: add support for non power two compressed textures (OpenGL provices support for * non-power-two textures gratis) **/
-        return D3DERR_NOTAVAILABLE;
+        if(Format == WINED3DFMT_DXT1 || Format == WINED3DFMT_DXT2 || Format == WINED3DFMT_DXT3
+           || Format == WINED3DFMT_DXT4 || Format == WINED3DFMT_DXT5){
+
+           FIXME("(%p) Compressed non-power-two textures are not supported w(%d) h(%d) \n",
+                 This, Width, Height);
+           return D3DERR_NOTAVAILABLE;
+        }
     }
 
-        
+
     /** TODO: Check against the maximum texture sizes supported by the video card **/
-    
+
     D3DCREATERESOURCEOBJECTINSTANCE(object,Surface,D3DRTYPE_SURFACE)
     object->container = (IUnknown*) This;
-            
+
     object->currentDesc.Width      = Width;
     object->currentDesc.Height     = Height;
     object->currentDesc.Level      = Level;
     object->currentDesc.MultiSampleType    = MultiSample;
     object->currentDesc.MultiSampleQuality = MultisampleQuality;
+    object->pow2Width  = pow2Width;
+    object->pow2Height = pow2Height;
+    object->nonpow2    = (pow2Width != Width || pow2Height != Height) ? TRUE : FALSE;
     object->discard    = Discard;
+    object->activeLock = FALSE;
     object->bytesPerPixel = D3DFmtGetBpp(This, Format);
-    
+
     /** DXTn mipmaps use the same number of 'levels' down to eg. 8x1, but since
      *  it is based around 4x4 pixel blocks it requires padding, so allocate enough
      *  space!
@@ -439,26 +622,32 @@
     if (Format == WINED3DFMT_DXT1) {
         /* DXT1 is half byte per pixel */
         object->resource.size = ((max(Width,4) * object->bytesPerPixel) * max(Height,4)) / 2;
-        
+
     } else if (Format == WINED3DFMT_DXT2 || Format == WINED3DFMT_DXT3 ||
                Format == WINED3DFMT_DXT4 || Format == WINED3DFMT_DXT5) {
         object->resource.size = ((max(Width,4) * object->bytesPerPixel) * max(Height,4));
     } else {
         object->resource.size = (Width * object->bytesPerPixel) * Height;
+        object->pow2Size         = (pow2Width * object->bytesPerPixel) * pow2Height;
     }
-    
+
+    /** FIXME: add support for real non-power-two if it's provided by the video card **/
+    /** TODO: change this into a texture transform matrix so that it's processed in hardware **/
+    /* Precalculated scaling for 'faked' non power of two texture coords */
+    object->pow2scalingFactorX  =  (((float)Width)  / ((float)pow2Width));
+    object->pow2scalingFactorY  =  (((float)Height) / ((float)pow2Height));
+    TRACE(" xf(%f) yf(%f) \n",     object->pow2scalingFactorX,     object->pow2scalingFactorY);
+
     TRACE("Pool %d %d %d %d",Pool, D3DPOOL_DEFAULT, D3DPOOL_MANAGED, D3DPOOL_SYSTEMMEM);
 
-#if 0
-    /* TODO: Check that we have enough video ram left */
-    if(Pool == D3DPOOL_DEFAULT  && IWineD3DDevice_GetAvailableTextureMem(iface) <= object->currentDesc.Size){
+    /* Check that we have enough video ram left */
+    if(Pool == D3DPOOL_DEFAULT  && IWineD3DDevice_GetAvailableTextureMem(iface) <= object->resource.size){
         TRACE("Out of 'bogus' video memory\n");
         HeapFree(GetProcessHeap(),0,object);
         *ppSurface = NULL;
         return D3DERR_OUTOFVIDEOMEMORY;
     }
-#endif
-    
+
     /** Quick lockable sanity check TODO: remove this after surfaces, usage and locablility have been debugged properly
     * this function is too deap to need to care about things like this.
     * Levels need to be checked too, and possibly Type wince they all affect what can be done.
@@ -477,17 +666,17 @@
         if(Usage == D3DUSAGE_DYNAMIC) FIXME("Create surface called with a pool of MANAGED and a \
                                              Usage of DYNAMIC which are mutually exclusive, not doing \
                                              anything just telling you.\n");
-    break;    
-    case D3DPOOL_DEFAULT: /*TODO: Create offscreen plain can cause this check to fail..., find out if it should */
+    break;
+    case D3DPOOL_DEFAULT: /* TODO: Create offscreen plain can cause this check to fail..., find out if it should */
         if(!(Usage & D3DUSAGE_DYNAMIC) && !(Usage & D3DUSAGE_RENDERTARGET)
            && !(Usage && D3DUSAGE_DEPTHSTENCIL ) && Lockable == TRUE)
             FIXME("Creating a surface with a POOL of DEFAULT with Locable true, that doesn't specify DYNAMIC usage.\n");
     break;
-    default:     
+    default:
         FIXME("(%p) Unknown pool %d\n", This, Pool);
     break;
     };
-    
+
     if (Usage & D3DUSAGE_RENDERTARGET && Pool != D3DPOOL_DEFAULT){
         FIXME("Trying to create a render target that isn't in the default pool\n");
     }
@@ -495,19 +684,46 @@
 
     object->locked   = FALSE;
     object->lockable = (WINED3DFMT_D16_LOCKABLE == Format) ? TRUE : Lockable;
-    /* TODO: memory management */
+
+    /* Textures in the default pool only get allocated system ram if and when they are locked. */
+    if(Pool == D3DPOOL_DEFAULT){
+        object->resource.allocatedMemory = NULL;
+        /* Should we pre-load the surface now? */
+        globalChangeGlRam(object->resource.size);
+    }else{
     object->resource.allocatedMemory = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,object->resource.size);
     if(object->resource.allocatedMemory == NULL ) {
-        FIXME("Out of memory!\n");
-        HeapFree(GetProcessHeap(),0,object);
-        *ppSurface = NULL;
-        return D3DERR_OUTOFVIDEOMEMORY;
-    }
+            FIXME("Out of memory!\n");
+            HeapFree(GetProcessHeap(),0,object);
+            *ppSurface = NULL;
+            return D3DERR_OUTOFVIDEOMEMORY;
+        }
     
 
     IWineD3DSurface_CleanDirtyRect(*ppSurface);
-    TRACE("(%p) : w(%d) h(%d) fmt(%d,%s) lockable(%d) surf@%p, surfmem@%p, %d bytes\n",
-           This, Width, Height, Format, debug_d3dformat(Format),
+    }
+
+
+    /** TODO: change this to use the Devices resource store. **/
+    surfacecount = globalStoreSurface((IWineD3DSurface *)object);
+
+#ifdef USE_CONTEXT_MANAGER
+/* TODO: OpenGL context manager
+(this should happen in preload not here, a context manager could overload the vtable though  */
+    if(Usage & D3DUSAGE_RENDERTARGET){
+       /** render targets are special
+       *  because they can be render targets!
+       *  so forward the object onto the context manager to see if it wants do anything special
+       *  I think this only applies when the texture is loaded, not here
+       ************************************************/
+
+       IContextManager_CreateRenderTarget(This->contextManager, object);
+    }
+#endif
+  
+    IWineD3DSurface_CleanDirtyRect(*ppSurface);
+    TRACE("(%p) : number %d w(%d) h(%d) pow2w(%d) pow2h(%d) fmt(%d,%s) lockable(%d) surf@%p, surfmem@%p, %d bytes\n",
+           This, surfacecount, Width, Height, pow2Width, pow2Height, Format, debug_d3dformat(Format),
            (WINED3DFMT_D16_LOCKABLE == Format), *ppSurface, object->resource.allocatedMemory, object->resource.size);
     return D3D_OK;
 
@@ -516,22 +732,25 @@
 HRESULT  WINAPI IWineD3DDeviceImpl_CreateTexture(IWineD3DDevice *iface, UINT Width, UINT Height, UINT Levels,
                                                  DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool,
                                                  IWineD3DTexture** ppTexture, HANDLE* pSharedHandle, IUnknown *parent,
-                                                 D3DCB_CREATESURFACEFN D3DCB_CreateSurface) {
+                                                 D3DCB_CREATESURFACETFN D3DCB_CreateSurface) {
 
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    IWineD3DTextureImpl *object;    
+    IWineD3DTextureImpl *object;
+    DWORD startTime = 0;
     unsigned int i;
+    int texturecount;
     UINT tmpW;
     UINT tmpH;
     HRESULT hr;
-
     TRACE("(%p), Width(%d) Height(%d) Levels(%d) Usage(%ld) .... \n", This, Width, Height, Levels, Usage);
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
 
     D3DCREATERESOURCEOBJECTINSTANCE(object, Texture, D3DRTYPE_TEXTURE);
     D3DINITILIZEBASETEXTURE(object->baseTexture);    
     object->width  = Width;
     object->height = Height;
-    
+    object->resource.pool   = Pool;
     /* Calculate levels for mip mapping */
     if (Levels == 0) {
         TRACE("calculating levels %d\n", object->baseTexture.levels);
@@ -545,11 +764,11 @@
         }
         TRACE("Calculated levels = %d\n", object->baseTexture.levels);
     }
-    
+
     /* Generate all the surfaces */
     tmpW = Width;
     tmpH = Height;
-    for (i = 0; i < object->baseTexture.levels; i++) 
+    for (i = 0; i < object->baseTexture.levels; i++)
     {
         /* use the callback to create the texture surface */
         hr = D3DCB_CreateSurface(This->parent, tmpW, tmpH, Format, Usage, Pool, i, &object->surfaces[i],NULL);
@@ -566,42 +785,45 @@
             *ppTexture = NULL;
             return hr;
         }
-        
+
         IWineD3DSurface_SetContainer(object->surfaces[i], (IUnknown *)object);
         TRACE("Created surface level %d @ %p\n", i, object->surfaces[i]);
         /* calculate the next mipmap level */
         tmpW = max(1, tmpW >> 1);
         tmpH = max(1, tmpH >> 1);
     }
-    
-    TRACE("(%p) : Created  texture %p\n", This, object);
+    texturecount = globalStoreTexture((IWineD3DBaseTexture *)object);
+    TRACE("(%p) : Created  texture %d %p\n", This, texturecount, object);
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVolumeTexture(IWineD3DDevice *iface, 
-                                                      UINT Width, UINT Height, UINT Depth, 
-                                                      UINT Levels, DWORD Usage, 
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVolumeTexture(IWineD3DDevice *iface,
+                                                      UINT Width, UINT Height, UINT Depth,
+                                                      UINT Levels, DWORD Usage,
                                                       WINED3DFORMAT Format, D3DPOOL Pool, 
                                                       IWineD3DVolumeTexture** ppVolumeTexture,
                                                       HANDLE* pSharedHandle, IUnknown *parent,
                                                       D3DCB_CREATEVOLUMEFN D3DCB_CreateVolume) {
-
     IWineD3DDeviceImpl        *This = (IWineD3DDeviceImpl *)iface;
-    IWineD3DVolumeTextureImpl *object;
+    IWineD3DVolumeTextureImpl *object; /** NOTE: impl ref allowed since this is a create function **/
     unsigned int               i;
+    int                        texturecount;
     UINT                       tmpW;
     UINT                       tmpH;
     UINT                       tmpD;
 
     D3DCREATERESOURCEOBJECTINSTANCE(object, VolumeTexture, D3DRTYPE_VOLUMETEXTURE);
     D3DINITILIZEBASETEXTURE(object->baseTexture);
-    
+
     TRACE("(%p) : W(%d) H(%d) D(%d), Lvl(%d) Usage(%ld), Fmt(%u,%s), Pool(%s)\n", This, Width, Height,
           Depth, Levels, Usage, Format, debug_d3dformat(Format), debug_d3dpool(Pool));
 
     object->width  = Width;
     object->height = Height;
     object->depth  = Depth;
+    object->resource.pool   = Pool;
 
     /* Calculate levels for mip mapping */
     if (Levels == 0) {
@@ -623,10 +845,10 @@
     tmpH = Height;
     tmpD = Depth;
 
-    for (i = 0; i < object->baseTexture.levels; i++) 
+    for (i = 0; i < object->baseTexture.levels; i++)
     {
         /* Create the volume */
-        D3DCB_CreateVolume(This->parent, Width, Height, Depth, Format, Pool, Usage, 
+        D3DCB_CreateVolume(This->parent, Width, Height, Depth, Format, Pool, Usage,
                            (IWineD3DVolume **)&object->volumes[i], pSharedHandle);
         IWineD3DVolume_SetContainer(object->volumes[i], (IUnknown *)object);
 
@@ -636,13 +858,14 @@
     }
 
     *ppVolumeTexture = (IWineD3DVolumeTexture *) object;
-    TRACE("(%p) : Created volume texture %p\n", This, object);
+    texturecount = globalStoreTexture((IWineD3DBaseTexture *)object);
+    TRACE("(%p) : Created volume texture %d %p\n", This, texturecount, object);
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVolume(IWineD3DDevice *iface, 
-                                               UINT Width, UINT Height, UINT Depth, 
-                                               DWORD Usage, 
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVolume(IWineD3DDevice *iface,
+                                               UINT Width, UINT Height, UINT Depth,
+                                               DWORD Usage,
                                                WINED3DFORMAT Format, D3DPOOL Pool, 
                                                IWineD3DVolume** ppVolume,
                                                HANDLE* pSharedHandle, IUnknown *parent) {
@@ -670,16 +893,18 @@
     return IWineD3DVolume_CleanDirtyBox((IWineD3DVolume *) object);
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateCubeTexture(IWineD3DDevice *iface, UINT EdgeLength, 
-                                                    UINT Levels, DWORD Usage, 
+
+HRESULT WINAPI IWineD3DDeviceImpl_CreateCubeTexture(IWineD3DDevice *iface,  UINT EdgeLength,
+                                                    UINT Levels, DWORD Usage,
                                                     WINED3DFORMAT Format, D3DPOOL Pool, 
                                                     IWineD3DCubeTexture** ppCubeTexture,
                                                     HANDLE* pSharedHandle, IUnknown *parent,
-                                                    D3DCB_CREATESURFACEFN D3DCB_CreateSurface) {
+                                                    D3DCB_CREATESURFACETFN D3DCB_CreateSurface) {
 
    IWineD3DDeviceImpl      *This = (IWineD3DDeviceImpl *)iface;
    IWineD3DCubeTextureImpl *object; /** NOTE: impl ref allowed since this is a create function **/
    unsigned int             i,j;
+   int                      texturecount;
    UINT                     tmpW;
    HRESULT                  hr;
 
@@ -687,8 +912,9 @@
    D3DINITILIZEBASETEXTURE(object->baseTexture);
 
    TRACE("(%p) Create Cube Texture \n", This);
-   
+
    object->edgeLength           = EdgeLength;
+   object->resource.pool     = Pool;
 
    /* Calculate levels for mip mapping */
    if (Levels == 0) {
@@ -707,10 +933,10 @@
 
         /* Create the 6 faces */
         for (j = 0; j < 6; j++) {
-                            
+
             hr=D3DCB_CreateSurface(This->parent, tmpW, tmpW, Format, Usage, Pool,
                                    i /* Level */, &object->surfaces[j][i],pSharedHandle);
-        
+
             if(hr!= D3D_OK){
                 /* clean up */
                 int k;
@@ -735,14 +961,16 @@
         tmpW = max(1, tmpW >> 1);
     }
 
-    TRACE("(%p) : Created Cube Texture %p\n", This, object);
+    /** TODO: repalce globalStoreTexture with a device **/
+    texturecount = globalStoreTexture((IWineD3DBaseTexture *)object);
     *ppCubeTexture = (IWineD3DCubeTexture *) object;
+    TRACE("(%p) : Created Cube Texture %d %p\n", This, texturecount, object);
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateQuery(IWineD3DDevice *iface, WINED3DQUERYTYPE Type, IWineD3DQuery **ppQuery, IUnknown* parent){
+HRESULT WINAPI IWineD3DDeviceImpl_CreateQuery(IWineD3DDevice *iface, WINED3DQUERYTYPE Type, IWineD3DQuery** ppQuery, IUnknown* parent){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    IWineD3DQueryImpl *object; /*NOTE: impl ref allowed since this is a create function */
+    IWineD3DQueryImpl *object; /* NOTE: impl ref allowed since this is a create function */
 
     if(NULL == ppQuery){
         /* Just a check to see if we support this type of query */
@@ -766,7 +994,7 @@
             hr = D3D_OK;
         break;
         default:
-            FIXME("(%p) Unhandled query type %d\n",This , Type);       
+            FIXME("(%p) Unhandled query type %d\n",This , Type);
         }
         FIXME("(%p) : Stub request for query type %d returned %ld\n", This, Type, hr);
         return hr;
@@ -780,103 +1008,474 @@
 }
 
 /* example at http://www.fairyengine.com/articles/dxmultiviews.htm */
-HRESULT WINAPI IWineD3DDeviceImpl_CreateAdditionalSwapChain(IWineD3DDevice* iface, WINED3DPRESENT_PARAMETERS*  pPresentationParameters,                                                                   void** ppSwapChain,
+HRESULT WINAPI IWineD3DDeviceImpl_CreateAdditionalSwapChain(IWineD3DDevice* iface, WINED3DPRESENT_PARAMETERS*  pPresentationParameters,                                                                   IWineD3DSwapChain** ppSwapChain,
                                                             IUnknown* parent,
                                                             D3DCB_CREATERENDERTARGETFN D3DCB_CreateRenderTarget,
                                                             D3DCB_CREATEDEPTHSTENCILSURFACEFN D3DCB_CreateDepthStencil){
+
     IWineD3DDeviceImpl      *This = (IWineD3DDeviceImpl *)iface;
-    *ppSwapChain = NULL;
-    FIXME("(%p) : Stub\n",This);
+
+    HWND                    whichHWND;
+    HDC                     hDc;
+    IWineD3DSwapChainImpl  *object; /** NOTE: impl ref allowed since this is a create function **/
+    int                     num;
+    XVisualInfo             template;
+    GLXContext              oldContext;
+    Drawable                oldDrawable;
+    DWORD                   startTime = 0;
+
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
+
+
+    TRACE("(%p) : Created Aditional Swap Chain\n", This);
+
+   /** FIXME: Test under windows to find out what the life cycle of a swap chain is,
+   * does a device hold a reference to a swap chain giving them a lifetime of the device
+   * or does the swap chain notify the device of it'd destruction.
+    *******************************/
+
+    D3DCREATEOBJECTINSTANCE(object, SwapChain)
+
+    /* Initialize other useful values */
+    object->presentParms.BackBufferCount = 1; /* TODO:? support for gl_aux buffers */
+
+    /*********************
+    * Lookup the window Handle and the relating X window handel
+    ********************/
+
+    /* Setup hwnd we are using, plus which display this equates to */
+    whichHWND = *(pPresentationParameters->hDeviceWindow);
+    if(!whichHWND){
+        whichHWND = This->createParms.hFocusWindow;
+    }
+
+    object->win_handle = whichHWND;
+
+    object->win        = (Window)GetPropA( whichHWND, "__wine_x11_whole_window" );
+    hDc                = GetDC(whichHWND);
+    object->display    = get_display(hDc);
+    ReleaseDC(whichHWND, hDc);
+    TRACE("Using a dispaly of %p %p  \n", object->display, hDc);
+
+    /**
+    * Create an opengl context for the display visuial
+    *  NOTE: the visual is chosen as the window is created and the glcontext cannot
+    *     use different properties after that point in time. FIXME: How to handle when requested format
+    *     doesn't match actual visual? Cannot choose one here - code removed as it ONLY works if the one
+    *     it chooses is identical to the one already being used!
+     **********************************/
+
+    /** FIXME: Handle stencil appropriately via EnableAutoDepthStencil / AutoDepthStencilFormat **/
+    ENTER_GL();
+
+    /* Create a new context for this swapchain */
+
+    template.visualid = (VisualID)GetPropA(GetDesktopWindow(), "__wine_x11_visual_id");
+    object->visInfo   = XGetVisualInfo(object->display, VisualIDMask, &template, &num);
+    if (NULL == object->visInfo) {
+        ERR("cannot really get XVisual\n");
+        LEAVE_GL();
+        return D3DERR_NOTAVAILABLE;
+    }
+#ifdef USE_CONTEXT_MANAGER
+
+    /** TODO: use a context mamager **/
+#endif
+
+    /* The first time around we create the context that is shared with all other swapchians and render targets */
+    if(This->numberOfSwapChains == 0) {
+        object->glCtx = glXCreateContext(object->display, object->visInfo, NULL, GL_TRUE);
+        TRACE("Creating implicite context for vis %p, hwnd %p\n", object->display, object->visInfo);
+    }else{
+        IWineD3DSwapChain *implSwapChain;
+        TRACE("Creating context for vis %p, hwnd %p\n", object->display, object->visInfo);
+        /* TODO: don't use Impl structures outside of create functions! (a context manager will replace the ->glCtx) */
+        IWineD3DDevice_GetSwapChain(iface, 0 ,&implSwapChain);
+        object->glCtx = glXCreateContext(object->display, object->visInfo, ((IWineD3DSwapChainImpl *)implSwapChain)->glCtx, GL_TRUE);
+        IWineD3DSwapChain_Release(implSwapChain);
+    }
+    if (NULL == object->glCtx) {
+        ERR("cannot create glxContext\n");
+        LEAVE_GL();
+        return D3DERR_NOTAVAILABLE;
+    }
+
+    LEAVE_GL();
+    if (object->glCtx == NULL) {
+        ERR("Error in context creation !\n");
+        return D3DERR_INVALIDCALL;
+    } else {
+        TRACE("Context created (HWND=%p, glContext=%p, Window=%ld, VisInfo=%p)\n",
+                whichHWND, object->glCtx, object->win, object->visInfo);
+    }
+
+   /*********************
+   * Windowed / Fullscreen
+   *******************/
+
+   /**
+   * TODO: MSDNsays that we are only allowed one fullscreen swapchain per device,
+   * so we should really check to see if their is a fullscreen swapchain already
+   * I think Windows and X have differnt ideas about fullscreen, does a single head count as full screen?
+    **************************************/
+
+   if (!*(pPresentationParameters->Windowed)) {
+
+        DEVMODEW devmode;
+        HDC      hdc;
+        int      bpp = 0;
+
+        /* Get info on the current display setup */
+        hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
+        bpp = GetDeviceCaps(hdc, BITSPIXEL);
+        DeleteDC(hdc);
+
+        /* Change the display settings */
+        memset(&devmode, 0, sizeof(DEVMODEW));
+        devmode.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
+        devmode.dmBitsPerPel = (bpp >= 24) ? 32 : bpp; /* Stupid XVidMode cannot change bpp */
+        devmode.dmPelsWidth  = *(pPresentationParameters->BackBufferWidth);
+        devmode.dmPelsHeight = *(pPresentationParameters->BackBufferHeight);
+        MultiByteToWideChar(CP_ACP, 0, "Gamers CG", -1, devmode.dmDeviceName, CCHDEVICENAME);
+        ChangeDisplaySettingsExW(devmode.dmDeviceName, &devmode, object->win_handle, CDS_FULLSCREEN, NULL);
+
+        /* Make popup window */
+        SetWindowLongA(whichHWND, GWL_STYLE, WS_POPUP);
+        SetWindowPos(object->win_handle, HWND_TOP, 0, 0,
+                     *(pPresentationParameters->BackBufferWidth),
+                     *(pPresentationParameters->BackBufferHeight), SWP_SHOWWINDOW | SWP_FRAMECHANGED);
+
+
+    }
+
+
+    /** MSDN: If Windowed is TRUE and either of the BackBufferWidth/Height values is zero,
+     *  then the corresponding dimension of the client area of the hDeviceWindow
+     *  (or the focus window, if hDeviceWindow is NULL) is taken.
+      **********************/
+
+    if (*(pPresentationParameters->Windowed) &&
+        ((*(pPresentationParameters->BackBufferWidth)  == 0) ||
+         (*(pPresentationParameters->BackBufferHeight) == 0))) {
+
+        RECT Rect;
+        GetClientRect(whichHWND, &Rect);
+
+        if (*(pPresentationParameters->BackBufferWidth) == 0) {
+           *(pPresentationParameters->BackBufferWidth) = Rect.right;
+           TRACE("Updating width to %d\n", *(pPresentationParameters->BackBufferWidth));
+        }
+        if (*(pPresentationParameters->BackBufferHeight) == 0) {
+           *(pPresentationParameters->BackBufferHeight) = Rect.bottom;
+           TRACE("Updating height to %d\n", *(pPresentationParameters->BackBufferHeight));
+        }
+    }
+
+   /*********************
+   * finish off parameter initilazation
+   *******************/
+
+    /* Put the correct figures in the presentation parameters */
+    TRACE("Coppying accross presentaion paraneters\n");
+    object->presentParms.BackBufferWidth                = *(pPresentationParameters->BackBufferWidth);
+    object->presentParms.BackBufferHeight               = *(pPresentationParameters->BackBufferHeight);
+    object->presentParms.BackBufferFormat               = *(pPresentationParameters->BackBufferFormat);
+    object->presentParms.BackBufferCount                = *(pPresentationParameters->BackBufferCount);
+    object->presentParms.MultiSampleType                = *(pPresentationParameters->MultiSampleType);
+    object->presentParms.MultiSampleQuality             = *(pPresentationParameters->MultiSampleQuality);
+    object->presentParms.SwapEffect                     = *(pPresentationParameters->SwapEffect);
+    object->presentParms.hDeviceWindow                  = *(pPresentationParameters->hDeviceWindow);
+    object->presentParms.Windowed                       = *(pPresentationParameters->Windowed);
+    object->presentParms.EnableAutoDepthStencil         = *(pPresentationParameters->EnableAutoDepthStencil);
+    object->presentParms.AutoDepthStencilFormat         = *(pPresentationParameters->AutoDepthStencilFormat);
+    object->presentParms.Flags                          = *(pPresentationParameters->Flags);
+    object->presentParms.FullScreen_RefreshRateInHz     = *(pPresentationParameters->FullScreen_RefreshRateInHz);
+    object->presentParms.PresentationInterval           = *(pPresentationParameters->PresentationInterval);
+
+
+
+   /*********************
+   * Create the back, frontand stencil buffers
+   *******************/
+    TRACE("calling rendertarget CB\n");
+    D3DCB_CreateRenderTarget((IUnknown *) This->parent,
+                             object->presentParms.BackBufferWidth,
+                             object->presentParms.BackBufferHeight,
+                             object->presentParms.BackBufferFormat,
+                             object->presentParms.MultiSampleType,
+                             object->presentParms.MultiSampleQuality,
+                             TRUE /* Lockable */,
+                             &object->frontBuffer,
+                             NULL /* pShared (always null)*/);
+    IWineD3DSurface_SetContainer(object->frontBuffer, (IUnknown *)object);
+    TRACE("calling rendertarget CB\n");
+    D3DCB_CreateRenderTarget((IUnknown *) This->parent,
+                             object->presentParms.BackBufferWidth,
+                             object->presentParms.BackBufferHeight,
+                             object->presentParms.BackBufferFormat,
+                             object->presentParms.MultiSampleType,
+                             object->presentParms.MultiSampleQuality,
+                             TRUE /* Lockable */,
+                             &object->backBuffer,
+                             NULL /* pShared (always null)*/);
+    IWineD3DSurface_SetContainer(object->backBuffer, (IUnknown *)object);
+
+    /* Under directX swapchains share the depth stencil, so only create one depth-stencil */
+    if (pPresentationParameters->EnableAutoDepthStencil) {
+        TRACE("Creating depth stencil buffer\n");
+        if(This->depthStencilBuffer == NULL ){
+            D3DCB_CreateDepthStencil((IUnknown *) This->parent,
+                                    object->presentParms.BackBufferWidth,
+                                    object->presentParms.BackBufferHeight,
+                                    object->presentParms.AutoDepthStencilFormat,
+                                    object->presentParms.MultiSampleType,
+                                    object->presentParms.MultiSampleQuality,
+                                    FALSE /* FIXME: Discard */,
+                                    &This->depthStencilBuffer,
+                                    NULL /* pShared (always null)*/  );
+        IWineD3DSurface_SetContainer(This->depthStencilBuffer, (IUnknown *)iface);
+        }
+
+        /** TODO: A check on width, height and multisample types
+        *(since the zbuffer must be at least as large as the render target and have the same multisample parameters)
+         ****************************/
+        object->wantsDepthStencilBuffer = TRUE;
+    } else {
+        object->wantsDepthStencilBuffer = FALSE;
+    }
+
+    TRACE("FrontBuf @ %p, BackBuf @ %p, DepthStencil %d\n",object->frontBuffer, object->backBuffer, object->wantsDepthStencilBuffer);
+
+
+   /*********************
+   * init the default renderTarget management
+   *******************/
+    object->drawable     = object->win;
+    object->render_ctx   = object->glCtx;
+
+
+    /*********************
+   * Setup some defaults and clear down the buffers
+   *******************/
+    ENTER_GL();
+    /** save current context and drawable **/
+    oldContext =   glXGetCurrentContext();
+    oldDrawable    =   glXGetCurrentDrawable();
+
+
+    if (glXMakeCurrent(object->display, object->win, object->glCtx) == False) {
+    ERR("Error in setting current context (display %p context %p drawable %ld)!\n", object->display, object->glCtx, object->win);
+    }
+    checkGLcall("glXMakeCurrent");
+
+
+    /* Clear the screen */
+    glClearColor(0.0, 0.0, 0.0, 0.0);
+    checkGLcall("glClearColor");
+    glClearIndex(0);
+    glClearDepth(1);
+    glClearStencil(0);
+
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+    checkGLcall("glClear");
+
+    glColor3f(1.0, 1.0, 1.0);
+    checkGLcall("glColor3f");
+
+    glEnable(GL_LIGHTING);
+    checkGLcall("glEnable");
+
+    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
+    checkGLcall("glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);");
+
+    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);
+    checkGLcall("glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);");
+
+    glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);
+    checkGLcall("glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);");
+
+    /* switch back to the original context (unless it was zero)*/
+    if(This->numberOfSwapChains != 0){
+        /** TODO: restore the context and drawable **/
+        glXMakeCurrent(object->display, oldDrawable, oldContext);
+    }
+    LEAVE_GL();
+
+    /* TODO: move this off into a linked list implementation! (add swapchain, remove swapchain or something along those lines) */
+#if 0
+        IListOperator *listOperator;
+        IListStore_CreateListOperator(This->swapchainStore, &listOperator);
+        IListOperator_Append(listOperator, (void *)object);
+        IListOperator_Release(listOperator);
+#endif
+
+    This->swapchains[This->numberOfSwapChains++] = (IWineD3DSwapChain *)object;
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld , total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+
+    TRACE("Set swapchain to %p\n", object);
     return D3D_OK;
+
 }
 
 /** NOTE: These are ahead of the other getters and setters to save using a forward declartion **/
 UINT     WINAPI  IWineD3DDeviceImpl_GetNumberOfSwapChains(IWineD3DDevice *iface) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    FIXME("(%p) : Stub\n",This);
-    return 1;
+
+
+#if 0 /** TODO: move over to using stores and linked lists. **/
+    unsigned int numberOfSwapChains = 0;
+    IListOperator *listOperator;
+    IListStore_CreateListOperator(This->swapChainStore, &listOperator);
+    numberOfSwapChains = IListOperator_count(listOperator);
+    IListOperator_Release(listOperator);
+
+    TRACE("(%p) returning %d\n", This, numberOfSwapChains);
+    return numberOfSwapChains;
+#endif
+
+
+    TRACE("(%p) returning %d\n", This, This->numberOfSwapChains);
+    return This->numberOfSwapChains;
 }
 
-HRESULT  WINAPI  IWineD3DDeviceImpl_GetSwapChain(IWineD3DDevice *iface, UINT iSwapChain, void** pSwapChain) {
+HRESULT  WINAPI  IWineD3DDeviceImpl_GetSwapChain(IWineD3DDevice *iface, UINT iSwapChain, IWineD3DSwapChain** pSwapChain) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    FIXME("(%p) : Stub\n",This);
+    TRACE("(%p) : swapchain %d \n", This, iSwapChain);
+    if(iSwapChain > IWineD3DDeviceImpl_GetNumberOfSwapChains(iface) || iSwapChain<0){
+        *pSwapChain = NULL;
+        return D3DERR_INVALIDCALL;
+    }else{
+        /** TODO: move off to a linkesList implementation **/
+        *pSwapChain = This->swapchains[iSwapChain];
+    }
+#if 0 /* TODO: move over to using stores and linked lists. */
+    IListOperator *listOperator;
+    IListStore_CreateListOperator(This->swapChainStore, &listOperator);
+    hr = IListOperator_get(listOperator, iSwapChain, (void **)pSwapChain);
+    IListOperator_Release(listOperator);
+    if(hr != D3D_OK){
+         *pSwapChain = NULL;
+        return D3DERR_INVALIDCALL;
+    }
+#endif
+
+    IWineD3DSwapChain_AddRef(*pSwapChain);
+    TRACE("(%p) returning %p\n", This, *pSwapChain);
     return D3D_OK;
 }
 
+
 HRESULT WINAPI IWineD3DDeviceImpl_Reset(IWineD3DDevice* iface, WINED3DPRESENT_PARAMETERS*  pPresentationParameters){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
-    FIXME("(%p) : Stub\n",This);
+    /** ********************************************************
+    * From dx9_lost_device....
+    *
+    * Reset will fail unless the application releases all
+    * resources that are allocated in D3DPOOL_DEFAULT, including
+    * those created by the IDirect3DDevice9::CreateRenderTarget
+    * and IDirect3DDevice9::CreateDepthStencilSurface methods.
+    * *****************************************************/
+
+    /** TODO: Move all the globalStore into the device object
+    *   Check that all objects with a usage of D3DPOOL_DEFAULT have been released
+    *   perform a reset using the new presentationParameters
+    **/
+
+#if 0
+    IListOperator *listOpertor = NULL;
+    IListStore_CreateListOperator(This->textureStore, &listOpertor);
+    IWIneD3DBaseTextureImpl *texture;
+    while(texture = (IWIneD3DBaseTextureImpl *)IListOperator_Next(listOpertor)){
+        if(texture->resource.pool == D3DPOOL_DEFAULT){
+            WARN("Application tried called reset, without first destroying all D3DPOOL_DEFAULT textures\n");
+            IListOperator_Release(listOpertor);
+            return D3DERR_INVALIDCALL;
+        }
+
+    }
+    IListOperator_Release(listOpertor);
+
+    IListStore_CreateListOperator(This->surfaceStore, &listOpertor);
+    IWIneD3DSurfaceImpl *texture;
+    while(surface = (IWIneD3DSurfaceImpl *)IListOperator_Next(listOpertor)){
+        if(surface->resource.pool == D3DPOOL_DEFAULT){
+            WARN("Application tried called reset, without first destroying all D3DPOOL_DEFAULT surfaces\n");
+            IListOperator_Release(listOpertor);
+            return D3DERR_INVALIDCALL;
+        }
+
+    }
+    IListOperator_Release(listOpertor);
+
+    /* TODO: check vertexBuffers (swapchains?) etc... */
+#endif
     return D3D_OK;
-          
+
 }
 
 /*****
  * Vertex Declaration
  *****/
+
  /* TODO: Get ridd of thease and put the functions in the  IWineD3DVertexDeclaration interface */
-#if 1
 extern HRESULT IWineD3DVertexDeclarationImpl_ParseDeclaration8(IWineD3DDeviceImpl * This, const DWORD* pDecl, IWineD3DVertexDeclarationImpl * object);
 extern HRESULT IWineD3DVertexDeclarationImpl_ParseDeclaration9(IWineD3DDeviceImpl * This, const D3DVERTEXELEMENT9* pDecl, IWineD3DVertexDeclarationImpl * object);
 
-
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration(IWineD3DDevice* iface, CONST VOID* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent) {
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration8(IWineD3DDevice* iface, const DWORD* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent){
     IWineD3DDeviceImpl            *This   = (IWineD3DDeviceImpl *)iface;
-    IWineD3DVertexDeclarationImpl *object = NULL;
+    IWineD3DVertexDeclarationImpl *object = NULL; /* NOTE: impl allowed, this is a create */
     HRESULT hr = D3D_OK;
-    
-    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);    
+    /* TODO: replace impl usage with a call to Version */
+    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);
     D3DCREATEOBJECTINSTANCE(object, VertexDeclaration)
     object->allFVF = 0;
-
-    if (8 == ((IWineD3DImpl *)This->wineD3D)->dxVersion) {
-      /** @TODO */
-      hr = IWineD3DVertexDeclarationImpl_ParseDeclaration8(This, (const DWORD*) pDeclaration, object);
-    } else {
-      hr = IWineD3DVertexDeclarationImpl_ParseDeclaration9(This, (const D3DVERTEXELEMENT9*) pDeclaration, object);
-    }
+    /* TODO: get ridd of the impl usage, we should only be using interfaces */
+    hr = IWineD3DVertexDeclarationImpl_ParseDeclaration8(This, pDeclaration, object);
 
     return hr;
 }
 
-
-#else
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration8(IWineD3DDevice* iface, const DWORD* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent){
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration9(IWineD3DDevice* iface, const D3DVERTEXELEMENT9* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent){
     IWineD3DDeviceImpl            *This   = (IWineD3DDeviceImpl *)iface;
     IWineD3DVertexDeclarationImpl *object = NULL; /* NOTE: impl allowed, this is a create */
     HRESULT hr = D3D_OK;
-    /* TODO: replace impl usage with a call to Version*/
-    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);    
+    /* TODO: replace impl usage with a call to Version */
+    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);
     D3DCREATEOBJECTINSTANCE(object, VertexDeclaration)
     object->allFVF = 0;
     /* TODO: get ridd of the impl usage, we should only be using interfaces */
-    hr = IWineD3DVertexDeclarationImpl_ParseDeclaration8(This, pDeclaration, object);
-    
+    hr = IWineD3DVertexDeclarationImpl_ParseDeclaration9(This, pDeclaration, object);
+
     return hr;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration9(IWineD3DDevice* iface, const D3DVERTEXELEMENT9* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent){
+/** TODO: repalce with IWineD3DDeviceImpl_CreateVertexDeclaration8 and IWineD3DDeviceImpl_CreateVertexDeclaration9 to avoid the use of a void * (see above!)  **/
+HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexDeclaration(IWineD3DDevice* iface, CONST VOID* pDeclaration, IWineD3DVertexDeclaration** ppVertexDeclaration, IUnknown *parent) {
     IWineD3DDeviceImpl            *This   = (IWineD3DDeviceImpl *)iface;
     IWineD3DVertexDeclarationImpl *object = NULL; /* NOTE: impl allowed, this is a create */
     HRESULT hr = D3D_OK;
-    /* TODO: replace impl usage with a call to Version*/
-    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);    
+    /* TODO: replace impl usage with a call to Version */
+    TRACE("(%p) : directXVersion=%u, pFunction=%p, ppDecl=%p\n", This, ((IWineD3DImpl *)This->wineD3D)->dxVersion, pDeclaration, ppVertexDeclaration);
     D3DCREATEOBJECTINSTANCE(object, VertexDeclaration)
     object->allFVF = 0;
-    /* TODO: get ridd of the impl usage, we should only be using interfaces */
-    hr = IWineD3DVertexDeclarationImpl_ParseDeclaration9(This, pDeclaration, object);
-    
+
+    if (8 == ((IWineD3DImpl *)This->wineD3D)->dxVersion) {
+      /** @TODO */
+      hr = IWineD3DVertexDeclarationImpl_ParseDeclaration8(This, (const DWORD*) pDeclaration, object);
+    } else {
+      hr = IWineD3DVertexDeclarationImpl_ParseDeclaration9(This, (const D3DVERTEXELEMENT9*) pDeclaration, object);
+    }
+
     return hr;
 }
-#endif
 
 /* http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/graphics/programmingguide/programmable/vertexshaders/vscreate.asp */
 HRESULT WINAPI IWineD3DDeviceImpl_CreateVertexShader(IWineD3DDevice* iface,  CONST DWORD* pFunction, IWineD3DVertexShader** ppVertexShader, IUnknown *parent){
     IWineD3DDeviceImpl       *This = (IWineD3DDeviceImpl *)iface;
-    IWineD3DVertexShaderImpl *object;  /* NOTE: impl usage is ok, this is a create */
-    D3DCREATEOBJECTINSTANCE(object, VertexShader)    
+    IWineD3DVertexShaderImpl *object;  /* NOTE: impl allowed, this is a create */
+    D3DCREATEOBJECTINSTANCE(object, VertexShader)
     object->function      = pFunction;
     FIXME("(%p) : STUB: Created Vertex shader %p\n", This, ppVertexShader);
     return D3D_OK;
@@ -885,26 +1484,40 @@
 
 HRESULT WINAPI IWineD3DDeviceImpl_CreatePixelShader(IWineD3DDevice* iface, CONST DWORD* pFunction, IWineD3DPixelShader** ppPixelShader, IUnknown *parent){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    FIXME("(%p) : Stub\n", This);
+    IWineD3DPixelShaderImpl *object; /* NOTE: impl allowed, this is a create */
+    D3DCREATEOBJECTINSTANCE(object, PixelShader)
+    object->function      = pFunction;
+    FIXME("(%p) : STUB: Created Pixel shader %p\n", This, ppPixelShader);
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetDirect3D(IWineD3DDevice* iface, IWineD3D** ppD3D){    
+HRESULT WINAPI IWineD3DDeviceImpl_GetDirect3D(IWineD3DDevice* iface, IWineD3D** ppD3D){
    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
    *ppD3D= This->wineD3D;
    TRACE("(%p) : wineD3D returning %p\n", This,  *ppD3D);
    IWineD3D_AddRef(*ppD3D);
    return D3D_OK;
-    
+
 }
-    
+
 UINT WINAPI IWineD3DDeviceImpl_GetAvailableTextureMem(IWineD3DDevice *iface) {
+    /** NOTE: There's a probably  a hack-around for this one by putting as many pbuffers, VBO's (or whatever)
+    * Into the video ram as possible and seeing how many fit
+    * you can also get the correct initial value from via X and ATI's driver
+    *******************/
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    FIXME("Stub :(%p) returning 64Mib\n", This);
-    return 64*1024*1024;
+    static BOOL showfixmes = TRUE;
+    if(showfixmes){
+        FIXME("(%p) : stub, emulating %dMib for now, returning %dMib\n", This, (emmulated_textureram/(1024*1024)),
+         ((emmulated_textureram - wineD3DGlobalStatistics->glsurfaceram) / (1024*1024)));
+         showfixmes = FALSE;
+    }
+    TRACE("(%p) :  emulating %dMib for now, returning %dMib\n",  This, (emmulated_textureram/(1024*1024)),
+         ((emmulated_textureram - wineD3DGlobalStatistics->glsurfaceram) / (1024*1024)));
+    /* videomemory is simulated videomemory + AGP memory left */
+    return (emmulated_textureram - wineD3DGlobalStatistics->glsurfaceram);
 }
 
-
 /*****
  * Get / Set FVF
  *****/
@@ -916,9 +1529,17 @@
     This->updateStateBlock->changed.fvf      = TRUE;
     This->updateStateBlock->set.fvf          = TRUE;
 
+    /* clear down the vertex declaration
+     NOTE: Axis and Allies doesn't work properly otherwise
+     (may be a stateblock problem though!)
+    */
+
+    IWineD3DDevice_SetVertexDeclaration(iface, NULL);
+
     TRACE("(%p) : FVF Shader FVF set to %lx\n", This, fvf);
-    
-    /* No difference if recording or not */
+    if(This->isRecordingState) {
+        return D3D_OK;
+    }
     return D3D_OK;
 }
 HRESULT WINAPI IWineD3DDeviceImpl_GetFVF(IWineD3DDevice *iface, DWORD *pfvf) {
@@ -935,14 +1556,41 @@
     IWineD3DDeviceImpl       *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DVertexBuffer     *oldSrc;
 
-    oldSrc = This->stateBlock->stream_source[StreamNumber];
+    /**TODO: instance and index data, see
+    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/directx9_c/directx/graphics/programmingguide/advancedtopics/DrawingMultipleInstances.asp
+    and
+    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/directx9_c/directx/graphics/reference/d3d/interfaces/idirect3ddevice9/SetStreamSourceFreq.asp
+     **************/
+
+    /* D3d9 only, but shouldn't  hurt d3d8 */
+    UINT streamFlags;
+
+    streamFlags = StreamNumber &(D3DSTREAMSOURCE_INDEXEDDATA | D3DSTREAMSOURCE_INSTANCEDATA);
+    if(streamFlags){
+        if(streamFlags & D3DSTREAMSOURCE_INDEXEDDATA){
+           FIXME("stream index data not supported\n");
+        }
+        if(streamFlags & D3DSTREAMSOURCE_INDEXEDDATA){
+           FIXME("stream instance data not supported\n");
+        }
+    }
+
+    StreamNumber&= ~(D3DSTREAMSOURCE_INDEXEDDATA | D3DSTREAMSOURCE_INSTANCEDATA);
+
+    if(StreamNumber >= MAX_STREAMS){
+        ERR("Stream out of rance %d\n", StreamNumber);
+        return D3DERR_INVALIDCALL;
+    }
+
+    oldSrc = This->stateBlock->streamSource[StreamNumber];
     TRACE("(%p) : StreamNo: %d, OldStream (%p), NewStream (%p), NewStride %d\n", This, StreamNumber, oldSrc, pStreamData, Stride);
 
-    This->updateStateBlock->changed.stream_source[StreamNumber] = TRUE;
-    This->updateStateBlock->set.stream_source[StreamNumber]     = TRUE;
-    This->updateStateBlock->stream_stride[StreamNumber]         = Stride;
-    This->updateStateBlock->stream_source[StreamNumber]         = pStreamData;
-    This->updateStateBlock->stream_offset[StreamNumber]         = OffsetInBytes;
+    This->updateStateBlock->changed.streamSource[StreamNumber] = TRUE;
+    This->updateStateBlock->set.streamSource[StreamNumber]     = TRUE;
+    This->updateStateBlock->streamStride[StreamNumber]         = Stride;
+    This->updateStateBlock->streamSource[StreamNumber]         = pStreamData;
+    This->updateStateBlock->streamOffset[StreamNumber]         = OffsetInBytes;
+    This->updateStateBlock->streamFlags[StreamNumber]          = streamFlags;
 
     /* Handle recording of state blocks */
     if (This->isRecordingState) {
@@ -951,48 +1599,102 @@
     }
 
     /* Not recording... */
+    /* Need to do a getParent and pass the reffs up */
+    /* MSDN says ..... When an application no longer holds a references to this interface, the interface will automatically be freed.
+    which suggests that we shouldn't be ref counting? and do need a _release on the stream source to reset the stream source
+    so for now, just count internally   */
+#if 0 /* TODO: move over to using ResourceReleased */
+    /* do nothing we're using ResourceReleased instead */
+#else
     if (oldSrc != NULL) IWineD3DVertexBuffer_Release(oldSrc);
     if (pStreamData != NULL) IWineD3DVertexBuffer_AddRef(pStreamData);
-
+#endif
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetStreamSource(IWineD3DDevice *iface, UINT StreamNumber,IWineD3DVertexBuffer** pStream, UINT *pOffset, UINT* pStride) {
+HRESULT WINAPI IWineD3DDeviceImpl_GetStreamSource(IWineD3DDevice *iface, UINT StreamNumber,
+                                                  IWineD3DVertexBuffer** pStream, UINT *pOffset, UINT* pStride) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    UINT streamFlags;
+
+    TRACE("(%p) : StreamNo: %d, Stream (%p), Stride %d\n", This, StreamNumber,
+           This->stateBlock->streamSource[StreamNumber], This->stateBlock->streamStride[StreamNumber]);
+
+
+    streamFlags = StreamNumber &(D3DSTREAMSOURCE_INDEXEDDATA | D3DSTREAMSOURCE_INSTANCEDATA);
+    if(streamFlags){
+        if(streamFlags & D3DSTREAMSOURCE_INDEXEDDATA){
+           FIXME("stream index data not supported\n");
+        }
+        if(streamFlags & D3DSTREAMSOURCE_INDEXEDDATA){
+            FIXME("stream instance data not supported\n");
+        }
+    }
+
+    StreamNumber&= ~(D3DSTREAMSOURCE_INDEXEDDATA | D3DSTREAMSOURCE_INSTANCEDATA);
+
+    if(StreamNumber >= MAX_STREAMS){
+        ERR("Stream out of rance %d\n", StreamNumber);
+        return D3DERR_INVALIDCALL;
+    }
+    *pStream = This->stateBlock->streamSource[StreamNumber];
+    *pStride = This->stateBlock->streamStride[StreamNumber];
+    *pOffset = This->stateBlock->streamOffset[StreamNumber];
+    if(*pStream == NULL){
+        FIXME("Attempting to get an empty stream %d\n", StreamNumber);
+        return  D3DERR_INVALIDCALL;
+    }
 
-    TRACE("(%p) : StreamNo: %d, Stream (%p), Stride %d\n", This, StreamNumber, This->stateBlock->stream_source[StreamNumber], This->stateBlock->stream_stride[StreamNumber]);
-    *pStream = This->stateBlock->stream_source[StreamNumber];
-    *pStride = This->stateBlock->stream_stride[StreamNumber];
-    *pOffset = This->stateBlock->stream_offset[StreamNumber];
-    if (*pStream != NULL) IWineD3DVertexBuffer_AddRef(*pStream); /* We have created a new reference to the VB */
+    IWineD3DVertexBuffer_AddRef(*pStream); /* We have created a new reference to the VB */
     return D3D_OK;
 }
 
-/*Should be quite easy, just an extension of vertexdata
+
+/* Should be quite easy, just an extension of vertexdata
 ref...
 http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_04/directx/graphics/programmingguide/advancedtopics/DrawingMultipleInstances.asp
 
 The divider is a bit odd though
 
-VertexOffset = StartVertex / Divider * StreamStride + 
+VertexOffset = StartVertex / Divider * StreamStride +
                VertexIndex / Divider * StreamStride + StreamOffset
 
 */
 HRESULT WINAPI IWineD3DDeviceImpl_SetStreamSourceFreq(IWineD3DDevice *iface,  UINT StreamNumber, UINT Divider){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    FIXME("(%p) : stub\n", This);
+
+    TRACE("(%p) StreamNumber(%d), Divider(%d)\n", This, StreamNumber, Divider);
+    This->updateStateBlock->streamFlags[StreamNumber] = Divider & (D3DSTREAMSOURCE_INSTANCEDATA  | D3DSTREAMSOURCE_INDEXEDDATA );
+    This->updateStateBlock->changed.streamFreq[StreamNumber]  = TRUE;
+    This->updateStateBlock->set.streamFreq[StreamNumber]      = TRUE;
+    This->updateStateBlock->streamFreq[StreamNumber]          = Divider & 0x7FFFFF;
+    if(This->updateStateBlock->streamFlags[StreamNumber] || This->updateStateBlock->streamFreq[StreamNumber] != 1){
+        FIXME("Stream indexing not fully supported\n");
+    }
     return D3D_OK;
-    
+
 }
 HRESULT WINAPI IWineD3DDeviceImpl_GetStreamSourceFreq(IWineD3DDevice *iface,  UINT StreamNumber, UINT* Divider){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-        
-    FIXME("(%p) : stub\n", This);
+
+    TRACE("(%p) StreamNumber(%d), Divider(%p)\n", This, StreamNumber, Divider);
+    *Divider = This->updateStateBlock->streamFreq[StreamNumber] | This->updateStateBlock->streamFlags[StreamNumber];
+    TRACE("(%p) : returning %d\n", This, *Divider);
     return D3D_OK;
-    
+
 }
 
+/* Should be quite easy, just an extension of vertexdata
+ref...
+http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_04/directx/graphics/programmingguide/advancedtopics/DrawingMultipleInstances.asp
+
+The divider is a bit odd though
+
+VertexOffset = StartVertex / Divider * StreamStride +
+               VertexIndex / Divider * StreamStride + StreamOffset
+
+*/
+
 /*****
  * Get / Set & Multipy Transform
  *****/
@@ -1011,14 +1713,17 @@
         return D3D_OK;
     }
 
-    /*
+    /**
      * If the new matrix is the same as the current one,
      * we cut off any further processing. this seems to be a reasonable
      * optimization because as was noticed, some apps (warcraft3 for example)
      * tend towards setting the same matrix repeatedly for some reason.
      *
      * From here on we assume that the new matrix is different, wherever it matters.
-     */
+      ******************/
+     dumpMatrixTRACE(lpmatrix);
+
+
     if (!memcmp(&This->stateBlock->transforms[d3dts].u.m[0][0], lpmatrix, sizeof(D3DMATRIX))) {
         TRACE("The app is setting the same matrix over again\n");
         return D3D_OK;
@@ -1026,13 +1731,13 @@
         conv_mat(lpmatrix, &This->stateBlock->transforms[d3dts].u.m[0][0]);
     }
 
-    /*
-       ScreenCoord = ProjectionMat * ViewMat * WorldMat * ObjectCoord
-       where ViewMat = Camera space, WorldMat = world space.
-
-       In OpenGL, camera and world space is combined into GL_MODELVIEW
-       matrix.  The Projection matrix stay projection matrix. 
-     */
+    /**
+     *  ScreenCoord = ProjectionMat * ViewMat * WorldMat * ObjectCoord
+     *  where ViewMat = Camera space, WorldMat = world space.
+     *
+     *  In OpenGL, camera and world space is combined into GL_MODELVIEW
+     *  matrix.  The Projection matrix stay projection matrix.
+      *****************************/
 
     /* Capture the times we can just ignore the change for now */
     if (d3dts == D3DTS_WORLDMATRIX(0)) {
@@ -1043,13 +1748,16 @@
         This->proj_valid = FALSE;
         return D3D_OK;
 
-    } else if (d3dts >= D3DTS_WORLDMATRIX(1) && d3dts <= D3DTS_WORLDMATRIX(255)) { 
+    } else if (d3dts >= D3DTS_WORLDMATRIX(1) && d3dts <= D3DTS_WORLDMATRIX(3)) {
+        This->proj_valid = FALSE;
+        return D3D_OK;
+    } else if (d3dts >= D3DTS_WORLDMATRIX(3) && d3dts <= D3DTS_WORLDMATRIX(255)) {
         /* Indexed Vertex Blending Matrices 256 -> 511  */
         /* Use arb_vertex_blend or NV_VERTEX_WEIGHTING? */
-        FIXME("D3DTS_WORLDMATRIX(1..255) not handled\n");
+        FIXME("D3DTS_WORLDMATRIX(3..255) not handled\n");
         return D3D_OK;
-    } 
-    
+    }
+
     /* Now we really are going to have to change a matrix */
     ENTER_GL();
 
@@ -1057,19 +1765,20 @@
         if (d3dts < GL_LIMITS(textures)) {
             int tex = d3dts - D3DTS_TEXTURE0;
             GLACTIVETEXTURE(tex);
-            set_texture_matrix((float *)lpmatrix, 
+            FIXME("Texture matrix transform adn't applied yet\n");
+            set_texture_matrix((float *)lpmatrix,
                                This->updateStateBlock->textureState[tex][D3DTSS_TEXTURETRANSFORMFLAGS]);
         }
 
     } else if (d3dts == D3DTS_VIEW) { /* handle the VIEW matrice */
         unsigned int k;
 
-        /* If we are changing the View matrix, reset the light and clipping planes to the new view   
+        /** If we are changing the View matrix, reset the light and clipping planes to the new view
          * NOTE: We have to reset the positions even if the light/plane is not currently
-         *       enabled, since the call to enable it will not reset the position.                 
+         *       enabled, since the call to enable it will not reset the position.
          * NOTE2: Apparently texture transforms do NOT need reapplying
-         */
-        
+          ***********************/
+
         PLIGHTINFOEL *lightChain = NULL;
         This->modelview_valid = FALSE;
         This->view_ident = !memcmp(lpmatrix, identity, 16*sizeof(float));
@@ -1106,6 +1815,7 @@
     return D3D_OK;
 
 }
+
 HRESULT WINAPI IWineD3DDeviceImpl_GetTransform(IWineD3DDevice *iface, D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : for Transform State %d\n", This, State);
@@ -1117,11 +1827,11 @@
     D3DMATRIX *mat = NULL;
     D3DMATRIX temp;
 
-    /* Note: Using 'updateStateBlock' rather than 'stateblock' in the code
+    /** Note: Using 'updateStateBlock' rather than 'stateblock' in the code
      * below means it will be recorded in a state block change, but it
-     * works regardless where it is recorded. 
+     * works regardless where it is recorded.
      * If this is found to be wrong, change to StateBlock.
-     */
+     *************************/
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : For state %u\n", This, State);
 
@@ -1133,25 +1843,41 @@
     }
 
     /* Copied from ddraw code:  */
-    temp.u.s._11 = (mat->u.s._11 * pMatrix->u.s._11) + (mat->u.s._21 * pMatrix->u.s._12) + (mat->u.s._31 * pMatrix->u.s._13) + (mat->u.s._41 * pMatrix->u.s._14);
-    temp.u.s._21 = (mat->u.s._11 * pMatrix->u.s._21) + (mat->u.s._21 * pMatrix->u.s._22) + (mat->u.s._31 * pMatrix->u.s._23) + (mat->u.s._41 * pMatrix->u.s._24);
-    temp.u.s._31 = (mat->u.s._11 * pMatrix->u.s._31) + (mat->u.s._21 * pMatrix->u.s._32) + (mat->u.s._31 * pMatrix->u.s._33) + (mat->u.s._41 * pMatrix->u.s._34);
-    temp.u.s._41 = (mat->u.s._11 * pMatrix->u.s._41) + (mat->u.s._21 * pMatrix->u.s._42) + (mat->u.s._31 * pMatrix->u.s._43) + (mat->u.s._41 * pMatrix->u.s._44);
-
-    temp.u.s._12 = (mat->u.s._12 * pMatrix->u.s._11) + (mat->u.s._22 * pMatrix->u.s._12) + (mat->u.s._32 * pMatrix->u.s._13) + (mat->u.s._42 * pMatrix->u.s._14);
-    temp.u.s._22 = (mat->u.s._12 * pMatrix->u.s._21) + (mat->u.s._22 * pMatrix->u.s._22) + (mat->u.s._32 * pMatrix->u.s._23) + (mat->u.s._42 * pMatrix->u.s._24);
-    temp.u.s._32 = (mat->u.s._12 * pMatrix->u.s._31) + (mat->u.s._22 * pMatrix->u.s._32) + (mat->u.s._32 * pMatrix->u.s._33) + (mat->u.s._42 * pMatrix->u.s._34);
-    temp.u.s._42 = (mat->u.s._12 * pMatrix->u.s._41) + (mat->u.s._22 * pMatrix->u.s._42) + (mat->u.s._32 * pMatrix->u.s._43) + (mat->u.s._42 * pMatrix->u.s._44);
-
-    temp.u.s._13 = (mat->u.s._13 * pMatrix->u.s._11) + (mat->u.s._23 * pMatrix->u.s._12) + (mat->u.s._33 * pMatrix->u.s._13) + (mat->u.s._43 * pMatrix->u.s._14);
-    temp.u.s._23 = (mat->u.s._13 * pMatrix->u.s._21) + (mat->u.s._23 * pMatrix->u.s._22) + (mat->u.s._33 * pMatrix->u.s._23) + (mat->u.s._43 * pMatrix->u.s._24);
-    temp.u.s._33 = (mat->u.s._13 * pMatrix->u.s._31) + (mat->u.s._23 * pMatrix->u.s._32) + (mat->u.s._33 * pMatrix->u.s._33) + (mat->u.s._43 * pMatrix->u.s._34);
-    temp.u.s._43 = (mat->u.s._13 * pMatrix->u.s._41) + (mat->u.s._23 * pMatrix->u.s._42) + (mat->u.s._33 * pMatrix->u.s._43) + (mat->u.s._43 * pMatrix->u.s._44);
-
-    temp.u.s._14 = (mat->u.s._14 * pMatrix->u.s._11) + (mat->u.s._24 * pMatrix->u.s._12) + (mat->u.s._34 * pMatrix->u.s._13) + (mat->u.s._44 * pMatrix->u.s._14);
-    temp.u.s._24 = (mat->u.s._14 * pMatrix->u.s._21) + (mat->u.s._24 * pMatrix->u.s._22) + (mat->u.s._34 * pMatrix->u.s._23) + (mat->u.s._44 * pMatrix->u.s._24);
-    temp.u.s._34 = (mat->u.s._14 * pMatrix->u.s._31) + (mat->u.s._24 * pMatrix->u.s._32) + (mat->u.s._34 * pMatrix->u.s._33) + (mat->u.s._44 * pMatrix->u.s._34);
-    temp.u.s._44 = (mat->u.s._14 * pMatrix->u.s._41) + (mat->u.s._24 * pMatrix->u.s._42) + (mat->u.s._34 * pMatrix->u.s._43) + (mat->u.s._44 * pMatrix->u.s._44);
+    temp.u.s._11 = (mat->u.s._11 * pMatrix->u.s._11) + (mat->u.s._21 * pMatrix->u.s._12) +
+      (mat->u.s._31 * pMatrix->u.s._13) + (mat->u.s._41 * pMatrix->u.s._14);
+    temp.u.s._21 = (mat->u.s._11 * pMatrix->u.s._21) + (mat->u.s._21 * pMatrix->u.s._22) +
+      (mat->u.s._31 * pMatrix->u.s._23) + (mat->u.s._41 * pMatrix->u.s._24);
+    temp.u.s._31 = (mat->u.s._11 * pMatrix->u.s._31) + (mat->u.s._21 * pMatrix->u.s._32) +
+      (mat->u.s._31 * pMatrix->u.s._33) + (mat->u.s._41 * pMatrix->u.s._34);
+    temp.u.s._41 = (mat->u.s._11 * pMatrix->u.s._41) + (mat->u.s._21 * pMatrix->u.s._42) +
+      (mat->u.s._31 * pMatrix->u.s._43) + (mat->u.s._41 * pMatrix->u.s._44);
+
+    temp.u.s._12 = (mat->u.s._12 * pMatrix->u.s._11) + (mat->u.s._22 * pMatrix->u.s._12) +
+      (mat->u.s._32 * pMatrix->u.s._13) + (mat->u.s._42 * pMatrix->u.s._14);
+    temp.u.s._22 = (mat->u.s._12 * pMatrix->u.s._21) + (mat->u.s._22 * pMatrix->u.s._22) +
+      (mat->u.s._32 * pMatrix->u.s._23) + (mat->u.s._42 * pMatrix->u.s._24);
+    temp.u.s._32 = (mat->u.s._12 * pMatrix->u.s._31) + (mat->u.s._22 * pMatrix->u.s._32) +
+      (mat->u.s._32 * pMatrix->u.s._33) + (mat->u.s._42 * pMatrix->u.s._34);
+    temp.u.s._42 = (mat->u.s._12 * pMatrix->u.s._41) + (mat->u.s._22 * pMatrix->u.s._42) +
+      (mat->u.s._32 * pMatrix->u.s._43) + (mat->u.s._42 * pMatrix->u.s._44);
+
+    temp.u.s._13 = (mat->u.s._13 * pMatrix->u.s._11) + (mat->u.s._23 * pMatrix->u.s._12) +
+      (mat->u.s._33 * pMatrix->u.s._13) + (mat->u.s._43 * pMatrix->u.s._14);
+    temp.u.s._23 = (mat->u.s._13 * pMatrix->u.s._21) + (mat->u.s._23 * pMatrix->u.s._22) +
+      (mat->u.s._33 * pMatrix->u.s._23) + (mat->u.s._43 * pMatrix->u.s._24);
+    temp.u.s._33 = (mat->u.s._13 * pMatrix->u.s._31) + (mat->u.s._23 * pMatrix->u.s._32) +
+      (mat->u.s._33 * pMatrix->u.s._33) + (mat->u.s._43 * pMatrix->u.s._34);
+    temp.u.s._43 = (mat->u.s._13 * pMatrix->u.s._41) + (mat->u.s._23 * pMatrix->u.s._42) +
+      (mat->u.s._33 * pMatrix->u.s._43) + (mat->u.s._43 * pMatrix->u.s._44);
+
+    temp.u.s._14 = (mat->u.s._14 * pMatrix->u.s._11) + (mat->u.s._24 * pMatrix->u.s._12) +
+      (mat->u.s._34 * pMatrix->u.s._13) + (mat->u.s._44 * pMatrix->u.s._14);
+    temp.u.s._24 = (mat->u.s._14 * pMatrix->u.s._21) + (mat->u.s._24 * pMatrix->u.s._22) +
+      (mat->u.s._34 * pMatrix->u.s._23) + (mat->u.s._44 * pMatrix->u.s._24);
+    temp.u.s._34 = (mat->u.s._14 * pMatrix->u.s._31) + (mat->u.s._24 * pMatrix->u.s._32) +
+      (mat->u.s._34 * pMatrix->u.s._33) + (mat->u.s._44 * pMatrix->u.s._34);
+    temp.u.s._44 = (mat->u.s._14 * pMatrix->u.s._41) + (mat->u.s._24 * pMatrix->u.s._42) +
+      (mat->u.s._34 * pMatrix->u.s._43) + (mat->u.s._44 * pMatrix->u.s._44);
 
     /* Apply change via set transform - will reapply to eg. lights this way */
     IWineD3DDeviceImpl_SetTransform(iface, State, &temp);
@@ -1162,12 +1888,12 @@
  * Get / Set Light
  *   WARNING: This code relies on the fact that D3DLIGHT8 == D3DLIGHT9
  *****/
-/* Note lights are real special cases. Although the device caps state only eg. 8 are supported,
-   you can reference any indexes you want as long as that number max are enabled at any
-   one point in time! Therefore since the indexes can be anything, we need a linked list of them.
-   However, this causes stateblock problems. When capturing the state block, I duplicate the list,
-   but when recording, just build a chain pretty much of commands to be replayed.                  */
-   
+/** Note lights are real special cases. Although the device caps state only eg. 8 are supported,
+*   you can reference any indexes you want as long as that number max are enabled at any
+*   one point in time! Therefore since the indexes can be anything, we need a linked list of them.
+*   However, this causes stateblock problems. When capturing the state block, I duplicate the list,
+*   but when recording, just build a chain pretty much of commands to be replayed.
+ *****************/
 HRESULT WINAPI IWineD3DDeviceImpl_SetLight(IWineD3DDevice *iface, DWORD Index, CONST WINED3DLIGHT* pLight) {
     float rho;
     PLIGHTINFOEL *object, *temp;
@@ -1177,7 +1903,7 @@
 
     /* If recording state block, just add to end of lights chain */
     if (This->isRecordingState) {
-        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PLIGHTINFOEL));
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,sizeof(PLIGHTINFOEL));
         if (NULL == object) {
             return D3DERR_OUTOFVIDEOMEMORY;
         }
@@ -1213,7 +1939,7 @@
         object->OriginalIndex = Index;
         object->glIndex = -1;
 
-        /* Add it to the front of list with the idea that lights will be changed as needed 
+        /* Add it to the front of list with the idea that lights will be changed as needed
            BUT after any lights currently assigned GL indexes                             */
         insertAt = This->stateBlock->lights;
         prevPos  = NULL;
@@ -1285,13 +2011,13 @@
         object->lightDirn[2] = pLight->Direction.z;
         object->lightDirn[3] = 1.0;
 
-        /*
+        /**
          * opengl-ish and d3d-ish spot lights use too different models for the
          * light "intensity" as a function of the angle towards the main light direction,
          * so we only can approximate very roughly.
          * however spot lights are rather rarely used in games (if ever used at all).
          * furthermore if still used, probably nobody pays attention to such details.
-         */
+          ********************************/
         if (pLight->Falloff == 0) {
             rho = 6.28f;
         } else {
@@ -1301,7 +2027,7 @@
         object->exponent = -0.3/log(cos(rho/2));
         object->cutoff = pLight->Phi*90/M_PI;
 
-        /* FIXME: Range */
+        /** FIXME: Range **/
         break;
 
     default:
@@ -1317,9 +2043,9 @@
 
 HRESULT WINAPI IWineD3DDeviceImpl_GetLight(IWineD3DDevice *iface, DWORD Index, WINED3DLIGHT* pLight) {
     PLIGHTINFOEL *lightInfo = NULL;
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface; 
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : Idx(%ld), pLight(%p)\n", This, Index, pLight);
-    
+
     /* Locate the light in the live lights */
     lightInfo = This->stateBlock->lights;
     while (lightInfo != NULL && lightInfo->OriginalIndex != Index) lightInfo = lightInfo->next;
@@ -1334,7 +2060,7 @@
 }
 
 /*****
- * Get / Set Light Enable 
+ * Get / Set Light Enable
  *   (Note for consistency, renamed d3dx function by adding the 'set' prefix)
  *****/
 HRESULT WINAPI IWineD3DDeviceImpl_SetLightEnable(IWineD3DDevice *iface, DWORD Index, BOOL Enable) {
@@ -1371,35 +2097,36 @@
     /* Special case - enabling an undefined light creates one with a strict set of parms! */
     if (lightInfo == NULL) {
         D3DLIGHT9 lightParms;
-        /* Warning - untested code :-) Prob safe to change fixme to a trace but
-             wait until someone confirms it seems to work!                     */
-        TRACE("Light enabled requested but light not defined, so defining one!\n"); 
-        lightParms.Type = D3DLIGHT_DIRECTIONAL;
-        lightParms.Diffuse.r = 1.0;
-        lightParms.Diffuse.g = 1.0;
-        lightParms.Diffuse.b = 1.0;
-        lightParms.Diffuse.a = 0.0;
-        lightParms.Specular.r = 0.0;
-        lightParms.Specular.g = 0.0;
-        lightParms.Specular.b = 0.0;
-        lightParms.Specular.a = 0.0;
-        lightParms.Ambient.r = 0.0;
-        lightParms.Ambient.g = 0.0;
-        lightParms.Ambient.b = 0.0;
-        lightParms.Ambient.a = 0.0;
-        lightParms.Position.x = 0.0;
-        lightParms.Position.y = 0.0;
-        lightParms.Position.z = 0.0;
-        lightParms.Direction.x = 0.0;
-        lightParms.Direction.y = 0.0;
-        lightParms.Direction.z = 1.0;
-        lightParms.Range = 0.0;
-        lightParms.Falloff = 0.0;
+        /** WARNING: - untested code :-) Prob safe to change fixme to a trace but
+         *    wait until someone confirms it seems to work!
+          ***********************/
+        FIXME("Light enabled requested but light not defined, so defining one!\n");
+        lightParms.Type         = D3DLIGHT_DIRECTIONAL;
+        lightParms.Diffuse.r    = 1.0;
+        lightParms.Diffuse.g    = 1.0;
+        lightParms.Diffuse.b    = 1.0;
+        lightParms.Diffuse.a    = 0.0;
+        lightParms.Specular.r   = 0.0;
+        lightParms.Specular.g   = 0.0;
+        lightParms.Specular.b   = 0.0;
+        lightParms.Specular.a   = 0.0;
+        lightParms.Ambient.r    = 0.0;
+        lightParms.Ambient.g    = 0.0;
+        lightParms.Ambient.b    = 0.0;
+        lightParms.Ambient.a    = 0.0;
+        lightParms.Position.x   = 0.0;
+        lightParms.Position.y   = 0.0;
+        lightParms.Position.z   = 0.0;
+        lightParms.Direction.x  = 0.0;
+        lightParms.Direction.y  = 0.0;
+        lightParms.Direction.z  = 1.0;
+        lightParms.Range        = 0.0;
+        lightParms.Falloff      = 0.0;
         lightParms.Attenuation0 = 0.0;
         lightParms.Attenuation1 = 0.0;
         lightParms.Attenuation2 = 0.0;
-        lightParms.Theta = 0.0;
-        lightParms.Phi = 0.0;
+        lightParms.Theta        = 0.0;
+        lightParms.Phi          = 0.0;
         IWineD3DDeviceImpl_SetLight(iface, Index, &lightParms);
 
         /* Search for it again! Should be fairly quick as near head of list */
@@ -1521,7 +2248,7 @@
                gl lights, setup a new light                                     */
             } else if (pos->glIndex == -1) {
 
-                /* We reached the end of the allocated gl lights, so already 
+                /* We reached the end of the allocated gl lights, so already
                     know the index of the next one!                          */
                 glIndex = Index;
                 lightInfo->glIndex = glIndex;
@@ -1557,7 +2284,7 @@
                 glEnable(GL_LIGHT0 + glIndex);
                 checkGLcall("glEnable GL_LIGHT0 new setup");
                 LEAVE_GL();
-                
+
             }
         }
     }
@@ -1567,9 +2294,9 @@
 HRESULT WINAPI IWineD3DDeviceImpl_GetLightEnable(IWineD3DDevice *iface, DWORD Index,BOOL* pEnable) {
 
     PLIGHTINFOEL *lightInfo = NULL;
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface; 
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : for idx(%ld)\n", This, Index);
-    
+
     /* Locate the light in the live lights */
     lightInfo = This->stateBlock->lights;
     while (lightInfo != NULL && lightInfo->OriginalIndex != Index) lightInfo = lightInfo->next;
@@ -1617,10 +2344,10 @@
     glPushMatrix();
     glLoadMatrixf((float *) &This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
 
-    TRACE("Clipplane [%f,%f,%f,%f]\n", 
-          This->updateStateBlock->clipplane[Index][0], 
+    TRACE("Clipplane [%f,%f,%f,%f]\n",
+          This->updateStateBlock->clipplane[Index][0],
           This->updateStateBlock->clipplane[Index][1],
-          This->updateStateBlock->clipplane[Index][2], 
+          This->updateStateBlock->clipplane[Index][2],
           This->updateStateBlock->clipplane[Index][3]);
     glClipPlane(GL_CLIP_PLANE0 + Index, This->updateStateBlock->clipplane[Index]);
     checkGLcall("glClipPlane");
@@ -1665,7 +2392,7 @@
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetClipStatus(IWineD3DDevice *iface, WINED3DCLIPSTATUS* pClipStatus) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    FIXME("(%p) : stub\n", This);    
+    FIXME("(%p) : stub\n", This);
     if (NULL == pClipStatus) {
       return D3DERR_INVALIDCALL;
     }
@@ -1692,12 +2419,15 @@
     }
 
     ENTER_GL();
-    TRACE("(%p) : Diffuse (%f,%f,%f,%f)\n", This, pMaterial->Diffuse.r, pMaterial->Diffuse.g, pMaterial->Diffuse.b, pMaterial->Diffuse.a);
-    TRACE("(%p) : Ambient (%f,%f,%f,%f)\n", This, pMaterial->Ambient.r, pMaterial->Ambient.g, pMaterial->Ambient.b, pMaterial->Ambient.a);
-    TRACE("(%p) : Specular (%f,%f,%f,%f)\n", This, pMaterial->Specular.r, pMaterial->Specular.g, pMaterial->Specular.b, pMaterial->Specular.a);
-    TRACE("(%p) : Emissive (%f,%f,%f,%f)\n", This, pMaterial->Emissive.r, pMaterial->Emissive.g, pMaterial->Emissive.b, pMaterial->Emissive.a);
+    TRACE("(%p) : Diffuse (%f,%f,%f,%f)\n", This, pMaterial->Diffuse.r, pMaterial->Diffuse.g,
+     pMaterial->Diffuse.b, pMaterial->Diffuse.a);
+    TRACE("(%p) : Ambient (%f,%f,%f,%f)\n", This, pMaterial->Ambient.r, pMaterial->Ambient.g,
+    pMaterial->Ambient.b, pMaterial->Ambient.a);
+    TRACE("(%p) : Specular (%f,%f,%f,%f)\n", This, pMaterial->Specular.r, pMaterial->Specular.g,
+     pMaterial->Specular.b, pMaterial->Specular.a);
+    TRACE("(%p) : Emissive (%f,%f,%f,%f)\n", This, pMaterial->Emissive.r, pMaterial->Emissive.g,
+    pMaterial->Emissive.b, pMaterial->Emissive.a);
     TRACE("(%p) : Power (%f)\n", This, pMaterial->Power);
-
     glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, (float*) &This->updateStateBlock->material.Ambient);
     checkGLcall("glMaterialfv");
     glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, (float*) &This->updateStateBlock->material.Diffuse);
@@ -1716,7 +2446,6 @@
     checkGLcall("glMaterialfv");
     glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, This->updateStateBlock->material.Power);
     checkGLcall("glMaterialf");
-
     LEAVE_GL();
     return D3D_OK;
 }
@@ -1724,10 +2453,14 @@
 HRESULT WINAPI IWineD3DDeviceImpl_GetMaterial(IWineD3DDevice *iface, WINED3DMATERIAL* pMaterial) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     memcpy(pMaterial, &This->updateStateBlock->material, sizeof (WINED3DMATERIAL));
-    TRACE("(%p) : Diffuse (%f,%f,%f,%f)\n", This, pMaterial->Diffuse.r, pMaterial->Diffuse.g, pMaterial->Diffuse.b, pMaterial->Diffuse.a);
-    TRACE("(%p) : Ambient (%f,%f,%f,%f)\n", This, pMaterial->Ambient.r, pMaterial->Ambient.g, pMaterial->Ambient.b, pMaterial->Ambient.a);
-    TRACE("(%p) : Specular (%f,%f,%f,%f)\n", This, pMaterial->Specular.r, pMaterial->Specular.g, pMaterial->Specular.b, pMaterial->Specular.a);
-    TRACE("(%p) : Emissive (%f,%f,%f,%f)\n", This, pMaterial->Emissive.r, pMaterial->Emissive.g, pMaterial->Emissive.b, pMaterial->Emissive.a);
+    TRACE("(%p) : Diffuse (%f,%f,%f,%f)\n", This, pMaterial->Diffuse.r, pMaterial->Diffuse.g,
+    pMaterial->Diffuse.b, pMaterial->Diffuse.a);
+    TRACE("(%p) : Ambient (%f,%f,%f,%f)\n", This, pMaterial->Ambient.r, pMaterial->Ambient.g,
+    pMaterial->Ambient.b, pMaterial->Ambient.a);
+    TRACE("(%p) : Specular (%f,%f,%f,%f)\n", This, pMaterial->Specular.r, pMaterial->Specular.g,
+    pMaterial->Specular.b, pMaterial->Specular.a);
+    TRACE("(%p) : Emissive (%f,%f,%f,%f)\n", This, pMaterial->Emissive.r, pMaterial->Emissive.g,
+    pMaterial->Emissive.b, pMaterial->Emissive.a);
     TRACE("(%p) : Power (%f)\n", This, pMaterial->Power);
     return D3D_OK;
 }
@@ -1735,7 +2468,7 @@
 /*****
  * Get / Set Indices
  *****/
-HRESULT WINAPI IWineD3DDeviceImpl_SetIndices(IWineD3DDevice *iface, IWineD3DIndexBuffer* pIndexData, 
+HRESULT WINAPI IWineD3DDeviceImpl_SetIndices(IWineD3DDevice *iface, IWineD3DIndexBuffer* pIndexData,
                                              UINT BaseVertexIndex) {
     IWineD3DDeviceImpl  *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DIndexBuffer *oldIdxs;
@@ -1753,7 +2486,7 @@
         TRACE("Recording... not performing anything\n");
         return D3D_OK;
     }
-
+    /* We shouldn't be reff counting! */
     if (oldIdxs)    IWineD3DIndexBuffer_Release(oldIdxs);
     if (pIndexData) IWineD3DIndexBuffer_AddRef(This->stateBlock->pIndexData);
     return D3D_OK;
@@ -1763,11 +2496,16 @@
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
     *ppIndexData = This->stateBlock->pIndexData;
-    
-    /* up ref count on ppindexdata */
-    if (*ppIndexData) IWineD3DIndexBuffer_AddRef(*ppIndexData);
-    *pBaseVertexIndex = This->stateBlock->baseVertexIndex;
 
+    /* up ref count on ppindexdata */
+    if (*ppIndexData) {
+        IWineD3DIndexBuffer_AddRef(*ppIndexData);
+        *pBaseVertexIndex = This->stateBlock->baseVertexIndex;
+        TRACE("(%p) index data set to %p + %u\n", This, ppIndexData, This->stateBlock->baseVertexIndex);
+    }else{
+        TRACE("(%p) No index data set\n", This);
+    }
+    TRACE("Returning %p %d \n",*ppIndexData, *pBaseVertexIndex);
     return D3D_OK;
 }
 
@@ -1796,9 +2534,26 @@
     glDepthRange(pViewport->MinZ, pViewport->MaxZ);
     checkGLcall("glDepthRange");
     /* Note: GL requires lower left, DirectX supplies upper left */
-    /* TODO: replace usage of renderTarget with context management */
-    glViewport(pViewport->X, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - (pViewport->Y + pViewport->Height)), 
-		    pViewport->Width, pViewport->Height);
+#if 1 /** TODO: replace IWineD3DSurfaceImpl * with IWineD3DSurface_GetDesc(or maybe just get height),
+            NOTE: moving over to context mamagement will fix things here  **/
+    glViewport(pViewport->X, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - (pViewport->Y + pViewport->Height)),
+               pViewport->Width,  pViewport->Height);
+#else /* NOTE: code below is a nasty hack to demostrate a fix for the problem in fr-030_candytron_final */
+    IWineD3DSurfaceImpl * backBuffer = (IWineD3DSurfaceImpl *)((IWineD3DSwapChainImpl *)This->swapchains[0])->backBuffer;
+    /** NOTE: This is a nasty hack, when we switch from an 'oversized' offscreen render target (in this case 1024x1024)
+    *to the back buffer we get nasty clipping problems fr-030_candytron_final is an example of the problem,
+    *and I think it happenes in pirates too everything should be solved by introducing an opengl context manager
+    *that knows a lot more about what context/drawable we're in and how to handel odd context/drawable problems.
+    **/
+    if(This->renderTarget == backBuffer){
+    glViewport(pViewport->X, (This->renderTarget->currentDesc.Height - (pViewport->Y + 1024)),
+              1024, 1024);
+    } else{
+    glViewport(pViewport->X, (This->renderTarget->currentDesc.Height - (pViewport->Y + pViewport->Height)),
+        pViewport->Width,  pViewport->Height);
+    }
+
+#endif
     checkGLcall("glViewport");
 
     LEAVE_GL();
@@ -1821,15 +2576,28 @@
 HRESULT WINAPI IWineD3DDeviceImpl_SetRenderState(IWineD3DDevice *iface, D3DRENDERSTATETYPE State, DWORD Value) {
 
     IWineD3DDeviceImpl  *This     = (IWineD3DDeviceImpl *)iface;
-    DWORD                OldValue = This->stateBlock->renderState[State];
-    
+    DWORD OldValue;
     /* Simple way of referring to either a DWORD or a 4 byte float */
     union {
         DWORD d;
         float f;
     } tmpvalue;
-        
+
+    union {
+        DWORD d;
+        float f;
+    } tmpvalue2;
+
     TRACE("(%p)->state = %s(%d), value = %ld\n", This, debug_d3drenderstate(State), State, Value);
+    if(State > WINEHIGHEST_RENDER_STATE ) {
+        FIXME("(%p) State %s(%d) out of range\n", This, debug_d3drenderstate(State), State);
+        return D3DERR_INVALIDCALL;
+    }
+
+    OldValue = This->stateBlock->renderState[State];
+    TRACE("(%p)->state = %s(%d), value = %ld OldValue %ld %p\n", This, debug_d3drenderstate(State), State,
+            Value, OldValue,  This->updateStateBlock);
+
     This->updateStateBlock->changed.renderState[State] = TRUE;
     This->updateStateBlock->set.renderState[State] = TRUE;
     This->updateStateBlock->renderState[State] = Value;
@@ -1887,7 +2655,7 @@
     case WINED3DRS_CULLMODE                  :
 
         /* If we are culling "back faces with clockwise vertices" then
-           set front faces to be counter clockwise and enable culling  
+           set front faces to be counter clockwise and enable culling
            of back faces                                               */
         switch ((D3DCULL) Value) {
         case D3DCULL_NONE:
@@ -1910,7 +2678,7 @@
             glEnable(GL_CULL_FACE);
             checkGLcall("glEnable GL_CULL_FACE");
             if (This->renderUpsideDown) {
-                glFrontFace(GL_CCW); 
+                glFrontFace(GL_CCW);
                 checkGLcall("glFrontFace GL_CCW");
             } else {
                 glFrontFace(GL_CW);
@@ -1997,7 +2765,7 @@
 
     case WINED3DRS_ALPHABLENDENABLE          :
         if (Value) {
-            glEnable(GL_BLEND);
+           glEnable(GL_BLEND);
             checkGLcall("glEnable GL_BLEND");
         } else {
             glDisable(GL_BLEND);
@@ -2096,7 +2864,7 @@
             /* Ensure we only do the changed clip planes */
             DWORD enable  = 0xFFFFFFFF;
             DWORD disable = 0x00000000;
-            
+
             /* If enabling / disabling all */
             if (State == WINED3DRS_CLIPPING) {
                 if (Value) {
@@ -2110,14 +2878,14 @@
                 enable =   Value & ~OldValue;
                 disable = ~Value &  OldValue;
             }
-            
+
             if (enable & D3DCLIPPLANE0)  { glEnable(GL_CLIP_PLANE0);  checkGLcall("glEnable(clip plane 0)"); }
             if (enable & D3DCLIPPLANE1)  { glEnable(GL_CLIP_PLANE1);  checkGLcall("glEnable(clip plane 1)"); }
             if (enable & D3DCLIPPLANE2)  { glEnable(GL_CLIP_PLANE2);  checkGLcall("glEnable(clip plane 2)"); }
             if (enable & D3DCLIPPLANE3)  { glEnable(GL_CLIP_PLANE3);  checkGLcall("glEnable(clip plane 3)"); }
             if (enable & D3DCLIPPLANE4)  { glEnable(GL_CLIP_PLANE4);  checkGLcall("glEnable(clip plane 4)"); }
             if (enable & D3DCLIPPLANE5)  { glEnable(GL_CLIP_PLANE5);  checkGLcall("glEnable(clip plane 5)"); }
-            
+
             if (disable & D3DCLIPPLANE0) { glDisable(GL_CLIP_PLANE0); checkGLcall("glDisable(clip plane 0)"); }
             if (disable & D3DCLIPPLANE1) { glDisable(GL_CLIP_PLANE1); checkGLcall("glDisable(clip plane 1)"); }
             if (disable & D3DCLIPPLANE2) { glDisable(GL_CLIP_PLANE2); checkGLcall("glDisable(clip plane 2)"); }
@@ -2159,7 +2927,7 @@
         {
             unsigned int i;
 
-            /* Note the texture color applies to all textures whereas 
+            /* Note the texture color applies to all textures whereas
                GL_TEXTURE_ENV_COLOR applies to active only */
             float col[4];
             D3DCOLORTOGLFLOAT4(Value, col);
@@ -2285,9 +3053,9 @@
 
     case WINED3DRS_STENCILFAIL               :
         {
-            GLenum fail  ; 
-            GLenum zpass ; 
-            GLenum zfail ; 
+            GLenum fail  ;
+            GLenum zpass ;
+            GLenum zfail ;
 
             fail = StencilOp(Value);
             glGetIntegerv(GL_STENCIL_PASS_DEPTH_PASS, &zpass);
@@ -2302,9 +3070,9 @@
         break;
     case WINED3DRS_STENCILZFAIL              :
         {
-            GLenum fail  ; 
-            GLenum zpass ; 
-            GLenum zfail ; 
+            GLenum fail  ;
+            GLenum zpass ;
+            GLenum zfail ;
 
             glGetIntegerv(GL_STENCIL_FAIL, &fail);
             checkGLcall("glGetIntegerv(GL_STENCIL_FAIL, &fail);");
@@ -2319,9 +3087,9 @@
         break;
     case WINED3DRS_STENCILPASS               :
         {
-            GLenum fail  ; 
-            GLenum zpass ; 
-            GLenum zfail ; 
+            GLenum fail  ;
+            GLenum zpass ;
+            GLenum zfail ;
 
             glGetIntegerv(GL_STENCIL_FAIL, &fail);
             checkGLcall("glGetIntegerv(GL_STENCIL_FAIL, &fail);");
@@ -2345,7 +3113,7 @@
 
     case WINED3DRS_FOGENABLE                 :
         {
-          if (Value/* && This->stateBlock->renderState[WINED3DRS_FOGTABLEMODE] != D3DFOG_NONE*/) {
+          if (Value/* && This->stateBlock->renderState[WINED3DRS_FOGTABLEMODE] != D3DFOG_NONE */) {
                glEnable(GL_FOG);
                checkGLcall("glEnable GL_FOG");
             } else {
@@ -2376,13 +3144,13 @@
         break;
 
     case WINED3DRS_FOGTABLEMODE              :
-        { 
+        {
           glHint(GL_FOG_HINT, GL_NICEST);
           switch (Value) {
-          case D3DFOG_NONE:    /* I don't know what to do here */ checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break; 
-          case D3DFOG_EXP:     glFogi(GL_FOG_MODE, GL_EXP); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break; 
-          case D3DFOG_EXP2:    glFogi(GL_FOG_MODE, GL_EXP2); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP2"); break; 
-          case D3DFOG_LINEAR:  glFogi(GL_FOG_MODE, GL_LINEAR); checkGLcall("glFogi(GL_FOG_MODE, GL_LINEAR"); break; 
+          case D3DFOG_NONE:    /* I don't know what to do here */ checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break;
+          case D3DFOG_EXP:     glFogi(GL_FOG_MODE, GL_EXP); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break;
+          case D3DFOG_EXP2:    glFogi(GL_FOG_MODE, GL_EXP2); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP2"); break;
+          case D3DFOG_LINEAR:  glFogi(GL_FOG_MODE, GL_LINEAR); checkGLcall("glFogi(GL_FOG_MODE, GL_LINEAR"); break;
           default:
             FIXME("Unsupported Value(%lu) for WINED3DRS_FOGTABLEMODE!\n", Value);
           }
@@ -2393,13 +3161,13 @@
         break;
 
     case WINED3DRS_FOGVERTEXMODE             :
-        { 
+        {
           glHint(GL_FOG_HINT, GL_FASTEST);
           switch (Value) {
-          case D3DFOG_NONE:    /* I don't know what to do here */ checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break; 
-          case D3DFOG_EXP:     glFogi(GL_FOG_MODE, GL_EXP); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break; 
-          case D3DFOG_EXP2:    glFogi(GL_FOG_MODE, GL_EXP2); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP2"); break; 
-          case D3DFOG_LINEAR:  glFogi(GL_FOG_MODE, GL_LINEAR); checkGLcall("glFogi(GL_FOG_MODE, GL_LINEAR"); break; 
+          case D3DFOG_NONE:    /* I don't know what to do here */ checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break;
+          case D3DFOG_EXP:     glFogi(GL_FOG_MODE, GL_EXP); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP"); break;
+          case D3DFOG_EXP2:    glFogi(GL_FOG_MODE, GL_EXP2); checkGLcall("glFogi(GL_FOG_MODE, GL_EXP2"); break;
+          case D3DFOG_LINEAR:  glFogi(GL_FOG_MODE, GL_LINEAR); checkGLcall("glFogi(GL_FOG_MODE, GL_LINEAR"); break;
           default:
             FIXME("Unsupported Value(%lu) for WINED3DRS_FOGTABLEMODE!\n", Value);
           }
@@ -2452,7 +3220,7 @@
 
     case WINED3DRS_INDEXEDVERTEXBLENDENABLE  :
         {
-          TRACE("Indexed Vertex Blend Enable to %ul\n", (BOOL) Value);
+          TRACE("Stub: Indexed Vertex Blend Enable to %ul\n", (BOOL) Value);
         }
         break;
 
@@ -2498,9 +3266,16 @@
                 if (This->tracking_color != DISABLED_TRACKING) This->tracking_color = NEEDS_DISABLE;
             }
         }
-        break; 
-
-    case WINED3DRS_LINEPATTERN               :
+        break;
+     case WINED3DRS_SCISSORTESTENABLE:
+           if(Value !=0 ){/* ignore default of off */
+               glDisable(GL_SCISSOR_TEST);
+	   }else{
+               glEnable(GL_SCISSOR_TEST);
+           }
+	/* All this stuff is D3D* only, so there needs to be a set of flags for WineD3D that's inclusive */
+#if 0
+    case WINED3DRS_LINEPATTERN:
         {
             union {
                 DWORD                 d;
@@ -2521,13 +3296,17 @@
             }
         }
         break;
+#endif
+     case WINED3DRS_DEPTHBIAS                 :
+     case WINED3DRS_SLOPESCALEDEPTHBIAS       :
 
-    case WINED3DRS_ZBIAS                     :
-        {
-            if (Value) {
-                tmpvalue.d = Value;
-                TRACE("ZBias value %f\n", tmpvalue.f);
-                glPolygonOffset(0, -tmpvalue.f);
+         tmpvalue.d = This->stateBlock->renderState[WINED3DRS_SLOPESCALEDEPTHBIAS];
+         tmpvalue2.d = This->stateBlock->renderState[WINED3DRS_DEPTHBIAS];
+
+             {
+            if (tmpvalue.f) {
+                TRACE("DEPTHBIAS value %f %f\n",tmpvalue.f, tmpvalue2.f);
+                glPolygonOffset(-tmpvalue.f, -tmpvalue2.f);
                 checkGLcall("glPolygonOffset(0, -Value)");
                 glEnable(GL_POLYGON_OFFSET_FILL);
                 checkGLcall("glEnable(GL_POLYGON_OFFSET_FILL);");
@@ -2558,12 +3337,15 @@
 
     case WINED3DRS_POINTSIZE                 :
         tmpvalue.d = Value;
-        TRACE("Set point size to %f\n", tmpvalue.f);
+        /* FIXME: check that pointSize isn't outside glGetFloatv( GL_POINT_SIZE_MAX_ARB, &maxSize ); or -ve */
+        VTRACE(("glPointSize: %f\n", tmpvalue.f));
         glPointSize(tmpvalue.f);
         checkGLcall("glPointSize(...);");
         break;
 
     case WINED3DRS_POINTSIZE_MIN             :
+        /* TODO: Arb
+        GL_EXTCALL(glPointParameterfARB)( GL_POINT_SIZE_MIN_ARB, 1.0f );*/
         if (GL_SUPPORT(EXT_POINT_PARAMETERS)) {
           tmpvalue.d = Value;
           GL_EXTCALL(glPointParameterfEXT)(GL_POINT_SIZE_MIN_EXT, tmpvalue.f);
@@ -2574,6 +3356,10 @@
         break;
 
     case WINED3DRS_POINTSIZE_MAX             :
+        /* TODO: Arb
+        GL_EXTCALL(glPointParameterfARB)( GL_POINT_FADE_THRESHOLD_SIZE_ARB, 60.0f );
+        GL_EXTCALL(glPointParameterfARB)( GL_POINT_SIZE_MAX_ARB, 60.0f );
+        */
         if (GL_SUPPORT(EXT_POINT_PARAMETERS)) {
           tmpvalue.d = Value;
           GL_EXTCALL(glPointParameterfEXT)(GL_POINT_SIZE_MAX_EXT, tmpvalue.f);
@@ -2588,41 +3374,44 @@
     case WINED3DRS_POINTSCALE_C              :
     case WINED3DRS_POINTSCALEENABLE          :
         {
-            /* If enabled, supply the parameters, otherwise fall back to defaults */
             if (This->stateBlock->renderState[WINED3DRS_POINTSCALEENABLE]) {
                 GLfloat att[3] = {1.0f, 0.0f, 0.0f};
-                att[0] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_A]);
-                att[1] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_B]);
-                att[2] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_C]);
+                /* This scaling seems to be ok, the z's not correct though */
+                att[0] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_A])/ This->stateBlock->viewport.Width;
+                att[1] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_B])/ This->stateBlock->viewport.Height;
+                att[2] = *((float*)&This->stateBlock->renderState[WINED3DRS_POINTSCALE_C]) * 2.0f /
+                            (This->stateBlock->viewport.Width *  This->stateBlock->viewport.Height);
+
 
                 if (GL_SUPPORT(EXT_POINT_PARAMETERS)) {
-                  GL_EXTCALL(glPointParameterfvEXT)(GL_DISTANCE_ATTENUATION_EXT, att);
-                  checkGLcall("glPointParameterfvEXT(GL_DISTANCE_ATTENUATION_EXT, ...);");
+                    TRACE("glPointParameterfvARB %f %f %f\n",att[0],att[1],att[2]);
+                    GL_EXTCALL(glPointParameterfvEXT)(GL_DISTANCE_ATTENUATION_EXT, att);
+                    checkGLcall("glPointParameterfvEXT(GL_DISTANCE_ATTENUATION_EXT, ...);");
                 } else {
-                  TRACE("WINED3DRS_POINTSCALEENABLE not supported on this opengl\n");
+                    TRACE("WINED3DRS_POINTSCALEENABLE not supported on this opengl\n");
                 }
             } else {
                 GLfloat att[3] = {1.0f, 0.0f, 0.0f};
                 if (GL_SUPPORT(EXT_POINT_PARAMETERS)) {
-                  GL_EXTCALL(glPointParameterfvEXT)(GL_DISTANCE_ATTENUATION_EXT, att);
-                  checkGLcall("glPointParameterfvEXT(GL_DISTANCE_ATTENUATION_EXT, ...);");
+                    GL_EXTCALL(glPointParameterfvEXT)(GL_DISTANCE_ATTENUATION_EXT, att);
+                    checkGLcall("glPointParameterfvEXT(GL_DISTANCE_ATTENUATION_EXT, ...);");
                 } else {
                   TRACE("WINED3DRS_POINTSCALEENABLE not supported, but not on either\n");
                 }
             }
-            break;
         }
+        break;
 
     case WINED3DRS_COLORWRITEENABLE          :
       {
-        TRACE("Color mask: r(%d) g(%d) b(%d) a(%d)\n", 
+        TRACE("Color mask: r(%d) g(%d) b(%d) a(%d)\n",
               Value & D3DCOLORWRITEENABLE_RED   ? 1 : 0,
               Value & D3DCOLORWRITEENABLE_GREEN ? 1 : 0,
               Value & D3DCOLORWRITEENABLE_BLUE  ? 1 : 0,
-              Value & D3DCOLORWRITEENABLE_ALPHA ? 1 : 0); 
-        glColorMask(Value & D3DCOLORWRITEENABLE_RED   ? GL_TRUE : GL_FALSE, 
+              Value & D3DCOLORWRITEENABLE_ALPHA ? 1 : 0);
+        glColorMask(Value & D3DCOLORWRITEENABLE_RED   ? GL_TRUE : GL_FALSE,
                     Value & D3DCOLORWRITEENABLE_GREEN ? GL_TRUE : GL_FALSE,
-                    Value & D3DCOLORWRITEENABLE_BLUE  ? GL_TRUE : GL_FALSE, 
+                    Value & D3DCOLORWRITEENABLE_BLUE  ? GL_TRUE : GL_FALSE,
                     Value & D3DCOLORWRITEENABLE_ALPHA ? GL_TRUE : GL_FALSE);
         checkGLcall("glColorMask(...)");
       }
@@ -2631,7 +3420,7 @@
     case WINED3DRS_LOCALVIEWER               :
       {
         GLint state = (Value) ? 1 : 0;
-        TRACE("Local Viewer Enable to %ul\n", (BOOL) Value);        
+        TRACE("Local Viewer Enable to %ul\n", (BOOL) Value);
         glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, state);
       }
       break;
@@ -2639,9 +3428,9 @@
     case WINED3DRS_LASTPIXEL                 :
       {
         if (Value) {
-          TRACE("Last Pixel Drawing Enabled\n");  
+          TRACE("Last Pixel Drawing Enabled\n");
         } else {
-          FIXME("Last Pixel Drawing Disabled, not handled yet\n");  
+          TRACE("Last Pixel Drawing Disabled, not handled yet\n");
         }
       }
       break;
@@ -2649,22 +3438,67 @@
     case WINED3DRS_SOFTWAREVERTEXPROCESSING  :
       {
         if (Value) {
-          TRACE("Software Processing Enabled\n");  
+          TRACE("Software Processing Enabled\n");
         } else {
-          TRACE("Software Processing Disabled\n");  
+          TRACE("Software Processing Disabled\n");
         }
       }
       break;
 
       /** not supported */
-    case WINED3DRS_ZVISIBLE                  :
+    case WINED3DRS_ZVISIBLE              :
+    case WINED3DRS_EDGEANTIALIAS             :
       {
         LEAVE_GL();
         return D3DERR_INVALIDCALL;
       }
 
-        /* Unhandled yet...! */
-    case WINED3DRS_EDGEANTIALIAS             :
+
+    case WINED3DRS_POINTSPRITEENABLE         :
+    /* http://data.plok.be/ExNihilo/pages/Tutorialpointsprite.htm
+      http://oss.sgi.com/projects/ogl-sample/registry/ARB/point_sprite.txt
+    */
+     /** TODO:
+     * if (GL_SUPPORT(GL_POINT_SPRITE_ARB)) {
+     **/
+        if(Value != FALSE){
+#if 1
+           /* Doesn't work with GL_POINT_SMOOTH on on my ATI 9600, but then ATI drivers are buggered! */
+           glDisable(GL_POINT_SMOOTH);
+#endif
+
+           /* Centre the texture on the vertex */
+           VTRACE("glTexEnvf( GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE)\n");
+           glTexEnvf( GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);
+
+           VTRACE("glTexEnvf( GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE)\n");
+           glTexEnvf( GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);
+           checkGLcall("glTexEnvf(...)");
+           VTRACE("glEnable( GL_POINT_SPRITE_ARB )\n");
+           glEnable( GL_POINT_SPRITE_ARB );
+           checkGLcall("glEnable(...)");
+        }else{
+           VTRACE("glDisable( GL_POINT_SPRITE_ARB )\n");
+           glDisable( GL_POINT_SPRITE_ARB );
+           checkGLcall("glEnable(...)");
+        }
+    break;
+    case WINED3DRS_MULTISAMPLEANTIALIAS      :
+       /* implementation at http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=46
+       GL_ARB_MULTISAMPLE
+       */
+       if(Value != 0){
+           FIXME("(%p) multisample antialias not yet supported\n",This);
+       }
+    break;
+    case WINED3DRS_DEBUGMONITORTOKEN         :
+       if(Value){
+         This->debug=TRUE;
+         FIXME("(%p) Debug streams not yet supported\n",This);
+       }else{
+         This->debug=FALSE;
+       }
+    break;
     case WINED3DRS_WRAP0                     :
     case WINED3DRS_WRAP1                     :
     case WINED3DRS_WRAP2                     :
@@ -2673,23 +3507,27 @@
     case WINED3DRS_WRAP5                     :
     case WINED3DRS_WRAP6                     :
     case WINED3DRS_WRAP7                     :
-    case WINED3DRS_POINTSPRITEENABLE         :
-    case WINED3DRS_MULTISAMPLEANTIALIAS      :
+    /**
+    http://www.cosc.brocku.ca/Offerings/3P98/course/lectures/texture/
+    http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/graphics/programmingguide/FixedFunction/Textures/texturewrapping.asp
+    http://www.gamedev.net/reference/programming/features/rendererdll3/page2.asp
+    Descussion that ways to turn on WRAPing to solve an opengl conversion problem.
+    http://www.flipcode.org/cgi-bin/fcmsg.cgi?thread_show=10248
+    */
+    TRACE("(%p)->(%d,%ld) Texture wraping not yet supported\n",This, State, Value);
+    break;
     case WINED3DRS_MULTISAMPLEMASK           :
     case WINED3DRS_PATCHEDGESTYLE            :
     case WINED3DRS_PATCHSEGMENTS             :
-    case WINED3DRS_DEBUGMONITORTOKEN         :
     case WINED3DRS_POSITIONORDER             :
     case WINED3DRS_NORMALORDER               :
-        /*Put back later: FIXME("(%p)->(%d,%ld) not handled yet\n", This, State, Value); */
         FIXME("(%p)->(%d,%ld) not handled yet\n", This, State, Value);
         break;
     default:
-        FIXME("(%p)->(%d,%ld) unrecognized\n", This, State, Value);
+        TRACE("(%p)->(%d,%ld) unrecognized\n", This, State, Value);
     }
 
     LEAVE_GL();
-
     return D3D_OK;
 }
 
@@ -2700,130 +3538,435 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_SetSamplerState(IWineD3DDevice *iface, DWORD Sampler, WINED3DSAMPLERSTATETYPE Type, DWORD Value){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
-}
-
-HRESULT WINAPI IWineD3DDeviceImpl_GetSamplerState(IWineD3DDevice *iface, DWORD Sampler, WINED3DSAMPLERSTATETYPE Type, DWORD* Value){
+HRESULT WINAPI IWineD3DDeviceImpl_SetSamplerState(IWineD3DDevice *iface, DWORD Sampler,  WINED3DSAMPLERSTATETYPE Type, DWORD Value){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
-
-}
-
-HRESULT WINAPI IWineD3DDeviceImpl_SetScissorRect(IWineD3DDevice *iface, CONST RECT* pRect){ 
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    ENTER_GL();
+    /**
+    * SetSampler is designed to allow fore more than the standard upto 8 textures?
+    *  and Geforce has stopped suporting more than 6 standards texture in openGL,
+    * So I have to use ARB for Gforce. (maybe if the sampler > 4 then use ARB?)
+    *
+    * http://developer.nvidia.com/object/General_FAQ.html#t6
+    *
+    * There are two new settings for GForce
+    * the sampler one:
+    * GL_MAX_TEXTURE_IMAGE_UNITS_ARB
+    * and the texture one:
+    * GL_MAX_TEXTURE_COORDS_ARB.
+    * Ok GForce say it's ok to use glTexParameter/glGetTexParameter(...).
+     ******************/
+
+    /** FIXME: Somethis isn't working properly, textures states don't seem to be being applied,
+    *    or there being cleared down oddly, or GLACTIVETEXTURE isn't working properly.
+     *****************/
+    union {
+        float f;
+        DWORD d;
+    } tmpvalue;
+    GLint maxSamplers;
     
-    /** FIXME: Windows uses a top,left origin openGL uses a bottom Right? **/
-    TRACE("(%p)Setting new Scissor Rect to %ld:%ld-%ld:%ld\n", This, pRect->left, pRect->top, pRect->right, pRect->bottom);
-    glScissor(pRect->left, pRect->top, pRect->right - pRect->left, pRect->bottom - pRect->top);
-    LEAVE_GL();
-    return D3D_OK;
-}
-
-HRESULT WINAPI IWineD3DDeviceImpl_GetScissorRect(IWineD3DDevice *iface, RECT* pRect){ 
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    GLint scissorBox[4];
+    TRACE("(%p) Sampler(%ld), Type(%d) Value(%ld)\n",This, Sampler ,Type, Value);
 
-    ENTER_GL();
-    /** FIXME: Windows uses a top,left origin openGL uses a bottom Right? **/
-    glGetIntegerv(GL_SCISSOR_BOX, scissorBox);
-    pRect->left = scissorBox[1];
-    pRect->top = scissorBox[2];
-    pRect->right = scissorBox[1] + scissorBox[3];
-    pRect->bottom = scissorBox[2] + scissorBox[4]; 
-    TRACE("(%p)Returning a Scissor Rect of %ld:%ld-%ld:%ld\n", This, pRect->left, pRect->top, pRect->right, pRect->bottom);
-    LEAVE_GL();
-    return D3D_OK;
-}
+#if 0
+    if supported GL_MAX_TEXTURE_IMAGE_UNITS_ARB
+    glenable(GL_ARB_fragment_program)
+#endif
+    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS_ARB,&maxSamplers);
 
-HRESULT WINAPI IWineD3DDeviceImpl_SetVertexDeclaration(IWineD3DDevice* iface, IWineD3DVertexDeclaration* pDecl) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;   
-    
-    TRACE("(%p) : pDecl=%p\n", This, pDecl);
+    if (Sampler < maxSamplers && GL_SUPPORT(ARB_MULTITEXTURE)) {
+        maxSamplers =  GL_LIMITS(textures);
+    } else{
+        maxSamplers = 1;
+    }
 
-    IWineD3DVertexDeclaration_AddRef(pDecl);
-    if (NULL != This->updateStateBlock->vertexDecl) {
-      IWineD3DVertexDeclaration_Release(This->updateStateBlock->vertexDecl);
+    if(Sampler > maxSamplers || Sampler < 0 || Type > HIGHEST_SAMPLER_STATE || Type < 0){
+       FIXME("out of range %d %d sampler %ld type %u\n", maxSamplers, HIGHEST_SAMPLER_STATE, Sampler, Type);
+       return D3D_OK;
     }
-    This->updateStateBlock->vertexDecl = pDecl;
-    This->updateStateBlock->changed.vertexDecl = TRUE;
-    This->updateStateBlock->set.vertexDecl = TRUE;
-    return D3D_OK;
-}
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetVertexDeclaration(IWineD3DDevice* iface, IWineD3DVertexDeclaration** ppDecl) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    This->updateStateBlock->changed.samplerState[Sampler][Type] = TRUE;
+    This->updateStateBlock->set.samplerState[Sampler][Type]     = TRUE;
 
-    TRACE("(%p) : ppDecl=%p\n", This, ppDecl);
-    
-    *ppDecl = This->updateStateBlock->vertexDecl;
-    if (NULL != *ppDecl) IWineD3DVertexDeclaration_AddRef(*ppDecl);
-    return D3D_OK;
-}
+#if 0 /* We need to do something so that we only set stateblocks when they change
+            this may meed keeping 'another' stateblock that holds the 'real' state
+            (but shouldn't ->stateblock already do that?
+          */
 
-HRESULT WINAPI IWineD3DDeviceImpl_SetVertexShader(IWineD3DDevice *iface, IWineD3DVertexShader* pShader){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    if(This->updateStateBlock->samplerState[Sampler][Type] == Value &&( Type == WINED3DSAMP_MINFILTER || Type == D3DSAMP_MIPFILTER)){
 
-    static BOOL showFixmes = TRUE;
-    
-    This->updateStateBlock->vertexShader = pShader;
-    This->updateStateBlock->changed.vertexShader = TRUE;
-    This->updateStateBlock->set.vertexShader = TRUE;
-    
-    if(pShader == NULL){
-    /* clear down the shader */
-        TRACE("Clear down the shader\n");
-    }else{
-        if(showFixmes){
-            FIXME("(%p) : stub pShader(%p)\n", This, pShader);
-            showFixmes = FALSE;
-        }
+       FIXME("(%p) no %d %d change of state %d \n",This, Sampler, Type, Value);
+       return D3D_OK;
     }
+#endif
+    TRACE("Setting sampler %ld %d to %ld \n", Sampler, Type, Value);
+    This->updateStateBlock->samplerState[Sampler][Type]         = Value;
 
-    return D3D_OK;
-    
-    /** FIXME: refernece counting? **/
-    if (pShader  == NULL) { /* only valid with non FVF shaders */
-      TRACE_(d3d_shader)("(%p) : FVF Shader, pShader=%p\n", This, pShader);
-      This->updateStateBlock->vertexShader = NULL;
-    } else {
-       TRACE_(d3d_shader)("(%p) : Created shader, pShader=%p\n", This, pShader);
-      This->updateStateBlock->vertexShader = pShader;
-    }
-    
-    This->updateStateBlock->changed.vertexShader = TRUE;
-    This->updateStateBlock->set.vertexShader = TRUE;
-    
     /* Handle recording of state blocks */
     if (This->isRecordingState) {
-      TRACE("Recording... not performing anything\n");
-      return D3D_OK;
+        TRACE("Recording... not performing anything\n");
+        return D3D_OK;
     }
-    /**
-     * TODO: merge HAL shaders context switching from prototype
-     */
-    return D3D_OK;
-    
+    /* In addition, IDirect3DDevice9::SetSamplerState will now be used for filtering, tiling,
+    clamping, MIPLOD, etc. This will work for up to 16 samplers.
+    is this just GL_TEXTURE_2D or is it GL_TEXTURE_1D and GL_TEXTURE_3D as well?
+    */
+    ENTER_GL();
+
+    VTRACE(("Activating appropriate texture state %ld\n", Sampler));
+    if (GL_SUPPORT(ARB_MULTITEXTURE)) {
+        GLACTIVETEXTURE(Sampler);
+    } else if (Sampler > 0) {
+        FIXME("Program using multiple concurrent textures which this opengl implementation doesn't support\n");
+    }
+
+    switch (Type) {
+
+    case WINED3DSAMP_ADDRESSU              : /* 1 */
+    case WINED3DSAMP_ADDRESSV              : /* 2 */
+    case WINED3DSAMP_ADDRESSW              : /* 3 */
+        {
+            GLint wrapParm = GL_REPEAT;
+            switch (Value) {
+            case D3DTADDRESS_WRAP:   wrapParm = GL_REPEAT; break;
+            case D3DTADDRESS_CLAMP:  wrapParm = GL_CLAMP_TO_EDGE; break;
+            case D3DTADDRESS_BORDER:
+              {
+                if (GL_SUPPORT(ARB_TEXTURE_BORDER_CLAMP)) {
+                  wrapParm = GL_CLAMP_TO_BORDER_ARB;
+                } else {
+                  /* FIXME: Not right, but better */
+                  TRACE("Unrecognized or unsupported D3DTADDRESS_* value %ld, state %d\n", Value, Type);
+                  wrapParm = GL_REPEAT;
+                }
+              }
+              break;
+            case D3DTADDRESS_MIRROR:
+              {
+                if (GL_SUPPORT(ARB_TEXTURE_MIRRORED_REPEAT)) {
+                  wrapParm = GL_MIRRORED_REPEAT_ARB;
+                } else {
+                  /* Unsupported in OpenGL pre-1.4 */
+                  TRACE("Unsupported D3DTADDRESS_MIRROR (needs GL_ARB_texture_mirrored_repeat) state %d\n", Type);
+                  wrapParm = GL_REPEAT;
+                }
+              }
+              break;
+            case D3DTADDRESS_MIRRORONCE:
+              {
+                if (GL_SUPPORT(ATI_TEXTURE_MIRROR_ONCE)) {
+                  wrapParm = GL_MIRROR_CLAMP_TO_EDGE_ATI;
+                } else {
+                  TRACE("Unsupported D3DTADDRESS_MIRRORONCE (needs GL_ATI_texture_mirror_once) state %d\n", Type);
+                  wrapParm = GL_REPEAT;
+                }
+              }
+              break;
+
+            default:
+            /* This is for the whole context, not just the sampler,
+            so we should warn if two states are baing set for any given scene */
+            if(Type!=0)
+                TRACE("Unrecognized or unsupported D3DTADDRESS_* value %ld, state %d\n", Value, Type);
+                wrapParm = GL_REPEAT;
+            }
+            switch (Type) {
+            case WINED3DSAMP_ADDRESSU:
+                TRACE("Setting WRAP_S for %ld to %d \n", Sampler, wrapParm);
+                glTexParameteri(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_WRAP_S, wrapParm);
+                checkGLcall("glTexParameteri(..., GL_TEXTURE_WRAP_S, wrapParm)");
+                break;
+            case WINED3DSAMP_ADDRESSV:
+                TRACE("Setting WRAP_T for %ld to %d\n", Sampler, wrapParm);
+                glTexParameteri(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_WRAP_T, wrapParm);
+                checkGLcall("glTexParameteri(..., GL_TEXTURE_WRAP_T, wrapParm)");
+                break;
+
+            case WINED3DSAMP_ADDRESSW:
+                TRACE("Setting WRAP_R for %ld to %d\n", Sampler, wrapParm);
+                glTexParameteri(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_WRAP_R, wrapParm);
+                checkGLcall("glTexParameteri(..., GL_TEXTURE_WRAP_R, wrapParm)");
+                break;
+            default: /* nop */
+                      break; /** stupic compilator */
+            }
+        }
+        break;
+
+    case WINED3DSAMP_BORDERCOLOR           : /* 4 */
+        {
+            float col[4];
+            D3DCOLORTOGLFLOAT4(Value, col);
+            TRACE("Setting border color for %ld to %lx\n", Sampler, Value);
+            glTexParameterfv(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_BORDER_COLOR, &col[0]);
+            checkGLcall("glTexParameteri(..., GL_TEXTURE_BORDER_COLOR, ...)");
+        }
+        break;
+
+      case WINED3DSAMP_MAGFILTER             : /* 5 */
+      {
+        DWORD ValueMAG = This->stateBlock->samplerState[Sampler][WINED3DSAMP_MAGFILTER];
+        GLint realVal = GL_NEAREST;
+
+        if (ValueMAG == D3DTEXF_POINT) {
+          realVal = GL_NEAREST;
+        } else if (ValueMAG == D3DTEXF_LINEAR) {
+          realVal = GL_LINEAR;
+        } else if (ValueMAG == D3DTEXF_ANISOTROPIC) {
+          if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
+            realVal = GL_LINEAR;
+          } else {
+            FIXME("Trying to use ANISOTROPIC_FILTERING for D3DTSS_MAGFILTER. But not supported by current OpenGL driver\n");
+            realVal = GL_NEAREST;
+          }
+        } else {
+          FIXME("Unhandled D3DTSS_MAGFILTER value of %ld\n", ValueMAG);
+          realVal = GL_NEAREST;
+        }
+        TRACE("ValueMAG=%ld setting MAGFILTER to %x\n", ValueMAG, realVal);
+        glTexParameteri(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_MAG_FILTER, realVal);
+        checkGLcall("glTexParameter GL_TEXTURE_MAG_FILTER, ...");
+        /**
+         * if we juste choose to use ANISOTROPIC filtering, refresh openGL state
+         */
+        if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC) && D3DTEXF_ANISOTROPIC == ValueMAG) {
+          glTexParameteri(This->stateBlock->textureDimensions[Sampler],
+                          GL_TEXTURE_MAX_ANISOTROPY_EXT,
+                          This->stateBlock->samplerState[Sampler][WINED3DSAMP_MAXANISOTROPY]);
+          checkGLcall("glTexParameter GL_TEXTURE_MAX_ANISOTROPY_EXT, ...");
+        }
+      }
+      break;
+
+       case WINED3DSAMP_MINFILTER: /* 6 */
+       case WINED3DSAMP_MIPFILTER: /* 7 */
+       {
+            DWORD ValueMIN = This->stateBlock->samplerState[Sampler][WINED3DSAMP_MINFILTER];
+            DWORD ValueMIP = This->stateBlock->samplerState[Sampler][WINED3DSAMP_MIPFILTER];
+            GLint realVal = GL_LINEAR;
+
+            if (ValueMIN == D3DTEXF_NONE) {
+              /* Doesn't really make sense - Windows just seems to disable
+                 mipmapping when this occurs                              */
+              FIXME("Odd - minfilter of none, just disabling mipmaps\n");
+              realVal = GL_LINEAR;
+            } else if (ValueMIN == D3DTEXF_POINT) {
+                /* GL_NEAREST_* */
+              if (ValueMIP == D3DTEXF_NONE) {
+                    realVal = GL_NEAREST;
+                } else if (ValueMIP == D3DTEXF_POINT) {
+                    realVal = GL_NEAREST_MIPMAP_NEAREST;
+                } else if (ValueMIP == D3DTEXF_LINEAR) {
+                    realVal = GL_NEAREST_MIPMAP_LINEAR;
+                } else {
+                    FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
+                    realVal = GL_NEAREST;
+                }
+            } else if (ValueMIN == D3DTEXF_LINEAR) {
+                /* GL_LINEAR_* */
+                if (ValueMIP == D3DTEXF_NONE) {
+                    realVal = GL_LINEAR;
+                } else if (ValueMIP == D3DTEXF_POINT) {
+                    realVal = GL_LINEAR_MIPMAP_NEAREST;
+                } else if (ValueMIP == D3DTEXF_LINEAR) {
+                    realVal = GL_LINEAR_MIPMAP_LINEAR;
+                } else {
+                    FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
+                    realVal = GL_LINEAR;
+                }
+            } else if (ValueMIN == D3DTEXF_ANISOTROPIC) {
+              if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
+                if (ValueMIP == D3DTEXF_NONE) {
+                  realVal = GL_LINEAR_MIPMAP_LINEAR;
+                } else if (ValueMIP == D3DTEXF_POINT) {
+                  realVal = GL_LINEAR_MIPMAP_NEAREST;
+                } else if (ValueMIP == D3DTEXF_LINEAR) {
+                    realVal = GL_LINEAR_MIPMAP_LINEAR;
+                } else {
+                  FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
+                  realVal = GL_LINEAR;
+                }
+              } else {
+                WARN("Trying to use ANISOTROPIC_FILTERING for D3DTSS_MINFILTER. But not supported by OpenGL driver\n");
+                realVal = GL_LINEAR;
+              }
+            } else {
+                FIXME("Unhandled D3DTSS_MINFILTER value of %ld\n", ValueMIN);
+                realVal = GL_LINEAR_MIPMAP_LINEAR;
+            }
+
+            TRACE("ValueMIN=%ld, ValueMIP=%ld, setting MINFILTER to %x\n", ValueMIN, ValueMIP, realVal);
+            glTexParameteri(This->stateBlock->textureDimensions[Sampler], GL_TEXTURE_MIN_FILTER, realVal);
+            checkGLcall("glTexParameter GL_TEXTURE_MIN_FILTER, ...");
+            /**
+             * if we just choose to use ANISOTROPIC filtering, refresh openGL state
+             */
+            if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC) && D3DTEXF_ANISOTROPIC == ValueMIN) {
+              glTexParameteri(This->stateBlock->textureDimensions[Sampler],  GL_TEXTURE_MAX_ANISOTROPY_EXT,
+               This->stateBlock->samplerState[Sampler][WINED3DSAMP_MAXANISOTROPY]);
+              checkGLcall("glTexParameter GL_TEXTURE_MAX_ANISOTROPY_EXT, ...");
+            }
+        }
+        break;
+
+    case WINED3DSAMP_MIPMAPLODBIAS         : /* 8 */
+      {
+        if (GL_SUPPORT(EXT_TEXTURE_LOD_BIAS)) {
+          tmpvalue.d = Value;
+          glTexEnvf(GL_TEXTURE_FILTER_CONTROL_EXT,
+                    GL_TEXTURE_LOD_BIAS_EXT,
+                    tmpvalue.f);
+          checkGLcall("glTexEnvi GL_TEXTURE_LOD_BIAS_EXT ...");
+        }
+      }
+      break;
+
+    case WINED3DSAMP_MAXMIPLEVEL           : /* 9 */
+      {
+        /**
+         * Not really the same, but the more apprioprate than nothing
+         */
+        glTexParameteri(This->stateBlock->textureDimensions[Sampler],
+                        GL_TEXTURE_BASE_LEVEL,
+                        This->stateBlock->samplerState[Sampler][WINED3DSAMP_MAXMIPLEVEL]);
+        checkGLcall("glTexParameteri GL_TEXTURE_BASE_LEVEL ...");
+      }
+      break;
+
+    case WINED3DSAMP_MAXANISOTROPY         :  /* 10 */
+      {
+        if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
+          glTexParameteri(This->stateBlock->textureDimensions[Sampler],
+                          GL_TEXTURE_MAX_ANISOTROPY_EXT,
+                          This->stateBlock->samplerState[Sampler][WINED3DSAMP_MAXANISOTROPY]);
+          checkGLcall("glTexParameteri GL_TEXTURE_MAX_ANISOTROPY_EXT ...");
+        }
+      }
+      break;
+    case WINED3DSAMP_SRGBTEXTURE            : /* 11 */
+   /* Per texture gamma correction, default 0 */
+    case WINED3DSAMP_ELEMENTINDEX           : /* 12 */
+   /* When a multi-element textures is used this indicates the element, (what's a multielement texture?) */
+    case WINED3DSAMP_DMAPOFFSET             : /* 13 */
+   /* Value of a precompiled displacement map used by the tesselator, default 0 */
+    default:
+
+        TRACE("invalid sampler setting, Sampler=%ld, Type=%d, Value =%ld\n", Sampler, Type, Value);
+    };
+    LEAVE_GL();
+    return D3D_OK;
+
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_GetSamplerState(IWineD3DDevice *iface, DWORD Sampler,  WINED3DSAMPLERSTATETYPE Type, DWORD* Value){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    /** TODO: check that sampler is in  range **/
+    *Value = This->updateStateBlock->samplerState[Sampler][Type];
+    return D3D_OK;
+
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_SetScissorRect(IWineD3DDevice *iface, CONST RECT* pRect){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    ENTER_GL();
+
+    /** FIXME: Windows uses a top,left origin openGL uses a bottom Right? **/
+    TRACE("(%p)Setting new Scissor Rect to %ld:%ld-%ld:%ld\n", This, pRect->left, pRect->top, pRect->right, pRect->bottom);
+    glScissor( pRect->left, pRect->top, pRect->right - pRect->left, pRect->bottom - pRect->top);
+    LEAVE_GL();
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_GetScissorRect(IWineD3DDevice *iface, RECT* pRect){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    GLint scissorBox[4];
+    ENTER_GL();
+
+    /** FIXME: Windows uses a top,left origin openGL uses a bottom Right? **/
+    glGetIntegerv(GL_SCISSOR_BOX, scissorBox);
+    pRect->left   = scissorBox[1];
+    pRect->top    = scissorBox[2];
+    pRect->right  = scissorBox[1] + scissorBox[3];
+    pRect->bottom = scissorBox[2] + scissorBox[4];
+    TRACE("(%p)Returning a Scissor Rect of %ld:%ld-%ld:%ld\n", This, pRect->left, pRect->top, pRect->right, pRect->bottom);
+    LEAVE_GL();
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_SetVertexDeclaration(IWineD3DDevice* iface, IWineD3DVertexDeclaration* pDecl) {
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
+
+    TRACE("(%p) : pDecl=%p\n", This, pDecl);
+    This->updateStateBlock->vertexDecl = pDecl;
+    This->updateStateBlock->changed.vertexDecl = TRUE;
+    This->updateStateBlock->set.vertexDecl = TRUE;
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_GetVertexDeclaration(IWineD3DDevice* iface, IWineD3DVertexDeclaration** ppDecl) {
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+
+    TRACE("(%p) : ppDecl=%p\n", This, ppDecl);
+
+    *ppDecl = This->updateStateBlock->vertexDecl;
+    if (NULL != *ppDecl) IWineD3DVertexDeclaration_AddRef(*ppDecl);
+    TRACE("(%p) : returning %p\n", This, *ppDecl);
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DDeviceImpl_SetVertexShader(IWineD3DDevice *iface, IWineD3DVertexShader* pShader){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+
+    static BOOL showFixmes = TRUE;
+
+    This->updateStateBlock->vertexShader = pShader;
+    This->updateStateBlock->changed.vertexShader = TRUE;
+    This->updateStateBlock->set.vertexShader = TRUE;
+
+    if(pShader == NULL){
+    /* clear down the shader */
+        TRACE("Clear down the shader\n");
+    }else{
+        if(showFixmes){
+            FIXME("(%p) : stub pShader(%p)\n", This, pShader);
+            showFixmes = FALSE;
+        }
+    }
+
+    return D3D_OK;
+
+    /** FIXME: refernece counting? **/
+    if (pShader  == NULL) { /* only valid with non FVF shaders */
+      TRACE_(d3d_shader)("(%p) : FVF Shader, pShader=%p\n", This, pShader);
+      This->updateStateBlock->vertexShader = NULL;
+    } else {
+       TRACE_(d3d_shader)("(%p) : Created shader, pShader=%p\n", This, pShader);
+      This->updateStateBlock->vertexShader = pShader;
+    }
+
+    This->updateStateBlock->changed.vertexShader = TRUE;
+    This->updateStateBlock->set.vertexShader = TRUE;
+
+    /* Handle recording of state blocks */
+    if (This->isRecordingState) {
+      TRACE("Recording... not performing anything\n");
+      return D3D_OK;
+    }
+    /**
+     * TODO: merge HAL shaders context switching from prototype
+     */
+    return D3D_OK;
+
 }
 
 HRESULT WINAPI IWineD3DDeviceImpl_GetVertexShader(IWineD3DDevice *iface, IWineD3DVertexShader** ppShader){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     *ppShader = This->stateBlock->vertexShader;
-    if(*ppShader != NULL)
-        IWineD3DVertexShader_AddRef(*ppShader);
+    IWineD3DVertexShader_AddRef(*ppShader);
     TRACE("(%p) : returning %p\n", This, *ppShader);
     return D3D_OK;
 }
-
 HRESULT WINAPI IWineD3DDeviceImpl_SetVertexShaderConstantB(IWineD3DDevice *iface, UINT StartRegister, CONST BOOL  *pConstantData, UINT BoolCount){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
     TRACE("(%p) : stub\n", This);
     return D3D_OK;
 }
@@ -2852,7 +3995,7 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetVertexShaderConstantF(IWineD3DDevice *iface, UINT StartRegister, float       *pConstantData, UINT Vector4fCount){    
+HRESULT WINAPI IWineD3DDeviceImpl_GetVertexShaderConstantF(IWineD3DDevice *iface, UINT StartRegister, float       *pConstantData, UINT Vector4fCount){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : stub\n", This);
     return D3D_OK;
@@ -2919,21 +4062,17 @@
  *****/
 HRESULT WINAPI IWineD3DDeviceImpl_SetTextureStageState(IWineD3DDevice *iface, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    union {
-        float f;
-        DWORD d;
-    } tmpvalue;
 
     /* FIXME: Handle 3d textures? What if TSS value set before set texture? Need to reapply all values? */
-   
+
     TRACE("(%p) : Stage=%ld, Type=%s(%d), Value=%ld\n", This, Stage, debug_d3dtexturestate(Type), Type, Value);
 
     /* Reject invalid texture units */
     if (Stage >= GL_LIMITS(textures)) {
         TRACE("Attempt to access invalid texture rejected\n");
         return D3DERR_INVALIDCALL;
-    }
-
+      }
+    /* FIXME: Only change if the value is different!*/
     This->updateStateBlock->changed.textureState[Stage][Type] = TRUE;
     This->updateStateBlock->set.textureState[Stage][Type] = TRUE;
     This->updateStateBlock->textureState[Stage][Type] = Value;
@@ -2942,162 +4081,19 @@
     if (This->isRecordingState) {
         TRACE("Recording... not performing anything\n");
         return D3D_OK;
-    }
+        }
 
     ENTER_GL();
 
     /* Make appropriate texture active */
     VTRACE(("Activating appropriate texture state %ld\n", Stage));
     if (GL_SUPPORT(ARB_MULTITEXTURE)) {
-        GLACTIVETEXTURE(Stage);
-    } else if (Stage > 0) {
-        FIXME("Program using multiple concurrent textures which this opengl implementation doesn't support\n");
-    }
-
-    switch (Type) {
-
-    case D3DTSS_MINFILTER             :
-    case D3DTSS_MIPFILTER             :
-        {
-            DWORD ValueMIN = This->stateBlock->textureState[Stage][D3DTSS_MINFILTER];
-            DWORD ValueMIP = This->stateBlock->textureState[Stage][D3DTSS_MIPFILTER];
-            GLint realVal = GL_LINEAR;
-
-            if (ValueMIN == D3DTEXF_NONE) {
-              /* Doesn't really make sense - Windows just seems to disable
-                 mipmapping when this occurs                              */
-              FIXME("Odd - minfilter of none, just disabling mipmaps\n");
-              realVal = GL_LINEAR;
-            } else if (ValueMIN == D3DTEXF_POINT) {
-                /* GL_NEAREST_* */
-              if (ValueMIP == D3DTEXF_NONE) {
-                    realVal = GL_NEAREST;
-                } else if (ValueMIP == D3DTEXF_POINT) {
-                    realVal = GL_NEAREST_MIPMAP_NEAREST;
-                } else if (ValueMIP == D3DTEXF_LINEAR) {
-                    realVal = GL_NEAREST_MIPMAP_LINEAR;
-                } else {
-                    FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
-                    realVal = GL_NEAREST;
-                }
-            } else if (ValueMIN == D3DTEXF_LINEAR) {
-                /* GL_LINEAR_* */
-                if (ValueMIP == D3DTEXF_NONE) {
-                    realVal = GL_LINEAR;
-                } else if (ValueMIP == D3DTEXF_POINT) {
-                    realVal = GL_LINEAR_MIPMAP_NEAREST;
-                } else if (ValueMIP == D3DTEXF_LINEAR) {
-                    realVal = GL_LINEAR_MIPMAP_LINEAR;
-                } else {
-                    FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
-                    realVal = GL_LINEAR;
-                }
-            } else if (ValueMIN == D3DTEXF_ANISOTROPIC) {
-              if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
-                if (ValueMIP == D3DTEXF_NONE) {
-                  realVal = GL_LINEAR_MIPMAP_LINEAR;                  
-                } else if (ValueMIP == D3DTEXF_POINT) {
-                  realVal = GL_LINEAR_MIPMAP_NEAREST;
-                } else if (ValueMIP == D3DTEXF_LINEAR) {
-                    realVal = GL_LINEAR_MIPMAP_LINEAR;
-                } else {
-                  FIXME("Unhandled D3DTSS_MIPFILTER value of %ld\n", ValueMIP);
-                  realVal = GL_LINEAR;
-                }
-              } else {
-                WARN("Trying to use ANISOTROPIC_FILTERING for D3DTSS_MINFILTER. But not supported by OpenGL driver\n");
-                realVal = GL_LINEAR;
-              }
-            } else {
-                FIXME("Unhandled D3DTSS_MINFILTER value of %ld\n", ValueMIN);
-                realVal = GL_LINEAR_MIPMAP_LINEAR;
-            }
-
-            TRACE("ValueMIN=%ld, ValueMIP=%ld, setting MINFILTER to %x\n", ValueMIN, ValueMIP, realVal);
-            glTexParameteri(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_MIN_FILTER, realVal);
-            checkGLcall("glTexParameter GL_TEXTURE_MIN_FILTER, ...");
-            /**
-             * if we juste choose to use ANISOTROPIC filtering, refresh openGL state
-             */
-            if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC) && D3DTEXF_ANISOTROPIC == ValueMIN) {
-              glTexParameteri(This->stateBlock->textureDimensions[Stage], 
-                              GL_TEXTURE_MAX_ANISOTROPY_EXT, 
-                              This->stateBlock->textureState[Stage][D3DTSS_MAXANISOTROPY]);
-              checkGLcall("glTexParameter GL_TEXTURE_MAX_ANISOTROPY_EXT, ...");
-            }
-        }
-        break;
-
-    case D3DTSS_MAGFILTER             :
-      {
-        DWORD ValueMAG = This->stateBlock->textureState[Stage][D3DTSS_MAGFILTER];
-        GLint realVal = GL_NEAREST;
-
-        if (ValueMAG == D3DTEXF_POINT) {
-          realVal = GL_NEAREST;
-        } else if (ValueMAG == D3DTEXF_LINEAR) {
-          realVal = GL_LINEAR;
-        } else if (ValueMAG == D3DTEXF_ANISOTROPIC) {
-          if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
-            realVal = GL_LINEAR;
-          } else {
-            FIXME("Trying to use ANISOTROPIC_FILTERING for D3DTSS_MAGFILTER. But not supported by current OpenGL driver\n");
-            realVal = GL_NEAREST;
-          }
-        } else {
-          FIXME("Unhandled D3DTSS_MAGFILTER value of %ld\n", ValueMAG);
-          realVal = GL_NEAREST;
-        }
-        TRACE("ValueMAG=%ld setting MAGFILTER to %x\n", ValueMAG, realVal);
-        glTexParameteri(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_MAG_FILTER, realVal);
-        checkGLcall("glTexParameter GL_TEXTURE_MAG_FILTER, ...");
-        /**
-         * if we juste choose to use ANISOTROPIC filtering, refresh openGL state
-         */
-        if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC) && D3DTEXF_ANISOTROPIC == ValueMAG) {
-          glTexParameteri(This->stateBlock->textureDimensions[Stage], 
-                          GL_TEXTURE_MAX_ANISOTROPY_EXT, 
-                          This->stateBlock->textureState[Stage][D3DTSS_MAXANISOTROPY]);
-          checkGLcall("glTexParameter GL_TEXTURE_MAX_ANISOTROPY_EXT, ...");
-        }
-      }
-      break;
-
-    case D3DTSS_MAXMIPLEVEL           :
-      {
-        /**
-         * Not really the same, but the more apprioprate than nothing
-         */
-        glTexParameteri(This->stateBlock->textureDimensions[Stage], 
-                        GL_TEXTURE_BASE_LEVEL, 
-                        This->stateBlock->textureState[Stage][D3DTSS_MAXMIPLEVEL]);
-        checkGLcall("glTexParameteri GL_TEXTURE_BASE_LEVEL ...");
-      }
-      break;
-
-    case D3DTSS_MAXANISOTROPY         :
-      {        
-        if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
-          glTexParameteri(This->stateBlock->textureDimensions[Stage], 
-                          GL_TEXTURE_MAX_ANISOTROPY_EXT, 
-                          This->stateBlock->textureState[Stage][D3DTSS_MAXANISOTROPY]);
-          checkGLcall("glTexParameteri GL_TEXTURE_MAX_ANISOTROPY_EXT ...");
-        }
-      }
-      break;
-
-    case D3DTSS_MIPMAPLODBIAS         :
-      {        
-        if (GL_SUPPORT(EXT_TEXTURE_LOD_BIAS)) {
-          tmpvalue.d = Value;
-          glTexEnvf(GL_TEXTURE_FILTER_CONTROL_EXT, 
-                    GL_TEXTURE_LOD_BIAS_EXT,
-                    tmpvalue.f);
-          checkGLcall("glTexEnvi GL_TEXTURE_LOD_BIAS_EXT ...");
-        }
+        GLACTIVETEXTURE(Stage);
+    } else if (Stage > 0) {
+        FIXME("Program using multiple concurrent textures which this opengl implementation doesn't support\n");
       }
-      break;
 
+    switch (Type) {
     case D3DTSS_ALPHAOP               :
     case D3DTSS_COLOROP               :
         {
@@ -3120,7 +4116,7 @@
                     } else {
                         glDisable(GL_TEXTURE_1D);
                         checkGLcall("Disable GL_TEXTURE_1D");
-                    } 
+                    }
                     if (This->stateBlock->textureDimensions[Stage] == GL_TEXTURE_2D) {
                       if (GL_SUPPORT(NV_TEXTURE_SHADER) && This->texture_shader_active) {
                         glTexEnvi(GL_TEXTURE_SHADER_NV, GL_SHADER_OPERATION_NV, GL_TEXTURE_2D);
@@ -3157,44 +4153,41 @@
         case D3DTSS_ALPHAARG1             :
         case D3DTSS_ALPHAARG2             :
             {
-                BOOL isAlphaArg = (Type == D3DTSS_ALPHAOP || Type == D3DTSS_ALPHAARG1 || 
+                BOOL isAlphaArg = (Type == D3DTSS_ALPHAOP || Type == D3DTSS_ALPHAARG1 ||
                                    Type == D3DTSS_ALPHAARG2 || Type == D3DTSS_ALPHAARG0);
                 if (isAlphaArg) {
                     set_tex_op(iface, TRUE, Stage, This->stateBlock->textureState[Stage][D3DTSS_ALPHAOP],
-                               This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG1], 
-                               This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG2], 
+                               This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG1],
+                               This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG2],
                                This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG0]);
                 } else {
                     set_tex_op(iface, FALSE, Stage, This->stateBlock->textureState[Stage][D3DTSS_COLOROP],
-                               This->stateBlock->textureState[Stage][D3DTSS_COLORARG1], 
-                               This->stateBlock->textureState[Stage][D3DTSS_COLORARG2], 
+                               This->stateBlock->textureState[Stage][D3DTSS_COLORARG1],
+                               This->stateBlock->textureState[Stage][D3DTSS_COLORARG2],
                                This->stateBlock->textureState[Stage][D3DTSS_COLORARG0]);
                 }
             }
             break;
         }
-
-    case D3DTSS_ADDRESSU              :
-    case D3DTSS_ADDRESSV              :
     case D3DTSS_ADDRESSW              :
         {
             GLint wrapParm = GL_REPEAT;
 
             switch (Value) {
             case D3DTADDRESS_WRAP:   wrapParm = GL_REPEAT; break;
-            case D3DTADDRESS_CLAMP:  wrapParm = GL_CLAMP_TO_EDGE; break;      
-            case D3DTADDRESS_BORDER: 
+            case D3DTADDRESS_CLAMP:  wrapParm = GL_CLAMP_TO_EDGE; break;
+            case D3DTADDRESS_BORDER:
               {
                 if (GL_SUPPORT(ARB_TEXTURE_BORDER_CLAMP)) {
-                  wrapParm = GL_CLAMP_TO_BORDER_ARB; 
+                  wrapParm = GL_CLAMP_TO_BORDER_ARB;
                 } else {
                   /* FIXME: Not right, but better */
                   FIXME("Unrecognized or unsupported D3DTADDRESS_* value %ld, state %d\n", Value, Type);
-                  wrapParm = GL_REPEAT; 
+                  wrapParm = GL_REPEAT;
                 }
               }
               break;
-            case D3DTADDRESS_MIRROR: 
+            case D3DTADDRESS_MIRROR:
               {
                 if (GL_SUPPORT(ARB_TEXTURE_MIRRORED_REPEAT)) {
                   wrapParm = GL_MIRRORED_REPEAT_ARB;
@@ -3205,33 +4198,23 @@
                 }
               }
               break;
-            case D3DTADDRESS_MIRRORONCE: 
+            case D3DTADDRESS_MIRRORONCE:
               {
                 if (GL_SUPPORT(ATI_TEXTURE_MIRROR_ONCE)) {
                   wrapParm = GL_MIRROR_CLAMP_TO_EDGE_ATI;
                 } else {
                   FIXME("Unsupported D3DTADDRESS_MIRRORONCE (needs GL_ATI_texture_mirror_once) state %d\n", Type);
-                  wrapParm = GL_REPEAT; 
+                  wrapParm = GL_REPEAT;
                 }
               }
               break;
 
             default:
-                FIXME("Unrecognized or unsupported D3DTADDRESS_* value %ld, state %d\n", Value, Type);
-                wrapParm = GL_REPEAT; 
+                if(Value != 0 /* default GL_REPEAT */)
+                    FIXME("Unrecognized or unsupported D3DTADDRESS_* value %ld, state %d\n", Value, Type);
+                wrapParm = GL_REPEAT;
             }
-
             switch (Type) {
-            case D3DTSS_ADDRESSU:
-                TRACE("Setting WRAP_S to %d for %x\n", wrapParm, This->stateBlock->textureDimensions[Stage]);
-                glTexParameteri(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_WRAP_S, wrapParm);
-                checkGLcall("glTexParameteri(..., GL_TEXTURE_WRAP_S, wrapParm)");
-                break;
-            case D3DTSS_ADDRESSV:
-                TRACE("Setting WRAP_T to %d for %x\n", wrapParm, This->stateBlock->textureDimensions[Stage]);
-                glTexParameteri(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_WRAP_T, wrapParm);
-                checkGLcall("glTexParameteri(..., GL_TEXTURE_WRAP_T, wrapParm)");
-                break;
             case D3DTSS_ADDRESSW:
                 TRACE("Setting WRAP_R to %d for %x\n", wrapParm, This->stateBlock->textureDimensions[Stage]);
                 glTexParameteri(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_WRAP_R, wrapParm);
@@ -3242,150 +4225,139 @@
             }
         }
         break;
-
-    case D3DTSS_BORDERCOLOR           :
-        {
-            float col[4];
-            D3DCOLORTOGLFLOAT4(Value, col);
-            TRACE("Setting border color for %x to %lx\n", This->stateBlock->textureDimensions[Stage], Value); 
-            glTexParameterfv(This->stateBlock->textureDimensions[Stage], GL_TEXTURE_BORDER_COLOR, &col[0]);
-            checkGLcall("glTexParameteri(..., GL_TEXTURE_BORDER_COLOR, ...)");
-        }
-        break;
-
     case D3DTSS_TEXCOORDINDEX         :
         {
             /* Values 0-7 are indexes into the FVF tex coords - See comments in DrawPrimitive */
 
-            /* FIXME: From MSDN: The D3DTSS_TCI_* flags are mutually exclusive. If you include 
-                  one flag, you can still specify an index value, which the system uses to 
-                  determine the texture wrapping mode.  
+            /** FIXME: From MSDN: The D3DTSS_TCI_* flags are mutually exclusive. If you include
+                  one flag, you can still specify an index value, which the system uses to
+                  determine the texture wrapping mode.
                   eg. SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION | 1 );
-                  means use the vertex position (camera-space) as the input texture coordinates 
+                  means use the vertex position (camera-space) as the input texture coordinates
                   for this texture stage, and the wrap mode set in the WINED3DRS_WRAP1 render
                   state. We do not (yet) support the D3DRENDERSTATE_WRAPx values, nor tie them up
-                  to the TEXCOORDINDEX value */
-          
-            /** 
-             * Be careful the value of the mask 0xF0000 come from d3d8types.h infos 
+                  to the TEXCOORDINDEX value **/
+
+            /**
+             * Be careful the value of the mask 0xF0000 come from d3d8types.h infos
              */
             switch (Value & 0xFFFF0000) {
             case D3DTSS_TCI_PASSTHRU:
-              /*Use the specified texture coordinates contained within the vertex format. This value resolves to zero.*/
-              glDisable(GL_TEXTURE_GEN_S);
-              glDisable(GL_TEXTURE_GEN_T);
-              glDisable(GL_TEXTURE_GEN_R);
-              checkGLcall("glDisable(GL_TEXTURE_GEN_S,T,R)");
-              break;
+                /* Use the specified texture coordinates contained within the vertex format. This value resolves to zero.*/
+                glDisable(GL_TEXTURE_GEN_S);
+                glDisable(GL_TEXTURE_GEN_T);
+                glDisable(GL_TEXTURE_GEN_R);
+                checkGLcall("glDisable(GL_TEXTURE_GEN_S,T,R)");
+                break;
 
             case D3DTSS_TCI_CAMERASPACEPOSITION:
-              /* CameraSpacePosition means use the vertex position, transformed to camera space, 
-                 as the input texture coordinates for this stage's texture transformation. This 
-                 equates roughly to EYE_LINEAR                                                  */
-              {
-                float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
-                float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
-                float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
-                float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
-                TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
-
-                glMatrixMode(GL_MODELVIEW);
-                glPushMatrix();
-                glLoadIdentity();
-                glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
-                glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
-                glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
-                glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
-                glPopMatrix();
-                
-                TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set GL_TEXTURE_GEN_x and GL_x, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR\n");
-                glEnable(GL_TEXTURE_GEN_S);
-                checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
-                glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-                checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
-                glEnable(GL_TEXTURE_GEN_T);
-                checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
-                glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-                checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
-                glEnable(GL_TEXTURE_GEN_R);
-                checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
-                glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-                checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
-              }
-              break;
+                /* CameraSpacePosition means use the vertex position, transformed to camera space,
+                    as the input texture coordinates for this stage's texture transformation. This
+                    equates roughly to EYE_LINEAR                                                  */
+                {
+                    float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
+                    float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
+                    float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
+                    float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
+                    TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
+
+                    glMatrixMode(GL_MODELVIEW);
+                    glPushMatrix();
+                    glLoadIdentity();
+                    glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
+                    glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
+                    glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
+                    glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
+                    glPopMatrix();
+
+                    TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set GL_TEXTURE_GEN_x and GL_x, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR\n");
+                    glEnable(GL_TEXTURE_GEN_S);
+                    checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
+                    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+                    checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
+                    glEnable(GL_TEXTURE_GEN_T);
+                    checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
+                    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+                    checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
+                    glEnable(GL_TEXTURE_GEN_R);
+                    checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
+                    glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+                    checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)");
+                }
+                break;
 
             case D3DTSS_TCI_CAMERASPACENORMAL:
-              {
-                if (GL_SUPPORT(NV_TEXGEN_REFLECTION)) {
-                  float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
-                  float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
-                  float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
-                  float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
-                  TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
-
-                  glMatrixMode(GL_MODELVIEW);
-                  glPushMatrix();
-                  glLoadIdentity();
-                  glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
-                  glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
-                  glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
-                  glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
-                  glPopMatrix();
-                  
-                  glEnable(GL_TEXTURE_GEN_S);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
-                  glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
-                  checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
-                  glEnable(GL_TEXTURE_GEN_T);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
-                  glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
-                  checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
-                  glEnable(GL_TEXTURE_GEN_R);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
-                  glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
-                  checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
+                {
+                    if (GL_SUPPORT(NV_TEXGEN_REFLECTION)) {
+                        float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
+                        float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
+                        float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
+                        float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
+                        TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
+
+                        glMatrixMode(GL_MODELVIEW);
+                        glPushMatrix();
+                        glLoadIdentity();
+                        glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
+                        glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
+                        glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
+                        glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
+                        glPopMatrix();
+
+                        glEnable(GL_TEXTURE_GEN_S);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
+                        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
+                        checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
+                        glEnable(GL_TEXTURE_GEN_T);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
+                        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
+                        checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
+                        glEnable(GL_TEXTURE_GEN_R);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
+                        glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV);
+                        checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_NV)");
+                    }
                 }
-              }
-              break;
+                break;
 
             case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
-              {
-                if (GL_SUPPORT(NV_TEXGEN_REFLECTION)) {
-                  float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
-                  float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
-                  float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
-                  float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
-                  TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
-                  
-                  glMatrixMode(GL_MODELVIEW);
-                  glPushMatrix();
-                  glLoadIdentity();
-                  glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
-                  glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
-                  glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
-                  glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
-                  glPopMatrix();
-                  
-                  glEnable(GL_TEXTURE_GEN_S);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
-                  glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
-                  checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
-                  glEnable(GL_TEXTURE_GEN_T);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
-                  glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
-                  checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
-                  glEnable(GL_TEXTURE_GEN_R);
-                  checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
-                  glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
-                  checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
+                {
+                    if (GL_SUPPORT(NV_TEXGEN_REFLECTION)) {
+                        float s_plane[] = { 1.0, 0.0, 0.0, 0.0 };
+                        float t_plane[] = { 0.0, 1.0, 0.0, 0.0 };
+                        float r_plane[] = { 0.0, 0.0, 1.0, 0.0 };
+                        float q_plane[] = { 0.0, 0.0, 0.0, 1.0 };
+                        TRACE("D3DTSS_TCI_CAMERASPACEPOSITION - Set eye plane\n");
+
+                        glMatrixMode(GL_MODELVIEW);
+                        glPushMatrix();
+                        glLoadIdentity();
+                        glTexGenfv(GL_S, GL_EYE_PLANE, s_plane);
+                        glTexGenfv(GL_T, GL_EYE_PLANE, t_plane);
+                        glTexGenfv(GL_R, GL_EYE_PLANE, r_plane);
+                        glTexGenfv(GL_Q, GL_EYE_PLANE, q_plane);
+                        glPopMatrix();
+
+                        glEnable(GL_TEXTURE_GEN_S);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_S);");
+                        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
+                        checkGLcall("glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
+                        glEnable(GL_TEXTURE_GEN_T);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_T);");
+                        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
+                        checkGLcall("glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
+                        glEnable(GL_TEXTURE_GEN_R);
+                        checkGLcall("glEnable(GL_TEXTURE_GEN_R);");
+                        glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV);
+                        checkGLcall("glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_NV)");
+                    }
                 }
-              }
-              break;
+                break;
 
             /* Unhandled types: */
             default:
-                /* Todo: */
-                /* ? disable GL_TEXTURE_GEN_n ? */ 
+                /** Todo: **/
+                /* ? disable GL_TEXTURE_GEN_n ? */
                 glDisable(GL_TEXTURE_GEN_S);
                 glDisable(GL_TEXTURE_GEN_T);
                 glDisable(GL_TEXTURE_GEN_R);
@@ -3398,27 +4370,27 @@
         /* Unhandled */
     case D3DTSS_TEXTURETRANSFORMFLAGS :
         set_texture_matrix((float *)&This->stateBlock->transforms[D3DTS_TEXTURE0 + Stage].u.m[0][0], Value);
-        break; 
+        break;
 
     case D3DTSS_BUMPENVMAT00          :
     case D3DTSS_BUMPENVMAT01          :
-        TRACE("BUMPENVMAT0%u Stage=%ld, Type=%d, Value =%ld\n", Type - D3DTSS_BUMPENVMAT00, Stage, Type, Value);
+        TRACE("FIXME: BUMPENVMAT0%u Stage=%ld, Type=%d, Value =%ld\n", Type - D3DTSS_BUMPENVMAT00, Stage, Type, Value);
         break;
     case D3DTSS_BUMPENVMAT10          :
     case D3DTSS_BUMPENVMAT11          :
-        TRACE("BUMPENVMAT1%u Stage=%ld, Type=%d, Value =%ld\n", Type - D3DTSS_BUMPENVMAT10, Stage, Type, Value);
+        TRACE("FIXME:  BUMPENVMAT1%u Stage=%ld, Type=%d, Value =%ld\n", Type - D3DTSS_BUMPENVMAT10, Stage, Type, Value);
         break;
 
     case D3DTSS_BUMPENVLSCALE         :
-      TRACE("BUMPENVLSCALE Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
+      TRACE("FIXME:  BUMPENVLSCALE Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
       break;
 
     case D3DTSS_BUMPENVLOFFSET        :
-      TRACE("BUMPENVLOFFSET Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
+      TRACE("FIXME:  BUMPENVLOFFSET Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
       break;
 
     case D3DTSS_RESULTARG             :
-      TRACE("RESULTARG Still a stub, Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
+      TRACE("FIXME:  RESULTARG Still a stub, Stage=%ld, Type=%d, Value =%ld\n", Stage, Type, Value);
       break;
 
     default:
@@ -3439,19 +4411,18 @@
 }
 
 /*****
- * Get / Set Texture 
+ * Get / Set Texture
  *****/
-HRESULT WINAPI IWineD3DDeviceImpl_SetTexture(IWineD3DDevice *iface, DWORD Stage, IWineD3DBaseTexture* pTexture) {
-
+HRESULT  WINAPI  IWineD3DDeviceImpl_SetTexture(IWineD3DDevice* iface, DWORD Stage, IWineD3DBaseTexture* pTexture){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+
     IWineD3DBaseTexture   *oldTexture;
     BOOL                   reapplyStates = TRUE;
-    DWORD                  reapplyFlags = 0;
     INT                    oldTextureDimensions = -1;
+    DWORD                  reapplyFlags = 0;
     D3DRESOURCETYPE        textureType;
 
-    oldTexture = This->updateStateBlock->textures[Stage];
-    TRACE("(%p) : Stage(%ld), Texture (%p)\n", This, Stage, pTexture);
+    TRACE("(%p) : Stage(%ld), pTexture(%p)  \n", This, Stage, pTexture);
 
     /* Reject invalid texture units */
     if (Stage >= GL_LIMITS(textures)) {
@@ -3459,8 +4430,14 @@
         return D3DERR_INVALIDCALL;
     }
 
-    This->updateStateBlock->set.textures[Stage] = TRUE;
+    oldTexture = This->updateStateBlock->textures[Stage];
+    TRACE("GL_LIMITS %d\n",GL_LIMITS(textures));
+    TRACE("(%p) : oldtexture(%p)\n", This,oldTexture);
+
+    This->updateStateBlock->set.textures[Stage]     = TRUE;
     This->updateStateBlock->changed.textures[Stage] = TRUE;
+
+    TRACE("(%p) : setting new texture to %p\n", This,pTexture);
     This->updateStateBlock->textures[Stage] = pTexture;
 
     /* Handle recording of state blocks */
@@ -3469,14 +4446,38 @@
         return D3D_OK;
     }
 
+    /** NOTE: MSDN says that setTexture increases the reference count,
+    * and the the application nust set the texture back to null (or have a leaky application),
+    * This means we should pass the refcount upto the parent
+     *******************************/
+    if (NULL != oldTexture) {
+
+        IUnknown *textureParent;
+        IWineD3DBaseTexture_GetParent(oldTexture, (IUnknown **)&textureParent);
+        IUnknown_Release(textureParent);
+        IUnknown_Release(textureParent); /** NOTE: Twice because GetParent adds a ref **/
+        oldTexture = NULL;
+    }
+    if(NULL != This->updateStateBlock->textures[Stage]){
+
+        IUnknown *textureParent;
+        IWineD3DBaseTexture_GetParent(This->updateStateBlock->textures[Stage], (IUnknown **)&textureParent);
+        /** NOTE: GetParent will increase the ref count for me, I won't clean up untill the texture is set to NULL **/
+    }
+
     oldTextureDimensions = This->updateStateBlock->textureDimensions[Stage];
 
     ENTER_GL();
 
     /* Make appropriate texture active */
     if (GL_SUPPORT(ARB_MULTITEXTURE)) {
-        GLACTIVETEXTURE(Stage);
-
+#if defined(GL_VERSION_1_3)
+        glActiveTexture(GL_TEXTURE0 + Stage);
+        checkGLcall("glActiveTexture");
+#else
+        glActiveTextureARB(GL_TEXTURE0_ARB + Stage);
+        checkGLcall("glActiveTextureARB");
+#endif
     } else if (Stage>0) {
         FIXME("Program using multiple concurrent textures which this opengl implementation doesn't support\n");
     }
@@ -3485,78 +4486,67 @@
     * and the the application nust set the texture back to null (or have a leaky application),
     * This means we should pass the refcount upto the parent
      *******************************/
-    if (NULL != oldTexture) {
 
         IUnknown *textureParent;
         IWineD3DBaseTexture_GetParent(oldTexture, (IUnknown **)&textureParent);
         IUnknown_Release(textureParent);
         IUnknown_Release(textureParent); /** NOTE: Twice because GetParent adds a ref **/
         oldTexture = NULL;
-    }
     
 
     if (NULL != pTexture) {
         IUnknown *textureParent;
         IWineD3DBaseTexture_GetParent(This->updateStateBlock->textures[Stage], (IUnknown **)&textureParent);
         /** NOTE: GetParent will increase the ref count for me, I won't clean up untill the texture is set to NULL **/
-
+        TRACE("Getting type\n");
         /* Now setup the texture appropraitly */
         textureType = IWineD3DBaseTexture_GetType(pTexture);
 
         if (textureType == D3DRTYPE_TEXTURE) {
-
-          if (oldTexture == pTexture && !IWineD3DBaseTexture_GetDirty(pTexture)) {
+          if (oldTexture == pTexture && IWineD3DBaseTexture_GetDirty(pTexture)) {
             TRACE("Skipping setting texture as old == new\n");
             reapplyStates = FALSE;
-
           } else {
-
             /* Standard 2D texture */
             TRACE("Standard 2d texture\n");
             This->updateStateBlock->textureDimensions[Stage] = GL_TEXTURE_2D;
 
             /* Load up the texture now */
-            IWineD3DTexture_PreLoad((IWineD3DTexture *) pTexture);
+            IWineD3DTexture_PreLoad((IWineD3DTexture*) pTexture);
           }
 
         } else if (textureType == D3DRTYPE_VOLUMETEXTURE) {
-
-          if (oldTexture == pTexture && !IWineD3DBaseTexture_GetDirty(pTexture)) {
-              TRACE("Skipping setting texture as old == new\n");
-              reapplyStates = FALSE;
-
+            if (oldTexture == pTexture && IWineD3DBaseTexture_GetDirty(pTexture)) {
+            TRACE("Skipping setting texture as old == new\n");
+            reapplyStates = FALSE;
           } else {
-
-              /* Standard 3D (volume) texture */
-              TRACE("Standard 3d texture\n");
-              This->updateStateBlock->textureDimensions[Stage] = GL_TEXTURE_3D;
-
-              /* Load up the texture now */
-              IWineD3DVolumeTexture_PreLoad((IWineD3DVolumeTexture *) pTexture);
+            /* Standard 3D (volume) texture */
+            TRACE("Standard 3d texture\n");
+            This->updateStateBlock->textureDimensions[Stage] = GL_TEXTURE_3D;
+            /** TODO: change this to use bind texture **/
+            /* Load up the texture now */
+            IWineD3DVolumeTexture_PreLoad((IWineD3DVolumeTexture*) pTexture);
           }
 
-        } else if (textureType == D3DRTYPE_CUBETEXTURE) {
 
-            if (oldTexture == pTexture && !IWineD3DBaseTexture_GetDirty(pTexture)) {
+         } else if (textureType == D3DRTYPE_CUBETEXTURE) {
+            if (oldTexture == pTexture && IWineD3DBaseTexture_GetDirty(pTexture)) {
                 TRACE("Skipping setting texture as old == new\n");
                 reapplyStates = FALSE;
-
             } else {
-
                 /* Standard Cube texture */
+
                 TRACE("Standard Cube texture\n");
                 This->updateStateBlock->textureDimensions[Stage] = GL_TEXTURE_CUBE_MAP_ARB;
-
+                /** TODO: change this to use bind texture **/
                 /* Load up the texture now */
-                IWineD3DCubeTexture_PreLoad((IWineD3DCubeTexture *) pTexture);
+                IWineD3DCubeTexture_PreLoad((IWineD3DCubeTexture*) pTexture);
             }
 
         } else {
             FIXME("(%p) : Incorrect type for a texture : (%d,%s)\n", This, textureType, debug_d3dresourcetype(textureType));
         }
-
     } else {
-
         TRACE("Setting to no texture (ie default texture)\n");
         This->updateStateBlock->textureDimensions[Stage] = GL_TEXTURE_1D;
         glBindTexture(GL_TEXTURE_1D, This->dummyTextureName[Stage]);
@@ -3577,7 +4567,7 @@
 
        /* If Alpha arg1 is texture then handle the special case when there changes between a
           texture and no texture - See comments in set_tex_op                                  */
-       if ((This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG1] == D3DTA_TEXTURE) && 
+       if ((This->stateBlock->textureState[Stage][D3DTSS_ALPHAARG1] == D3DTA_TEXTURE) &&
            (((oldTexture == NULL) && (pTexture != NULL)) || ((pTexture == NULL) && (oldTexture != NULL))))
        {
            reapplyFlags |= REAPPLY_ALPHAOP;
@@ -3591,43 +4581,52 @@
        IWineD3DDeviceImpl_SetupTextureStates(iface, Stage, reapplyFlags);
     }
 
-    LEAVE_GL();   
+    LEAVE_GL();
     TRACE("Texture now fully setup\n");
 
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetTexture(IWineD3DDevice *iface, DWORD Stage, IWineD3DBaseTexture** ppTexture) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    TRACE("(%p) : returning %p for stage %ld\n", This, This->updateStateBlock->textures[Stage], Stage);
-    *ppTexture = (IWineD3DBaseTexture *) This->updateStateBlock->textures[Stage];
-    if (*ppTexture)
-        IWineD3DBaseTexture_AddRef(*ppTexture);
-    return D3D_OK;
+HRESULT WINAPI   IWineD3DDeviceImpl_GetTexture(IWineD3DDevice* iface, DWORD Stage, IWineD3DBaseTexture** ppTexture){
+   IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+   TRACE("(%p) : (%ld /* Stage */,%p /* ppTexture */) \n", This, Stage, ppTexture);
+
+   /* Reject invalid texture units */
+   if (Stage >= GL_LIMITS(textures)) {
+      TRACE("Attempt to access invalid texture rejected\n");
+      return D3DERR_INVALIDCALL;
+   }
+   *ppTexture=This->updateStateBlock->textures[Stage];
+   if(*ppTexture)
+       IWineD3DTexture_AddRef(*ppTexture);
+   else
+        return D3DERR_INVALIDCALL;
+   return D3D_OK;
 }
 
 /*****
  * Get Back Buffer
  *****/
-HRESULT WINAPI IWineD3DDeviceImpl_GetBackBuffer(IWineD3DDevice *iface, UINT iSwapChain, UINT BackBuffer, D3DBACKBUFFER_TYPE Type, 
-                                                IWineD3DSurface** ppBackBuffer) {
+
+HRESULT WINAPI IWineD3DDeviceImpl_GetBackBuffer(IWineD3DDevice *iface, UINT iSwapChain, UINT BackBuffer, D3DBACKBUFFER_TYPE Type,
+                                                IWineD3DSurface **ppBackBuffer) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    IWineD3DSwapChain *swapChain;
+    HRESULT hr;
     
-    *ppBackBuffer = (IWineD3DSurface *) This->backBuffer;
     TRACE("(%p) : BackBuf %d Type %d SwapChain %d returning %p\n", This, BackBuffer, Type, iSwapChain, *ppBackBuffer);
-
-    if (BackBuffer > This->presentParms.BackBufferCount - 1) {
-        FIXME("Only one backBuffer currently supported\n");
-        return D3DERR_INVALIDCALL;
+    
+    hr = IWineD3DDeviceImpl_GetSwapChain(iface,  iSwapChain, &swapChain);
+    if(hr == D3D_OK){
+        hr = IWineD3DSwapChain_GetBackBuffer(swapChain, BackBuffer, Type, ppBackBuffer);
+            IWineD3DSwapChain_Release(swapChain);
+    }else{
+        *ppBackBuffer = NULL;
     }
-
-    /* Note inc ref on returned surface */
-    IWineD3DSurface_AddRef(*ppBackBuffer);
-
-    return D3D_OK;
+    return hr;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_GetDeviceCaps(IWineD3DDevice *iface, D3DCAPS9* pCaps) {
+HRESULT WINAPI IWineD3DDeviceImpl_GetDeviceCaps(IWineD3DDevice *iface, WINED3DCAPS* pCaps) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     WARN("(%p) : stub, calling idirect3d for now\n", This);
     IWineD3D_GetDeviceCaps(This->wineD3D, This->adapterNo, This->devType, pCaps);
@@ -3637,36 +4636,23 @@
 /** TODO: move to swapchains **/
 HRESULT WINAPI IWineD3DDeviceImpl_GetDisplayMode(IWineD3DDevice *iface, UINT iSwapChain, D3DDISPLAYMODE* pMode) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    HDC                 hdc;
-    int                 bpp = 0;
+    IWineD3DSwapChain *swapChain;
+    HRESULT hr;
 
-    pMode->Width        = GetSystemMetrics(SM_CXSCREEN);
-    pMode->Height       = GetSystemMetrics(SM_CYSCREEN);
-    pMode->RefreshRate  = 85; /*FIXME: How to identify? */
-
-    hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
-    bpp = GetDeviceCaps(hdc, BITSPIXEL);
-    DeleteDC(hdc);
-
-    switch (bpp) {
-    case  8: pMode->Format       = WINED3DFMT_R8G8B8; break;
-    case 16: pMode->Format       = WINED3DFMT_R5G6B5; break;
-    case 24: /*pMode->Format       = WINED3DFMT_R8G8B8; break; */
-    case 32: pMode->Format       = WINED3DFMT_A8R8G8B8; break;
-    default: 
-       FIXME("Unrecognized display mode format\n");
-       pMode->Format       = WINED3DFMT_UNKNOWN;
+    hr = IWineD3DDeviceImpl_GetSwapChain(iface,  iSwapChain, (IWineD3DSwapChain **)&swapChain);
+    if(hr == D3D_OK){
+        hr = IWineD3DSwapChain_GetDisplayMode(swapChain, pMode);
+        IWineD3DSwapChain_Release(swapChain);
+    }else{
+        FIXME("(%p) Error getting display mode\n", This);
     }
-
-    FIXME("(%p) : returning w(%d) h(%d) rr(%d) fmt(%u,%s)\n", This, pMode->Width, pMode->Height, pMode->RefreshRate, 
-          pMode->Format, debug_d3dformat(pMode->Format));
-    return D3D_OK;
+    return hr;
 }
 /*****
  * Stateblock related functions
  *****/
 
- HRESULT WINAPI IWineD3DDeviceImpl_BeginStateBlock(IWineD3DDevice *iface) {
+HRESULT WINAPI IWineD3DDeviceImpl_BeginStateBlock(IWineD3DDevice *iface) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     IWineD3DStateBlockImpl *object;
     TRACE("(%p)", This);
@@ -3676,19 +4662,19 @@
         return E_OUTOFMEMORY;
     }
     TRACE("(%p) creted object %p\n", This, object);
-    object->wineD3DDevice= This;    
+    object->wineD3DDevice= This;
     /** FIXME: object->parent       = parent; **/
     object->parent       = NULL;
-    object->blockType    = D3DSBT_ALL;    
+    object->blockType    = D3DSBT_ALL;
     object->ref          = 1;
-    object->lpVtbl       = &IWineD3DStateBlock_Vtbl;   
-    
+    object->lpVtbl       = &IWineD3DStateBlock_Vtbl;
+
     IWineD3DStateBlock_Release((IWineD3DStateBlock*)This->updateStateBlock);
     This->updateStateBlock = object;
     This->isRecordingState = TRUE;
-    
+
     TRACE("(%p) recording stateblock %p\n",This , object);
-    return D3D_OK; 
+    return D3D_OK;
 }
 
 HRESULT WINAPI IWineD3DDeviceImpl_EndStateBlock(IWineD3DDevice *iface, IWineD3DStateBlock** ppStateBlock) {
@@ -3702,11 +4688,11 @@
 
     *ppStateBlock = (IWineD3DStateBlock*)This->updateStateBlock;
     This->isRecordingState = FALSE;
-    This->updateStateBlock = This->stateBlock;    
+    This->updateStateBlock = This->stateBlock;
     IWineD3DStateBlock_AddRef((IWineD3DStateBlock*)This->updateStateBlock);
     /* IWineD3DStateBlock_AddRef(*ppStateBlock); don't need to do this, since we should really just release UpdateStateBlock first */
     TRACE("(%p) returning token (ptr to stateblock) of %p\n", This, *ppStateBlock);
-    return D3D_OK;  
+    return D3D_OK;
 }
 
 /*****
@@ -3714,7 +4700,15 @@
  *****/
 HRESULT WINAPI IWineD3DDeviceImpl_BeginScene(IWineD3DDevice *iface) {
     /* At the moment we have no need for any functionality at the beginning
-       of a scene                                                          */
+       of a scene                                                         */
+
+    /**
+    * TODO: Pass this onto the context manager
+    * it may be a good idea to really set the renderTarget at beginScene
+    * not when set render target is called, but this will be upto the
+    * context mamager
+     *****************************/
+
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) : stub\n", This);
     return D3D_OK;
@@ -3722,16 +4716,34 @@
 
 HRESULT WINAPI IWineD3DDeviceImpl_EndScene(IWineD3DDevice *iface) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    DWORD startTime = 0;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount();
+
     TRACE("(%p)\n", This);
     ENTER_GL();
     /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
     glFlush();
     checkGLcall("glFlush");
+    /* Potentially I have to loop through the swapchains,
+    I should really do this...
+    IUnknown *targetContainer;
+    IUnknown *bufferContainter;
+
+    IWineD3DSurface_GetContainer(This->renderTarget, targetContainer);
+    IWineD3DSurface_GetContainer(This->backBuffer, bufferContainter);
+
+
+    if(classof(targetContainer) != SwapChain || classof(bufferContainter) != SwapChain){
 
+    }
+    ,but as a poor option I can compaire the container aginst the device (This)
+    since renderTargets that arn't created as part of a swapchain will have
+    the device as their container.
+    */
     TRACE("End Scene\n");
     if(This->renderTarget != NULL){
 
-        /* If the container of the rendertarget is a texture then we need to save the data from the pbuffer */
         IUnknown *targetContainer = NULL;
         if (D3D_OK == IWineD3DSurface_GetContainer(This->renderTarget, &IID_IWineD3DBaseTexture, (void **)&targetContainer)) {
             TRACE("RenderTarget is either standalone of a texture.\n");
@@ -3744,99 +4756,55 @@
             IWineD3DBaseTexture_PreLoad((IWineD3DBaseTexture *)targetContainer);
             IWineD3DSurface_SetPBufferState(This->renderTarget, FALSE /* inPBuffer */, FALSE /* inTexture */);
             IUnknown_Release(targetContainer);
+        } else
+        if (D3D_OK == IWineD3DSurface_GetContainer(This->renderTarget, &IID_IWineD3DDevice, (void **)&targetContainer)){
+                /* Were testing to see if the texture is standalone, standalone textures has a container of IWineD3DDevice */
+                FIXME("If your seeing corrupt textures, this may be why\n");
+                IWineD3DSurface_SetPBufferState(This->renderTarget, TRUE /* inPBuffer */, FALSE /* inTexture */);
+                IWineD3DSurface_AddDirtyRect(This->renderTarget, NULL);
+                IWineD3DSurface_PreLoad(This->renderTarget);
+                IWineD3DSurface_SetPBufferState(This->renderTarget, FALSE /* inPBuffer */, FALSE /* inTexture */);
+                IUnknown_Release(targetContainer);
         }
 
     }
-
     LEAVE_GL();
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_Present(IWineD3DDevice *iface, 
-                                          CONST RECT* pSourceRect, CONST RECT* pDestRect, 
+HRESULT WINAPI IWineD3DDeviceImpl_Present(IWineD3DDevice *iface,
+                                          CONST RECT* pSourceRect, CONST RECT* pDestRect,
                                           HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    TRACE("(%p) Presenting the frame\n", This);
-
-    ENTER_GL();
-
-    if (pSourceRect || pDestRect) FIXME("Unhandled present options %p/%p\n", pSourceRect, pDestRect);
-
-    glXSwapBuffers(This->display, This->drawable);
-    /* Don't call checkGLcall, as glGetError is not applicable here */
-    
-    TRACE("glXSwapBuffers called, Starting new frame\n");
-
-    /* FPS support */
-    if (TRACE_ON(d3d_fps))
-    {
-        static long prev_time, frames;
-
-        DWORD time = GetTickCount();
-        frames++;
-        /* every 1.5 seconds */
-        if (time - prev_time > 1500) {
-            TRACE_(d3d_fps)("@ approx %.2ffps\n", 1000.0*frames/(time - prev_time));
-            prev_time = time;
-            frames = 0;
-        }
-    }
+    IWineD3DSwapChain *swapChain = NULL;
+    int i;
+    int swapchains = IWineD3DDeviceImpl_GetNumberOfSwapChains(iface);
 
-#if defined(FRAME_DEBUGGING)
-{
-    if (GetFileAttributesA("C:\\D3DTRACE") != INVALID_FILE_ATTRIBUTES) {
-        if (!isOn) {
-            isOn = TRUE;
-            FIXME("Enabling D3D Trace\n");
-            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 1);
-#if defined(SHOW_FRAME_MAKEUP)
-            FIXME("Singe Frame snapshots Starting\n");
-            isDumpingFrames = TRUE;
-            glClear(GL_COLOR_BUFFER_BIT);
-#endif
+    TRACE("(%p) Presenting the frame\n", This);
 
-#if defined(SINGLE_FRAME_DEBUGGING)
-        } else {
-#if defined(SHOW_FRAME_MAKEUP)
-            FIXME("Singe Frame snapshots Finishing\n");
-            isDumpingFrames = FALSE;
-#endif
-            FIXME("Singe Frame trace complete\n");
-            DeleteFileA("C:\\D3DTRACE");
-            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 0);
-#endif
-        }
-    } else {
-        if (isOn) {
-            isOn = FALSE;
-#if defined(SHOW_FRAME_MAKEUP)
-            FIXME("Singe Frame snapshots Finishing\n");
-            isDumpingFrames = FALSE;
-#endif
-            FIXME("Disabling D3D Trace\n");
-            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 0);
-        }
-    }
-}
-#endif
+    for(i = 0 ; i < swapchains ; i ++){
 
-    LEAVE_GL();
-    /* Although this is not strictly required, a simple demo showed this does occur
-       on (at least non-debug) d3d                                                  */
-    if (This->presentParms.SwapEffect == D3DSWAPEFFECT_DISCARD) {
-       IWineD3DDevice_Clear(iface, 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_ZBUFFER|D3DCLEAR_TARGET, 0x00, 1.0, 0);
+        IWineD3DDeviceImpl_GetSwapChain(iface, i , (IWineD3DSwapChain **)&swapChain);
+        TRACE("presentinng chain %d, %p\n", i, swapChain);
+        IWineD3DSwapChain_Present(swapChain, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, 0);
+        IWineD3DSwapChain_Release(swapChain);
     }
 
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_Clear(IWineD3DDevice *iface, DWORD Count, CONST D3DRECT* pRects, 
+HRESULT WINAPI IWineD3DDeviceImpl_Clear(IWineD3DDevice *iface, DWORD Count, CONST D3DRECT* pRects,
                                         DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
     /* TODO: From MSDN This method fails if you specify the D3DCLEAR_ZBUFFER or D3DCLEAR_STENCIL flags when the
       render target does not have an attached depth buffer. Similarly, if you specify the D3DCLEAR_STENCIL flag
       when the depth-buffer format does not contain stencil buffer information, this method fails. */
+    /* TODO: Check that the scissortests in here doesn't affect DirectX scissor tests */
+    /* TODO: what about swapchains? */
     GLbitfield     glMask = 0;
     GLboolean      old_ztest;
     GLfloat        old_z_clear_value;
@@ -3847,7 +4815,6 @@
 
     TRACE("(%p) Count (%ld), pRects (%p), Flags (%lx), Z (%f), Stencil (%ld)\n", This,
           Count, pRects, Flags, Z, Stencil);
-
     ENTER_GL();
 
     glEnable(GL_SCISSOR_TEST);
@@ -3860,7 +4827,7 @@
     }
 
     /* Only set the values up once, as they are not changing */
-    if (Flags & D3DCLEAR_STENCIL) {        
+    if (Flags & D3DCLEAR_STENCIL) {
         glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &old_stencil_clear_value);
         glClearStencil(Stencil);
         checkGLcall("glClearStencil");
@@ -3870,7 +4837,7 @@
 
     if (Flags & D3DCLEAR_ZBUFFER) {
         glGetBooleanv(GL_DEPTH_WRITEMASK, &old_ztest);
-        glDepthMask(GL_TRUE); 
+        glDepthMask(GL_TRUE);
         glGetFloatv(GL_DEPTH_CLEAR_VALUE, &old_z_clear_value);
         glClearDepth(Z);
         checkGLcall("glClearDepth");
@@ -3880,9 +4847,9 @@
     if (Flags & D3DCLEAR_TARGET) {
         TRACE("Clearing screen with glClear to color %lx\n", Color);
         glGetFloatv(GL_COLOR_CLEAR_VALUE, old_color_clear_value);
-        glClearColor(((Color >> 16) & 0xFF) / 255.0f, 
+        glClearColor(((Color >> 16) & 0xFF) / 255.0f,
                      ((Color >>  8) & 0xFF) / 255.0f,
-                     ((Color >>  0) & 0xFF) / 255.0f, 
+                     ((Color >>  0) & 0xFF) / 255.0f,
                      ((Color >> 24) & 0xFF) / 255.0f);
         checkGLcall("glClearColor");
 
@@ -3890,28 +4857,31 @@
         glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
         glMask = glMask | GL_COLOR_BUFFER_BIT;
     }
-
+TRACE("running through each rect\n");
     /* Now process each rect in turn */
     for (i = 0; i < Count || i == 0; i++) {
 
         if (curRect) {
             /* Note gl uses lower left, width/height */
+            /* TODO: repalce impl usage with iface usage */
             TRACE("(%p) %p Rect=(%ld,%ld)->(%ld,%ld) glRect=(%ld,%ld), len=%ld, hei=%ld\n", This, curRect,
                   curRect->x1, curRect->y1, curRect->x2, curRect->y2,
-                  curRect->x1, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - curRect->y2), 
+                  curRect->x1, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - curRect->y2),
                   curRect->x2 - curRect->x1, curRect->y2 - curRect->y1);
-            glScissor(curRect->x1, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - curRect->y2), 
+            glScissor(curRect->x1, (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - curRect->y2),
                       curRect->x2 - curRect->x1, curRect->y2 - curRect->y1);
             checkGLcall("glScissor");
         } else {
-            glScissor(This->stateBlock->viewport.X, 
-                      (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height - (This->stateBlock->viewport.Y + This->stateBlock->viewport.Height)), 
-                      This->stateBlock->viewport.Width, 
+            glScissor(This->stateBlock->viewport.X,
+                      (((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height -
+                      (This->stateBlock->viewport.Y + This->stateBlock->viewport.Height)),
+                      This->stateBlock->viewport.Width,
                       This->stateBlock->viewport.Height);
             checkGLcall("glScissor");
         }
 
-        /* Clear the selected rectangle (or full screen) */
+        /* Clear the selected r
+        ectangle (or full screen) */
         glClear(glMask);
         checkGLcall("glClear");
 
@@ -3923,15 +4893,15 @@
     if (Flags & D3DCLEAR_STENCIL) {
         glClearStencil(old_stencil_clear_value);
         glStencilMask(This->stateBlock->renderState[WINED3DRS_STENCILWRITEMASK]);
-    }    
+    }
     if (Flags & D3DCLEAR_ZBUFFER) {
         glDepthMask(old_ztest);
         glClearDepth(old_z_clear_value);
     }
     if (Flags & D3DCLEAR_TARGET) {
-        glClearColor(old_color_clear_value[0], 
+        glClearColor(old_color_clear_value[0],
                      old_color_clear_value[1],
-                     old_color_clear_value[2], 
+                     old_color_clear_value[2],
                      old_color_clear_value[3]);
         glColorMask(This->stateBlock->renderState[WINED3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_RED ? GL_TRUE : GL_FALSE,
                     This->stateBlock->renderState[WINED3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_GREEN ? GL_TRUE : GL_FALSE,
@@ -3942,29 +4912,34 @@
     glDisable(GL_SCISSOR_TEST);
     checkGLcall("glDisable");
     LEAVE_GL();
-
     return D3D_OK;
 }
 
 /*****
  * Drawing functions
  *****/
-HRESULT WINAPI IWineD3DDeviceImpl_DrawPrimitive(IWineD3DDevice *iface, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, 
+HRESULT WINAPI IWineD3DDeviceImpl_DrawPrimitive(IWineD3DDevice *iface, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex,
                                                 UINT PrimitiveCount) {
 
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    This->stateBlock->streamIsUP = FALSE;
+    DWORD startTime = 0;
 
-    TRACE("(%p) : Type=(%d,%s), Start=%d, Count=%d\n", This, PrimitiveType, 
-                               debug_d3dprimitivetype(PrimitiveType), 
+    This->stateBlock->streamIsUP = FALSE;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
+    TRACE("(%p) : Type=(%d,%s), Start=%d, Count=%d\n", This, PrimitiveType,
+                               debug_d3dprimitivetype(PrimitiveType),
                                StartVertex, PrimitiveCount);
     drawPrimitive(iface, PrimitiveType, PrimitiveCount, StartVertex, -1, 0, NULL, 0);
 
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+
     return D3D_OK;
 }
 
-/* TODO: baseVIndex needs to be provided from This->stateBlock->baseVertexIndex when called from d3d8 */
-HRESULT  WINAPI  IWineD3DDeviceImpl_DrawIndexedPrimitive(IWineD3DDevice *iface, 
+/** TODO: baseVIndex needs to be provided from This->stateBlock->baseVertexIndex when called from d3d8 **/
+HRESULT  WINAPI  IWineD3DDeviceImpl_DrawIndexedPrimitive(IWineD3DDevice *iface,
                                                            D3DPRIMITIVETYPE PrimitiveType,
                                                            INT baseVIndex, UINT minIndex,
                                                            UINT NumVertices,UINT startIndex,UINT primCount) {
@@ -3973,11 +4948,14 @@
     UINT                 idxStride = 2;
     IWineD3DIndexBuffer *pIB;
     D3DINDEXBUFFER_DESC  IdxBufDsc;
-    
+    DWORD startTime = 0;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
+
     pIB = This->stateBlock->pIndexData;
     This->stateBlock->streamIsUP = FALSE;
 
-    TRACE("(%p) : Type=(%d,%s), min=%d, CountV=%d, startIdx=%d, baseVidx=%d, countP=%d \n", This, 
+    TRACE("(%p) : Type=(%d,%s), min=%d, CountV=%d, startIdx=%d, baseVidx=%d, countP=%d \n", This,
           PrimitiveType, debug_d3dprimitivetype(PrimitiveType),
           minIndex, NumVertices, startIndex, baseVIndex, primCount);
 
@@ -3987,35 +4965,46 @@
     } else {
         idxStride = 4;
     }
-
-    drawPrimitive(iface, PrimitiveType, primCount, baseVIndex, 
-                      startIndex, idxStride, 
+    /** TODO: get rid of the IWineD3DIndexBufferImpl * cast **/
+    drawPrimitive(iface, PrimitiveType, primCount, baseVIndex,
+                      startIndex, idxStride,
                       ((IWineD3DIndexBufferImpl *) pIB)->resource.allocatedMemory,
                       minIndex);
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
 
     return D3D_OK;
 }
 
+
 HRESULT WINAPI IWineD3DDeviceImpl_DrawPrimitiveUP(IWineD3DDevice *iface, D3DPRIMITIVETYPE PrimitiveType,
                                                     UINT PrimitiveCount, CONST void* pVertexStreamZeroData,
                                                     UINT VertexStreamZeroStride) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
-    TRACE("(%p) : Type=(%d,%s), pCount=%d, pVtxData=%p, Stride=%d\n", This, PrimitiveType, 
-             debug_d3dprimitivetype(PrimitiveType), 
-             PrimitiveCount, pVertexStreamZeroData, VertexStreamZeroStride);
-
-    if (This->stateBlock->stream_source[0] != NULL) IWineD3DVertexBuffer_Release(This->stateBlock->stream_source[0]);
-
+    TRACE("(%p) : Type=(%d,%s), pCount=%d, pVtxData=%p, Stride=%d\n", This, PrimitiveType,
+        debug_d3dprimitivetype(PrimitiveType),
+        PrimitiveCount, pVertexStreamZeroData, VertexStreamZeroStride);
+    /* TODO: instancing */
+#if 0 /* move over to using callbacks */
+#else
+    if(This->stateBlock->streamSource[0] != NULL){
+        IWineD3DVertexBuffer_Release(This->stateBlock->streamSource[0]);
+    }
+#endif
+    TRACE("Setting the stream source to something odd\n");
     /* Note in the following, it's not this type, but that's the purpose of streamIsUP */
-    This->stateBlock->stream_source[0] = (IWineD3DVertexBuffer *)pVertexStreamZeroData; 
-    This->stateBlock->stream_stride[0] = VertexStreamZeroStride;
+    This->stateBlock->streamSource[0] = (IWineD3DVertexBuffer *)pVertexStreamZeroData;
+    This->stateBlock->streamStride[0] = VertexStreamZeroStride;
     This->stateBlock->streamIsUP = TRUE;
+    TRACE("calling draw primitive\n");
     drawPrimitive(iface, PrimitiveType, PrimitiveCount, 0, 0, 0, NULL, 0);
-    This->stateBlock->stream_stride[0] = 0;
-    This->stateBlock->stream_source[0] = NULL;
+    /* stream zero settings set to null at end, as per the msdn
+            http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/graphics/reference/d3d/interfaces/idirect3ddevice9/DrawPrimitiveUP.asp
+    */
+    This->stateBlock->streamStride[0] = 0;
+    This->stateBlock->streamSource[0] = NULL;
 
-    /*stream zero settings set to null at end, as per the msdn */
     return D3D_OK;
 }
 
@@ -4024,32 +5013,37 @@
                                                              UINT NumVertexIndices,UINT PrimitiveCount,CONST void* pIndexData,
                                                              WINED3DFORMAT IndexDataFormat, CONST void* pVertexStreamZeroData,
                                                              UINT VertexStreamZeroStride) {
-    int                 idxStride;
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    int                 idxStride;
 
-    TRACE("(%p) : Type=(%d,%s), MinVtxIdx=%d, NumVIdx=%d, PCount=%d, pidxdata=%p, IdxFmt=%d, pVtxdata=%p, stride=%d\n", 
+    TRACE("(%p) : Type=(%d,%s), MinVtxIdx=%d, NumVIdx=%d, PCount=%d, pidxdata=%p, IdxFmt=%d, pVtxdata=%p, stride=%d\n",
              This, PrimitiveType, debug_d3dprimitivetype(PrimitiveType),
-             MinVertexIndex, NumVertexIndices, PrimitiveCount, pIndexData,  
+             MinVertexIndex, NumVertexIndices, PrimitiveCount, pIndexData,
              IndexDataFormat, pVertexStreamZeroData, VertexStreamZeroStride);
 
-    if (This->stateBlock->stream_source[0] != NULL) IWineD3DVertexBuffer_Release(This->stateBlock->stream_source[0]);
-
     if (IndexDataFormat == WINED3DFMT_INDEX16) {
         idxStride = 2;
     } else {
         idxStride = 4;
     }
 
+#if 0 /* move over to using callbacks */
+#else
+    if(This->stateBlock->streamSource[0] != NULL){
+        IWineD3DVertexBuffer_Release(This->stateBlock->streamSource[0]);
+    }
+#endif
+
     /* Note in the following, it's not this type, but that's the purpose of streamIsUP */
-    This->stateBlock->stream_source[0] = (IWineD3DVertexBuffer *)pVertexStreamZeroData;
+    This->stateBlock->streamSource[0] = (IWineD3DVertexBuffer *)pVertexStreamZeroData;
     This->stateBlock->streamIsUP = TRUE;
-    This->stateBlock->stream_stride[0] = VertexStreamZeroStride;
-
+    This->stateBlock->streamStride[0] = VertexStreamZeroStride;
     drawPrimitive(iface, PrimitiveType, PrimitiveCount, 0, 0, idxStride, pIndexData, MinVertexIndex);
-
-    /* stream zero settings set to null at end as per the msdn */
-    This->stateBlock->stream_source[0] = NULL;
-    This->stateBlock->stream_stride[0] = 0;
+    /* stream zero settings set to null at end as per the msdn
+    http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/graphics/reference/d3d/interfaces/idirect3ddevice9/DrawPrimitiveUP.asp
+    */
+    This->stateBlock->streamSource[0] = NULL;
+    This->stateBlock->streamStride[0] = 0;
     IWineD3DDevice_SetIndices(iface, NULL, 0);
 
     return D3D_OK;
@@ -4057,31 +5051,252 @@
 
 HRESULT WINAPI IWineD3DDeviceImpl_UpdateTexture (IWineD3DDevice *iface, IWineD3DBaseTexture *pSourceTexture,  IWineD3DBaseTexture *pDestinationTexture){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    TRACE("(%p) : stub\n", This);
+    /* Well it should be easy, just write from one texture in memory to another in video ram */
+
+
+    D3DRESOURCETYPE sourceType;
+    D3DRESOURCETYPE destinationType;
+    IWineD3DTextureImpl *pDestTexture = (IWineD3DTextureImpl *)pDestinationTexture;
+    IWineD3DTextureImpl *pSrcTexture  = (IWineD3DTextureImpl *)pSourceTexture;
+    int i;    
+    DWORD startTime = 0;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
+
+    sourceType = IWineD3DBaseTexture_GetType(pSourceTexture);
+    destinationType = IWineD3DBaseTexture_GetType(pDestinationTexture);
+    if(sourceType != D3DRTYPE_TEXTURE && destinationType != D3DRTYPE_TEXTURE){
+        FIXME("(%p) Only D3DRTYPE_TEXTURE to D3DRTYPE_TEXTURE supported\n", This);
+        return D3DERR_INVALIDCALL;
+    }
+    TRACE("(%p) Source %p Destination %p\n", This, pSourceTexture, pDestinationTexture);
+
+    /** TODO: Get rid of the casts to IWineD3DBaseTextureImpl
+        repalce surfaces[x] with GetSurfaceLevel, or GetCubeMapSurface etc..
+        think about moving the code into texture, and adding a member to base texture to occomplish this **/
+
+    /* Make sure that the destination textrue is loaded */
+    IWineD3DBaseTexture_PreLoad(pDestinationTexture);
+    TRACE("Loading source texture\n");
+
+    if(pSrcTexture->surfaces[0] == NULL || pDestTexture->surfaces[0] == NULL){
+        FIXME("(%p) Texture src %p or dest %p has not surface %p %p\n", This, pSrcTexture, pDestTexture,
+               pSrcTexture->surfaces[0], pDestTexture->surfaces[0]);
+    }
+
+    if(((IWineD3DSurfaceImpl *)pSrcTexture->surfaces[0])->resource.pool != D3DPOOL_SYSTEMMEM ||
+        ((IWineD3DSurfaceImpl *)pDestTexture->surfaces[0])->resource.pool != D3DPOOL_DEFAULT){
+
+        FIXME("(%p) source %p must be SYSTEMMEM and dest %p must be DEFAULT\n",This, pSrcTexture, pDestTexture);
+        return D3DERR_INVALIDCALL;
+    }
+    /** TODO: check that both textures have the same number of levels  **/
+#if 0
+    if(IWineD3DBaseTexture_GetLevelCount(pDestinationTexture)  !=IWineD3DBaseTexture_GetLevelCount(pSourceTexture))
+            return D3DERR_INVALIDCALL;
+#endif
+    /** TODO: move this code into baseTexture? device should never touch impl*'s **/
+    for(i = 0 ; i < IWineD3DBaseTexture_GetLevelCount(pDestinationTexture) ; i++){
+        IWineD3DDevice_UpdateSurface(iface, pSrcTexture->surfaces[i], NULL, pDestTexture->surfaces[i], NULL);
+    }
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+
     return D3D_OK;
 }
 
-HRESULT  WINAPI  IWineD3DDeviceImpl_StretchRect(IWineD3DDevice *iface, IWineD3DSurface *pSourceSurface,
-                                                CONST RECT* pSourceRect, IWineD3DSurface *pDestinationSurface,
-                                                CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+HRESULT  WINAPI  IWineD3DDeviceImpl_StretchRect(IWineD3DDevice *iface, IWineD3DSurface *pSourceSurface, CONST RECT* pSourceRect, IWineD3DSurface *pDestinationSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) {
+    IWineD3DDeviceImpl  *This         = (IWineD3DDeviceImpl *) iface;
+    /**
+    * TODO: get rid of the cases to IWineD3DSurfaceImpl think about moving the code into surface
+    *         look at ways to implement (converting the dest into a rendertarget and
+    * then writing the texture out seems the 'best' way forward)
+     ******************************************************************/
+
+    IWineD3DSurfaceImpl *pDestSurface = (IWineD3DSurfaceImpl *)pDestinationSurface;
+    IWineD3DSurfaceImpl *pSrcSurface  = (IWineD3DSurfaceImpl *)pSourceSurface;
+    int width, height;
+    RECT sourceLock;
+    RECT destLock;
+    D3DLOCKED_RECT lockedSrcRect;
+    D3DLOCKED_RECT lockedDestRect;
+    static BOOL showFixmes = TRUE;
+
+    if(pSrcSurface->resource.pool != D3DPOOL_DEFAULT  || pDestSurface->resource.pool != D3DPOOL_DEFAULT){
+            /* This shouldn't happen, unless the calling application or wined3d is buggy */
+            WARN("source %p must be DEFAULT and dest %p must be DEFAULT\n", pSrcSurface, pDestSurface);
+            return D3DERR_INVALIDCALL;
+    }
+
+#if 0
+    /** This is a non aligned psudo, software version
+    * an aligned version would always start the origin at the same pixel
+    * and calaulate the error from there, here were just calculating
+    * the error from the starting pixel.
+    * ***********************************/
+    int x1;
+    int y1;
+    int x2;
+    int y2;
+    int dx;
+    int dy;
+
+    for(y1 = 0; y1 < destHeight; y1++){
+        dx=0;
+        for(x1 = 0; x1 < destwidth; x1++){
+
+            /* TODO: optional linearblending */
+            dx+=destwidth;
+            if(dx > sourceWidth){
+                x2 += dx/sourceWidth;
+                dx%=sourceWidth;
+            }
+        }
+        /** TODO: optional linearblending
+        * (colour = adv(etc...,
+        * optional weighted left most, and rightmost blended pixels become weighted blends middle pixels are left)
+        * or where were streaching
+        * color = weighted(y2,y2+1,dy/sourceHeight) =ish (y2 * dy + y2 * (sourceHeight - dy ))/(sourceHeight * 2)
+        * also random noise or other dithering techniques can be used to
+        * make streatching look better by giving it greater 'visuial' colour deapth.
+         **********************************/
+        dy+=destHeight;
+        if(dy > sourceHeight){
+            y2 += dy/sourceHeight;
+            dy%=sourceHeight;
+        }
+
+    }
+#endif
+    if(pSrcSurface->resource.format != pDestSurface->resource.format){
+        D3DCOLOR color = 0xFF0000FF;
+        if(showFixmes)
+        FIXME("Soruce and destination must be the same format\n");
+        /**
+        * FIXME: For now just colour the target area in red!
+        * software implmentation is easy, hardware isn't too hard
+        * but there are lots of performance/compatability playoffs
+            ****************************************************/
+        if(showFixmes)
+            FIXME("(%p) Streaching and filering not yet supported, colouring the target rect in red\n", This);
+        IWineD3DDevice_ColorFill(iface, pDestinationSurface, (D3DRECT*)pDestRect, color);
+
+        showFixmes = FALSE;
+        return D3D_OK;
+    }
+
+    return D3D_OK;
+
+    /** FIXME: This is the slowest possibly way to copy the texture, but it will do for now. */
+    if((pSourceRect->right - pSourceRect->left) != (pDestRect->right - pDestRect->left)
+       || (pSourceRect->bottom - pSourceRect->top) != (pDestRect->bottom - pDestRect->top)){
+        FIXME("Texture scaling not supported\n");
+    }
+    /* no zooming for now either, just copy across the minimum sized block  */
+
+    width  = min((pSourceRect->right - pSourceRect->left), (pDestRect->right - pDestRect->left));
+    height = min((pSourceRect->bottom - pSourceRect->top), (pDestRect->bottom - pDestRect->top));
     
-    TRACE("(%p) : stub\n", This);
+    sourceLock.top    = pSourceRect->top;
+    sourceLock.left   = pSourceRect->left;
+    sourceLock.bottom = pSourceRect->top + height;
+    sourceLock.right  = pSourceRect->left + width;
+
+    destLock.top    = pDestRect->top;
+    destLock.left   = pDestRect->left;
+    destLock.bottom = pDestRect->top + height;
+    destLock.right  = pDestRect->left + width;
+
+
+    IWineD3DSurface_LockRect(pSourceSurface, &lockedSrcRect, &sourceLock, D3DLOCK_READONLY);
+    IWineD3DSurface_LockRect(pDestinationSurface, &lockedDestRect, &destLock, 0);
+
+    /* copy across the data! */
+    {
+    int y;
+    int srcoff  = 0;
+    int destoff = 0;
+    for(y = 0 ; y < height; y++){
+        memcpy(((char *)lockedDestRect.pBits) +srcoff, ((char *)lockedSrcRect.pBits) +destoff, width * pSrcSurface->bytesPerPixel);
+    }
+    srcoff+=  lockedSrcRect.Pitch;
+    destoff+= lockedDestRect.Pitch;
+
+    }
+    IWineD3DSurface_UnlockRect(pSourceSurface);
+    IWineD3DSurface_UnlockRect(pDestinationSurface);
+    /* we need to make sure that the format is the same.... */
+
     return D3D_OK;
+
 }
+
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetRenderTargetData(IWineD3DDevice *iface, IWineD3DSurface *pRenderTarget, IWineD3DSurface *pSurface){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    TRACE("(%p) : stub\n", This);
-    return D3D_OK;
+IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+/** TODO: remove remove casts to IWineD3DSurfaceImpl *
+ *  NOTE It may be best to move the code into surface to occomplish this
+  ****************************************/
+
+    IWineD3DSurfaceImpl *renderTarget = (IWineD3DSurfaceImpl *)pRenderTarget;
+    IWineD3DSurfaceImpl *surface = (IWineD3DSurfaceImpl *)pSurface;
+    GLenum format;
+    GLenum type;
+    IWineD3DSwapChainImpl *container = NULL;
+    ENTER_GL();
+
+   /* check to see if it's the backbuffer or the frontbuffer being requested (to make sureteh data is upto date)*/
+            format = D3DFmt2GLFmt(This, surface->resource.format);
+            type   = D3DFmt2GLType(This, surface->resource.format);
+
+            /* Ok, I may need to setup some kind of active  swapchain reference on the device */
+            IWineD3DSurface_GetContainer(pRenderTarget, &IID_IWineD3DSwapChain, (void **)&container);
+
+            /* TODO: opengl Context switching for swapchains etc... */
+            if(NULL != container  || pRenderTarget == This->renderTarget || pRenderTarget == This->depthStencilBuffer){
+#ifndef USE_CONTEXT_MANAGER /* TODO: opengl context managers */
+                if (NULL != container  && (pRenderTarget == container->backBuffer)) {
+                    glReadBuffer(GL_BACK);
+                } else if ((NULL != container  && (pRenderTarget == container->frontBuffer)) || (pRenderTarget == This->renderTarget)) {
+                    glReadBuffer(GL_FRONT);
+                } else if (pRenderTarget == This->depthStencilBuffer) {
+                    FIXME("Reading of depthstencil not yet supported\n");
+                }
+
+                glReadPixels(0,
+                            0,
+                            surface->currentDesc.Width,
+                            surface->currentDesc.Height,
+                            format,
+                            type,
+                            surface->resource.allocatedMemory);
+#endif
+                if(NULL != container ){
+                    IWineD3DSwapChain_Release((IWineD3DSwapChain*) container);
+                }
+            }else{
+                glEnable(GL_TEXTURE_2D);
+                vcheckGLcall("glEnable(GL_TEXTURE_2D)");
+                glBindTexture(GL_TEXTURE_2D,renderTarget->textureName);
+                vcheckGLcall("glBindTexture");
+                glGetTexImage(GL_TEXTURE_2D,
+                    renderTarget->currentDesc.Level,
+                    format,
+                    type,
+                    surface->resource.allocatedMemory);
+            }
+        LEAVE_GL();
+        return D3D_OK;
 }
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetFrontBufferData(IWineD3DDevice *iface,UINT iSwapChain, IWineD3DSurface *pDestSurface){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
-    TRACE("(%p) : stub\n", This);
-    return D3D_OK;
+    IWineD3DSwapChain *swapChain;
+    HRESULT hr;
+    hr = IWineD3DDeviceImpl_GetSwapChain(iface,  iSwapChain, (IWineD3DSwapChain **)&swapChain);
+    if(hr == D3D_OK){
+        hr = IWineD3DSwapChain_GetFrontBufferData(swapChain, pDestSurface);
+                IWineD3DSwapChain_Release(swapChain);
+    }
+    return hr;
 }
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_ValidateDevice(IWineD3DDevice *iface, DWORD* pNumPasses) {
@@ -4093,7 +5308,7 @@
 }
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_SetPaletteEntries(IWineD3DDevice *iface, UINT PaletteNumber, CONST PALETTEENTRY* pEntries) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;  
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     FIXME("(%p) : stub\n", This);
     return D3D_OK;
 }
@@ -4132,9 +5347,19 @@
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetRasterStatus(IWineD3DDevice *iface, UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-        
-    pRasterStatus->InVBlank = TRUE;
-    pRasterStatus->ScanLine = 0;
+    IWineD3DSwapChain *swapChain;
+    HRESULT hr;
+
+    TRACE("(%p) :  SwapChain %d returning %p\n", This, iSwapChain, pRasterStatus);
+
+    hr = IWineD3DDeviceImpl_GetSwapChain(iface,  iSwapChain, (IWineD3DSwapChain **)&swapChain);
+    if(hr == D3D_OK){
+        hr = IWineD3DSwapChain_GetRasterStatus(swapChain, pRasterStatus);
+        IWineD3DSwapChain_Release(swapChain);
+    }else{
+        FIXME("(%p) IWineD3DSwapChain_GetRasterStatus returned in error \n", This);
+    }
+    return hr;
     FIXME("(%p) : stub\n", This);
     return D3D_OK;
 }
@@ -4164,8 +5389,95 @@
 
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_UpdateSurface(IWineD3DDevice *iface, IWineD3DSurface *pSourceSurface, CONST RECT* pSourceRect, IWineD3DSurface *pDestinationSurface, CONST POINT* pDestPoint) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
-    FIXME("(%p) : stub\n", This);
+
+    IWineD3DDeviceImpl  *This         = (IWineD3DDeviceImpl *) iface;
+    /** TODO: remove casts to IWineD3DSurfaceImpl
+     *       NOTE: move code to surface to occomplish this
+      ****************************************/
+    IWineD3DSurfaceImpl *pDestSurface = (IWineD3DSurfaceImpl *)pDestinationSurface;
+    IWineD3DSurfaceImpl *pSrcSurface  = (IWineD3DSurfaceImpl *)pSourceSurface;
+    int srcWidth, srcHeight;
+    int destLeft, destTop;
+    int offset    = 0;
+    int rowoffset = 0; /* how many bytes to add onto the end of a row to wraparound to the begining of the next */
+
+    if(pSrcSurface->resource.pool != D3DPOOL_SYSTEMMEM  || pDestSurface->resource.pool != D3DPOOL_DEFAULT){
+        FIXME("source %p must be SYSTEMMEM and dest %p must be DEFAULT\n", pSrcSurface, pDestSurface);
+        return D3DERR_INVALIDCALL;
+    }
+    /* TODO:  change this to use bindTexture */
+    /* Make sure the surface is loaded */
+    IWineD3DSurface_PreLoad(pDestinationSurface);
+    ENTER_GL();
+
+    /* this needs to be done in lines if the sourceRect != the sourceWidth */
+    srcWidth   = pSourceRect ? pSourceRect->right - pSourceRect->left   : pSrcSurface->currentDesc.Width;
+    srcHeight  = pSourceRect ? pSourceRect->top   - pSourceRect->bottom : pSrcSurface->currentDesc.Height;
+    destLeft   = pDestPoint  ? pDestPoint->x : 0;
+    destTop    = pDestPoint  ? pDestPoint->y : 0;
+
+
+    /* This function doesn't support compressed textures
+    the pitch is just bytesPerPixel * width */
+
+    if(srcWidth != pSrcSurface->currentDesc.Width  || (pSourceRect != NULL && pSourceRect->left != 0) ){
+        rowoffset = (pSrcSurface->currentDesc.Width - srcWidth) * pSrcSurface->bytesPerPixel;
+        offset   += pSourceRect->left * pSrcSurface->bytesPerPixel;
+        /* TODO: do we ever get 3bpp?, would a shift and an add be quicker than a mul (well maybe a cycle or two) */
+    }
+    if(pSourceRect != NULL && pSourceRect->top != 0){
+       offset +=  pSourceRect->top * pSrcSurface->currentDesc.Width * pSrcSurface->bytesPerPixel;
+    }
+    TRACE("glTexSubImage2D, Level %d, left %d, top %d, width %d, height %d ,ftm %d, type %d, memory %p\n"
+    ,pDestSurface->currentDesc.Level
+    ,destLeft
+    ,destTop
+    ,srcWidth
+    ,srcHeight
+    ,D3DFmt2GLFmt(This, pSrcSurface->resource.format)
+    ,D3DFmt2GLType(This, pSrcSurface->resource.format)
+    ,pSrcSurface->resource.allocatedMemory
+    );
+    if(pSrcSurface->resource.allocatedMemory == NULL){
+    /* need to lock the surface to get the data */
+       FIXME("Surfaces has no allocated memory, but should be an in memory only surface\n");
+    }
+
+    if(rowoffset != 0){
+        /* not a whole row so we have to do it a line at a time */
+        int j;
+        /* hopefully using pointer addtion will be quicker than using a point + j * rowoffset */
+        unsigned char* data =((unsigned char *)pSrcSurface->resource.allocatedMemory) + offset;
+
+        for(j = destTop ; j < (srcHeight + destTop) ; j++){
+
+                glTexSubImage2D( GL_TEXTURE_2D
+                ,pDestSurface->currentDesc.Level
+                ,destLeft
+                ,j
+                ,srcWidth
+                ,1
+                ,D3DFmt2GLFmt(This, pSrcSurface->resource.format)
+                ,D3DFmt2GLType(This, pSrcSurface->resource.format)
+                ,data/* could be quicker using */
+            );
+            data+=rowoffset;
+        }
+    }else{ /* Full width, so just write out the whole texture */
+        glTexSubImage2D( GL_TEXTURE_2D
+                ,pDestSurface->currentDesc.Level
+                ,destLeft
+                ,destTop
+                ,srcWidth
+                ,srcHeight
+                ,D3DFmt2GLFmt(This, pSrcSurface->resource.format)
+                ,D3DFmt2GLType(This, pSrcSurface->resource.format)
+                ,pSrcSurface->resource.allocatedMemory
+            );
+     }
+    checkGLcall("glTexSubImage2D");
+    glDisable(GL_TEXTURE_2D);
+    LEAVE_GL();
     return D3D_OK;
 
 }
@@ -4194,39 +5506,164 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DDeviceImpl_DeletePatch(IWineD3DDevice *iface, UINT Handle){    
+HRESULT WINAPI IWineD3DDeviceImpl_DeletePatch(IWineD3DDevice *iface, UINT Handle){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
     TRACE("(%p) Handle(%d)\n", This, Handle);
     FIXME("(%p) : Stub\n", This);
     return D3D_OK;
-} 
+}
+
 
 HRESULT WINAPI IWineD3DDeviceImpl_ColorFill(IWineD3DDevice *iface, IWineD3DSurface *pSurface, CONST D3DRECT* pRect, D3DCOLOR color){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
 
-    FIXME("(%p) : stub\n", This);
+    /* I couldn't find a 'really' quick way of doing this in openGl so here goes
+    fill a surface with a block of color!  */
+
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    /* TODO: get rid of the use of IWineD3DSurfaceImpl, move code into surface.c */
+    IWineD3DSurfaceImpl *surface = (IWineD3DSurfaceImpl *)pSurface;
+    IWineD3DSwapChainImpl *container = NULL;
+    BOOL isRenderTarget = FALSE;
+    unsigned int width,height;
+    unsigned int top,left;
+    unsigned int u, v;
+    DWORD        *data;
+    TRACE("(%p) Colour fill Surface: %p rect: %p color: %ld\n", This, pSurface, pRect, color);
+
+    if(surface->resource.pool != D3DPOOL_DEFAULT){
+        FIXME("call to colorfill with non D3DPOOL_DEFAULT surface\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    /* TODO: get rid of IWineD3DSwapChainImpl reference, a 'context' manager may help with this */
+    IWineD3DSurface_GetContainer(pSurface, &IID_IWineD3DSwapChain, (void **)&container);
+
+    if(NULL != container || pSurface == This->renderTarget){
+        if(surface->resource.usage & D3DUSAGE_RENDERTARGET){
+
+            /* TODO: make sure we set everything back to the way it was, and context management!
+                glGetIntegerv(GL_READ_BUFFER, &prev_read);
+                vcheckGLcall("glIntegerv");
+                glGetIntegerv(GL_PACK_SWAP_BYTES, &prev_store);
+                vcheckGLcall("glIntegerv");
+            */
+            TRACE("Color fill to render targets may cause some graphics issues\n");
+
+            /* return D3D_OK;  Try this if you get raster problems (or just implement state saving!)*/
+#ifndef USE_RENDER_MANAGER /* TODO: opengl context managers */
+            if(pSurface == container->frontBuffer){
+                glDrawBuffer(GL_FRONT);
+            }else{
+                glDrawBuffer(GL_BACK);
+            }
+            if(container != NULL){
+                IWineD3DSwapChain_Release((IWineD3DSwapChain *)container);
+            }
+#endif
+        }else{
+            if(pSurface != This->renderTarget && D3DUSAGE_DEPTHSTENCIL & surface->resource.usage){
+                FIXME("colouring of depth_stencil? %p buffers is not yet supported? %ld \n", surface, surface->resource.usage);
+            }else{
+               /* in theory we should never get here, but it has once so put some sanity checks in just incase it happens again */
+               if(pSurface == This->renderTarget){
+                FIXME("REGRESSION: This surface has been set as a render target, but doesn't have a usage of render target surface  %p, usage %ld!  \n",
+                surface, surface->resource.usage);
+               }else{
+                if(pSurface == container->frontBuffer || pSurface == container->backBuffer){
+                    FIXME("REGRESSION: front or back buffer of the swapchain has invalid usage flags\n");
+                } if(container != NULL){
+                    FIXME("REGRESSION: 'unknown' surface has swaphcain %p  as parent (odd!) %p, usage %ld! \n",container,
+                           surface, surface->resource.usage);
+                }else{
+                    FIXME("REGRESSION: Trying to color an 'unknown' surface  %p, usage %ld! \n",surface, surface->resource.usage);
+                }
+               }
+            }
+            /* we can use GL_STENCIL_INDEX etc...*/
+            return D3D_OK;
+        }
+        isRenderTarget = TRUE;
+    }
+    /* TODO: drawing to GL_FRONT and GL_BACK */
+
+    if(isRenderTarget == FALSE){
+        IWineD3DSurface_PreLoad(pSurface);
+    }
+    /* TODO: see if things can be speeded up by using the correct
+     * colour model of the target texture from the start (16 bit graphics on 32 X are slow anyway!) */
+    if(pRect == NULL){
+        top    = 0;
+        left   = 0;
+        width  = surface->currentDesc.Width;
+        height = surface->currentDesc.Height;
+    }else{
+        left   = pRect->x1;
+        top    = pRect->y1;
+        width  = pRect->x2 - left;
+        height = pRect->y2 - top;
+    }
+
+    data = HeapAlloc(GetProcessHeap(), 0, 4 * width);
+    /* Create a 'line' of color color, in the correct format for the surface */
+    for(u = 0 ; u < width ; u ++){
+            data[u] = color;
+    }
+
+    ENTER_GL();
+    if(isRenderTarget == FALSE){
+        glEnable(GL_TEXTURE_2D);
+        checkGLcall("glEnable");
+        glBindTexture(GL_TEXTURE_2D, surface->textureName);
+        checkGLcall("glBindTexture");
+
+        /* draw a block of that line on the sufrace */
+        for(v = 0 ; v< height;v++){
+            glTexSubImage2D( GL_TEXTURE_2D
+                            ,0 /* level */
+                            ,left
+                            ,top + v
+                            ,width
+                            ,1 /* height */
+                            ,GL_RGBA
+                            ,GL_UNSIGNED_BYTE
+                            ,data
+                            );
+        }
+        checkGLcall("glTexSubImage2D"); /* only do this once not 1000 times in the loop! */
+
+        /* clean up */
+        glDisable(GL_TEXTURE_2D);
+    }else{
+        /** FIXME: Using GLClear may be faster **/
+        glRasterPos2i(left, top);
+        glPixelZoom((float)width ,(float)height);
+        glDrawPixels(1, 1, GL_RGBA, GL_UNSIGNED_BYTE, data);
+        checkGLcall("glDrawPixels");
+    }
+    HeapFree(GetProcessHeap(),0,data);
+    LEAVE_GL();
     return D3D_OK;
 }
 
 /* rendertarget and deptth stencil functions */
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetRenderTarget(IWineD3DDevice* iface,DWORD RenderTargetIndex, IWineD3DSurface **ppRenderTarget){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    
+
     /* FIXME: Implelent RenderTargetIndex >0 */
     if(RenderTargetIndex > 0)
-        FIXME("(%p) : RenderTargetIndex %ld >0 not currently supported\n", This, RenderTargetIndex);
-    
-    *ppRenderTarget = (IWineD3DSurface *)This->renderTarget;
+        FIXME("(%p) : RenderTargetIndex %ld >0 not currently supported\n",This,RenderTargetIndex);
+
+    *ppRenderTarget = This->renderTarget;
     TRACE("(%p) : RenderTarget %ld Index returning %p\n", This, RenderTargetIndex, *ppRenderTarget);
     /* Note inc ref on returned surface */
-    if(*ppRenderTarget != NULL)
-        IWineD3DSurface_AddRef(*ppRenderTarget);
+    IWineD3DSurface_AddRef(*ppRenderTarget);
     return D3D_OK;
 }
 
+
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetDepthStencilSurface(IWineD3DDevice* iface, IWineD3DSurface **ppZStencilSurface){
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
-    *ppZStencilSurface = (IWineD3DSurface *)This->depthStencilBuffer;
+    *ppZStencilSurface = This->depthStencilBuffer;
     TRACE("(%p) : zStencilSurface  returning %p\n", This,  *ppZStencilSurface);
 
     if(*ppZStencilSurface != NULL){
@@ -4236,27 +5673,549 @@
     return D3D_OK;
 }
 
+/* internal static helper functions */
+HRESULT WINAPI static IWineD3DDeviceImpl_ActiveRender(IWineD3DDevice* iface,
+                                                IWineD3DSurface *RenderSurface);
+
+HRESULT WINAPI static IWineD3DDeviceImpl_CleanRender(IWineD3DDevice* iface, IWineD3DSwapChainImpl *swapchain);
+
 HRESULT WINAPI IWineD3DDeviceImpl_SetRenderTarget(IWineD3DDevice *iface, DWORD RenderTargetIndex, IWineD3DSurface *pRenderTarget){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    HRESULT  hr = D3D_OK;
+    WINED3DVIEWPORT viewport;
 
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
+    DWORD startTime = 0;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount();
+
+    TRACE("(%p) Swapping rendertarget\n",This);
+    if(RenderTargetIndex>0){
+        FIXME("(%p) Render targets other than the first are not supported\n",This);
+        RenderTargetIndex=0;
+    }
+
+    /* Hmm.. what does msdn say?, not a lot except that null disables the render target
+    but a device must always be associatated with a render target
+    nope MSDN says that we return invalid call to a null rendertarget with an index of 0
+
+    see http://msdn.microsoft.com/library/default.asp?url=/library/en-us/directx9_c/directx/graphics/programmingguide/AdvancedTopics/PixelPipe/MultipleRenderTarget.asp
+    for more details
+    */
+    if(RenderTargetIndex == 0 && pRenderTarget == NULL){
+        FIXME("Trying to set render target 0 to NULL\n");
+        return D3DERR_INVALIDCALL;
+    }
+    /* TODO: raplce Impl* usage with interface usage */
+    if(! ((IWineD3DSurfaceImpl *)pRenderTarget)->resource.usage & D3DUSAGE_RENDERTARGET){
+        FIXME("(%p)Trying to set the render target to a surface(%p) that wasn't created with a usage of D3DUSAGE_RENDERTARGET\n",This ,pRenderTarget);
+        return D3DERR_INVALIDCALL;
+    }
+    /** TODO: check that the depth stencil format matches the render target, this is only done in debug
+     *        builds, but I think wine counts as a 'debug' build for now.
+      ******************************/
+    /* If we are trying to set what we already have, don't bother */
+    if (pRenderTarget == This->renderTarget) {
+        TRACE("Trying to do a NOP SetRenderTarget operation\n");
+    } else {
+        /* Otherwise, set the render target up */
+        TRACE("clearing renderer\n");
+        /* IWineD3DDeviceImpl_CleanRender(iface); */
+        /* OpenGL doesn't support 'sharing' of the stencilBuffer so we may incure an extra memory overhead
+        depending on the renter target implemenattion being used.
+        A shared context implementation will share all buffers between all rendertargets (including swapchains),
+        implemenations that use serperate pbuffers for different swapchains or rendertargets will have to duplicate the
+        stencil buffer and incure an extra memory overhead */
+        hr = IWineD3DDeviceImpl_ActiveRender(iface, pRenderTarget);
+    }
+
+    if (SUCCEEDED(hr)) {
+        /* Finally, reset the viewport as the MSDN states. */
+        /* TODO: Repalace impl usage */
+        viewport.Height = ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height;
+        viewport.Width  = ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Width;
+        viewport.X      = 0;
+        viewport.Y      = 0;
+        viewport.MaxZ   = 1.0f;
+        viewport.MinZ   = 0.0f;
+        IWineD3DDeviceImpl_SetViewport(iface, &viewport);
+    }else{
+        FIXME("Unknown error setting the render target\n");
+    }
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+    return hr;
 }
 
 HRESULT WINAPI IWineD3DDeviceImpl_SetDepthStencilSurface(IWineD3DDevice *iface, IWineD3DSurface *pNewZStencil){
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    HRESULT  hr = D3D_OK;
+    WINED3DVIEWPORT viewport;
+    DWORD startTime = 0;
+    IWineD3DSurface *tmp;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount();
+    TRACE("(%p) Swapping z-buffer\n",This);
+
+    if(pNewZStencil == This->stencilBufferTarget){
+        TRACE("Trying to do a NOP SetRenderTarget operation\n");
+    }else{
+        /** OpenGL doesn't support 'sharing' of the stencilBuffer so we may incure an extra memory overhead
+        * depending on the renter target implemenattion being used.
+        * A shared context implementation will share all buffers between all rendertargets (including swapchains),
+        * implemenations that use serperate pbuffers for different swapchains or rendertargets will have to duplicate the
+        * stencil buffer and incure an extra memory overhead
+         ******************************************************/
+
+
+        tmp = This->stencilBufferTarget;
+        This->stencilBufferTarget = pNewZStencil;
+        /* should we be calling the parent or the wined3d surface? */
+        if (NULL != This->stencilBufferTarget) IWineD3DSurface_AddRef(This->stencilBufferTarget);
+        if (NULL != tmp) IWineD3DSurface_Release(tmp);
+        hr = D3D_OK;
+        /** TODO: glEnable/glDisable on depth/stencil    depending on
+         *   pNewZStencil is NULL and the depth/stencil is enabled in d3d
+          **********************************************************/
+    }
+
+    if (SUCCEEDED(hr)) {
+        /* Finally, reset the viewport as the MSDN states.*/
+        /* TODO: get ridd of Impl usage */
+        viewport.Height = ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height;
+        viewport.Width  = ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Width;
+        viewport.X      = 0;
+        viewport.Y      = 0;
+        viewport.MaxZ   = 1.0f;
+        viewport.MinZ   = 0.0f;
+        IWineD3DDeviceImpl_SetViewport(iface, &viewport);
+    }
+
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+    return hr;
+}
+
+
+/* Internal functions not in DirectX */
+ /** TODO: move this off to the opengl context manager
+ *(the swapchain doesn't need to know anything about offscreen rendering!)
+  ****************************************************/
+
+HRESULT WINAPI IWineD3DDeviceImpl_CleanRender(IWineD3DDevice* iface, IWineD3DSwapChainImpl *swapchain)
+{
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    DWORD startTime = 0;
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount();
+#if defined(GL_VERSION_1_3) /* @see comments on ActiveRender */
+
+    TRACE("(%p), %p\n", This, swapchain);
+
+    if(swapchain->win != swapchain->drawable) {
+        ENTER_GL();
+        if(swapchain->glCtx != swapchain->render_ctx) {
+            FIXME("Destroying context %p \n", swapchain->render_ctx);
+            glXDestroyContext(swapchain->display, swapchain->render_ctx);
+
+        }
+        FIXME("glXDestroyPbuffer %ld \n", swapchain->drawable);
+        glXDestroyPbuffer(swapchain->display, swapchain->drawable);
+#endif
+        LEAVE_GL();
+        /* Set everything back to the way that it ws */
+        swapchain->render_ctx = swapchain->glCtx;
+        swapchain->drawable = swapchain->win;
+    }
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+  return D3D_OK;
+}
+
+/** FIXME: This is currently used called whenever SetRenderTarget or SetStencilBuffer are called
+* the functiolaity needs splitting up so that we don't do more than we should do.
+* this only seems to affect performance a little.
+ ******************************/
+HRESULT WINAPI IWineD3DDeviceImpl_ActiveRender(IWineD3DDevice* iface,
+                                               IWineD3DSurface *RenderSurface) {
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+#ifndef USE_RENDER_MANAGER
+
+  IWineD3DSurface *StencilSurface = This->stencilBufferTarget;
+  HRESULT ret =  D3DERR_INVALIDCALL;
+  /**
+   * Currently only active for GLX >= 1.3
+   * for others versions we'll have to use GLXPixmaps
+   *
+   * normally we must test GLX_VERSION_1_3 but nvidia headers are not correct
+   * as they implements GLX 1.3 but only define GLX_VERSION_1_2
+   * so only check OpenGL version
+   * ..........................
+   * I don't belive that it is a problem with NVidia headers,
+   * XFree only supports GLX1.2, nVidia (and ATI to some extent) provide 1.3 functions
+   * in GLX 1.2, there is no mention of the correct way to tell if the extensions are provided.
+   * ATI Note:
+   * Your application will report GLX version 1.2 on glXQueryVersion.
+   * However, it is safe to call the GLX 1.3 functions as described below.
+   */
+#if defined(GL_VERSION_1_3)
+
+    /** TODO: we only need to look up the configuration !IF! we are setting the target to a texture **/
+    GLXFBConfig* cfgs = NULL;
+    int nCfgs = 0;
+    int attribs[256];
+    int nAttribs = 0;
+    IWineD3DSwapChain     *currentSwapchain;
+    IWineD3DSwapChainImpl *swapchain;
+    /** TODO: get rid of Impl usage we should always create a zbuffer/stencil with our contexts if pussible,
+    * but switch them off if the StencilSurface is set to NULL
+    ** *********************************************************/
+    D3DFORMAT BackBufferFormat = ((IWineD3DSurfaceImpl *) RenderSurface)->resource.format;
+    D3DFORMAT StencilBufferFormat = (NULL != StencilSurface) ? ((IWineD3DSurfaceImpl *) StencilSurface)->resource.format : 0;
+    UINT Width = ((IWineD3DSurfaceImpl *) RenderSurface)->currentDesc.Width;
+    UINT Height = ((IWineD3DSurfaceImpl *) RenderSurface)->currentDesc.Height;
+
+    IWineD3DSurface *tmp;
+
+    /**TODO:
+        if StencilSurface == NULL && zBufferTarget != NULL then swtich the zbuffer off,
+        it StencilSurface != NULL && zBufferTarget == NULL switch it on
+    */
+
+#define PUSH1(att)        attribs[nAttribs++] = (att);
+#define PUSH2(att,value)  attribs[nAttribs++] = (att); attribs[nAttribs++] = (value);
+
+    /* PUSH2(GLX_BIND_TO_TEXTURE_RGBA_ATI, True); examples of this are few and far between (but I've got a nice working one!)*/
+
+    /** TODO: remove the reff to Impl (context manager should fis this!) **/
+    IWineD3DSwapChainImpl *impSwapChain;
+    IWineD3DDevice_GetSwapChain(iface, 0, (IWineD3DSwapChain **)&impSwapChain);
+    if(NULL == impSwapChain){ /* NOTE: This should NEVER fail */
+        ERR("(%p) Failed to get a the implicite swapchain\n", iface);
+    }
+
+    ENTER_GL();
+
+    PUSH2(GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT);
+    PUSH2(GLX_X_RENDERABLE,  TRUE);
+    PUSH2(GLX_DOUBLEBUFFER, TRUE);
+    TRACE("calling makeglcfg\n");
+    D3DFmtMakeGlCfg(BackBufferFormat, StencilBufferFormat, attribs, &nAttribs, FALSE /* alternate */);
+
+    PUSH1(None);
+
+
+    TRACE("calling chooseFGConfig\n");
+    cfgs = glXChooseFBConfig(impSwapChain->display, DefaultScreen(impSwapChain->display),
+                                                     attribs, &nCfgs);
+
+    if(!cfgs){ /* OK we didn't find the exact config, so use any reasonably match */
+        /* TODO: fill in the 'requested' and 'current' depths, also make sure that's
+           why we failed and only show this message once! */
+        MESSAGE("Failed to find exact match, finding alternative but you may suffer performance issues, try changing xfree's depth to match the requested depth\n"); /**/
+        nAttribs = 0;
+        PUSH2(GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT | GLX_WINDOW_BIT);
+       /* PUSH2(GLX_X_RENDERABLE,  TRUE); */
+        PUSH2(GLX_RENDER_TYPE,   GLX_RGBA_BIT);
+        PUSH2(GLX_DOUBLEBUFFER, FALSE);
+        TRACE("calling makeglcfg\n");
+        D3DFmtMakeGlCfg(BackBufferFormat, StencilBufferFormat, attribs, &nAttribs, TRUE /* alternate */);
+        PUSH1(None);
+        cfgs = glXChooseFBConfig(impSwapChain->display, DefaultScreen(impSwapChain->display),
+                                                        attribs, &nCfgs);
+    }
+
+#if 0
+    if (NULL != cfgs) {
+#if 0 /* find the best possible config (should try to get the closest match to the texture format */
+            int bestConfig = 0;
+        int minBits = 0x7FFFFFFF;
+        for (int i = 0; i < nConfigs; i++){
+            int red, green, blue, alpha, depth, stencil;
+            glXGetFBConfigAttrib(display, configs[i], GLX_RED_SIZE,     &red);
+            glXGetFBConfigAttrib(display, configs[i], GLX_GREEN_SIZE,   &green);
+            glXGetFBConfigAttrib(display, configs[i], GLX_BLUE_SIZE,    &blue);
+            glXGetFBConfigAttrib(display, configs[i], GLX_ALPHA_SIZE,   &alpha);
+            glXGetFBConfigAttrib(display, configs[i], GLX_DEPTH_SIZE,   &depth);
+            glXGetFBConfigAttrib(display, configs[i], GLX_STENCIL_SIZE, &stencil);
+
+            int bits = red + green + blue + alpha + depth + stencil;
+            if (bits < minBits){
+                bestConfig = i;
+                minBits = bits;
+            }
+        }
+
+#endif
+        TRACE("found config\n");
+
+#ifdef EXTRA_TRACES
+        int i;
+        for (i = 0; i < nCfgs; ++i) {
+            TRACE("for (%u,%s)/(%u,%s) found config[%d]@%p\n", BackBufferFormat,
+            debug_d3dformat(BackBufferFormat), StencilBufferFormat,
+            debug_d3dformat(StencilBufferFormat), i, cfgs[i]);
+        }
+#endif
+#endif
+    if (NULL != This->renderTarget) {
+#ifdef EXTRA_TRACES
+        glFlush();
+        vcheckGLcall("glFlush");
+        /** This is only usefuly if the old render target was a swapchain,
+        * we need to supercede this with a function that displays
+        * the current buffer on the screen. This is easy to do in glx1.3 but
+        * we need to do copy-write pixels in glx 1.2.
+         ************************************************/
+        glXSwapBuffers(impSwapChain->display, impSwapChain->drawable);
+
+        printf("Hit Enter to get next frame ...\n");
+        getchar();
+#endif
+    }
+
+    if(IWineD3DSurface_GetContainer(This->renderTarget, &IID_IWineD3DSwapChain, (void **)&currentSwapchain) != D3D_OK){
+        /* the selected render target doesn't belong to a swapchain, so use the devices implicite swapchain */
+        IWineD3DDevice_GetSwapChain(iface, 0, &currentSwapchain);
+    }
+
+    /**
+    * TODO: remove the use of IWineD3DSwapChainImpl, a context manager will help since it will replace the
+    *  renderTarget = swapchain->backBuffer bit and anything to do with *glContexts
+     **********************************************************************/
+    if(IWineD3DSurface_GetContainer(RenderSurface, &IID_IWineD3DSwapChain, (void **)&swapchain) == D3D_OK){
+        /* We also need to make sure that the lights &co are also in the context of the swapchains */
+        /* FIXME: If the render target gets sent to the frontBuffer should be be presenting it raw? */
+        TRACE("making swapchain active\n");
+        if(RenderSurface != This->renderTarget){
+            if(RenderSurface ==  swapchain->backBuffer){
+            } else {
+                /* This could be flagged so that some operations work directly with the front buffer */
+                FIXME("Attempting to set the  renderTarget to the frontBuffer\n");
+            }
+            if(glXMakeCurrent(swapchain->display, swapchain->win, swapchain->glCtx)
+            == False) {
+                TRACE("Error in setting current context: context %p drawable %ld !\n",
+                       impSwapChain->glCtx, impSwapChain->win);
+            }
+
+
+#if 1 /* TODO: apply the state block to the 'possibly' new context. */
+	    if(1){
+            BOOL oldRecording;
+            IWineD3DStateBlockImpl *oldUpdateStateBlock;
+            oldUpdateStateBlock = This->updateStateBlock;
+            oldRecording= This->isRecordingState;
+            This->isRecordingState = FALSE;
+            This->updateStateBlock = This->stateBlock;
+            IWineD3DStateBlock_Apply((IWineD3DStateBlock *)This->stateBlock);
+
+            This->isRecordingState = oldRecording;
+            This->updateStateBlock = oldUpdateStateBlock;
+	    }
+#endif
+
+#if 0 /* optionally */
+                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+#endif
+
+            IWineD3DDeviceImpl_CleanRender(iface, (IWineD3DSwapChainImpl *)currentSwapchain);
+        }
+        checkGLcall("glXMakeContextCurrent");
+
+        IWineD3DSwapChain_Release((IWineD3DSwapChain *)swapchain);
+    }else
+    if (FALSE && NULL != cfgs  &&
+               (((IWineD3DSwapChainImpl *)currentSwapchain)->drawable == ((IWineD3DSwapChainImpl *)currentSwapchain)->win
+                ||  BackBufferFormat != ((IWineD3DSurfaceImpl *)This->renderTarget)->resource.format
+                || (Width > ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Width
+                ||  Height > ((IWineD3DSurfaceImpl *)This->renderTarget)->currentDesc.Height))) {
+
+        /** ********************************************************************
+        * This code is far too leaky to be usefull IWineD3DDeviceImpl_CleanRender
+        * doesn't seem to work properly and creating a new context Every time is 'extream' overkill.
+        * The code does however work, and should be moved to a context manager to
+        * manage caching of pbuffers or render to texture are appropriate.
+        *
+        * There are some real speed vs compatability issues here:
+        *    we should really use a new context for every texture, but that eats ram.
+        *    we should also be restoring the texture to the pbuffer but that eats CPU
+        *    we can also 'reuse' the current pbuffer if the size is larger than the requested buffer,
+        *    but if this means reusing the display backbuffer then we need to make sure that
+        *    states are correctly preserved.
+        * In many cases I would expect that we can 'skip' some functions, such as preserving states,
+        * and gain a good performance increase at the cost of compatability.
+        * I would suggest that, when this is the case, a user configurable flag be made
+        * available, alowing the user to choose the best emmulated experiance for them.
+         *********************************************************************/
+
+        /**
+        * TODO: support for faces of cube textures, possibly volumes
+        * (this should be easy for ATI as I have examples)
+        **/
+
+        GLXContext  newContext;
+        Drawable    newDrawable;
+        XVisualInfo *visinfo;
+
+        TRACE("making new buffer\n");
+        nAttribs = 0;
+        PUSH2(GLX_PBUFFER_WIDTH,  Width);
+        PUSH2(GLX_PBUFFER_HEIGHT, Height);
+
+#if 0 /* ATI render to texture support */
+        PUSH2(GLX_LARGEST_PBUFFER, True);/* This is ignored by ATI */
+        PUSH2(GLX_TEXTURE_FORMAT_ATI, GLX_TEXTURE_RGBA_ATI);
+        PUSH2(GLX_TEXTURE_TARGET_ATI, cubemap? GLX_TEXTURE_CUBE_MAP_ATI : GLX_TEXTURE_2D_ATI);
+        PUSH2(GLX_MIPMAP_TEXTURE_ATI, mipmapped? True : False);
+#endif
+
+#if 0
+        /* TODO: discardable Pbuffer */
+        PUSH2(GLX_PRESERVED_CONTENTS, FALSE);
+#endif
+
+        PUSH1(None);
+        newDrawable = glXCreatePbuffer(impSwapChain->display, cfgs[0], attribs);
+
+        /** ****************************************
+        *GLX1.3 isn't supported by XFree 'yet' untill that point ATI emulates pBuffers
+        *they note:
+        *   In future releases, we may provide the calls glXCreateNewContext,
+        *   glXQueryDrawable and glXMakeContextCurrent.
+        *    so until then we have to use glXGetVisualFromFBConfig &co..
+         ********************************************/
+
+#define CREATE_ATI_STYLE 1
+#if CREATE_ATI_STYLE
+            visinfo = glXGetVisualFromFBConfig(impSwapChain->display, cfgs[0]);
+            if (!visinfo) {
+                ERR("Error: couldn't get an RGBA, double-buffered visual\n");
+            }
+            newContext = glXCreateContext(impSwapChain->display, visinfo, impSwapChain->glCtx,  GL_TRUE);
+            XFree(visinfo);
+#else
+            newContext = glXCreateNewContext(impSwapChain->display, cfgs[0], GLX_RGBA_TYPE, impSwapChain->glCtx, TRUE);
+
+#endif
+
+        /* Make sure that the sorface exists as a glTexture */
+        IWineD3DSurface_PreLoad(RenderSurface);
+
+#if 0 /* preload must do this for us, if it isn't then fix it. untill then here's some 'debug' code. */
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, Width, Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE_EXT);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE_EXT);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+#endif
+
+        newContext = glXCreateNewContext(impSwapChain->display, cfgs[0], GLX_RGBA_TYPE, impSwapChain->glCtx, TRUE);
+
+        if (NULL == newContext) {
+            ERR("cannot create glxContext\n");
+        }else{
+            /* Debug logging, (this function leaks), change to a TRACE when the leak is plugged */
+            FIXME("Created context %p drawable %ld \n", newContext, newDrawable);
+#if 1 /* If we set the context textures don't load properly, even if they come from memory, but why? */
+#if CREATE_ATI_STYLE
+                if (glXMakeCurrent(impSwapChain->display, newDrawable, newContext) == False) {
+#else
+                if (glXMakeContextCurrent(impSwapChain->display, newDrawable, newDrawable, newContext) == False) {
+#endif
+            TRACE("Error in setting current context: context %p drawable %ld\n", newContext, newDrawable);
+        }
+#endif
+        /* TODO: find out what of the current context needs to be coppied accross */
+
+        checkGLcall("glXMakeContextCurrent");
+
+        /* clean renderer should become part of the context manager so I'm not goint to put in in SwapChain just to remove it */
+        IWineD3DDeviceImpl_CleanRender(iface, (IWineD3DSwapChainImpl *)currentSwapchain);
+        /** TODO: We may need to copy the bits into the buffer,
+        * this should !!ONLY!! be done if an operation is performed on the target
+        * without it being cleared and the buffer is not discardable.
+        * (basicly only bother preserving the contents if there's a possiblity that it will be reused)
+        ** *********************************************************************/
+        impSwapChain->drawable = newDrawable;
+        impSwapChain->render_ctx = newContext;
+
+        }
+
+    }
+    /* clean up the current rendertargets swapchain (if it belonged to one) */
+    if (currentSwapchain != NULL){
+        IWineD3DSwapChain_Release((IWineD3DSwapChain *)currentSwapchain);
+    }
+
+    /* Were done with the opengl context management, setup the rendertargets */
+
+    tmp = This->renderTarget;
+    This->renderTarget = RenderSurface;
+    IWineD3DSurface_AddRef(This->renderTarget);
+    IWineD3DSurface_Release(tmp);
+
+
+
+    {
+        DWORD value;
+        /* The surface must be rendered upside down to cancel the flip produce by glCopyTexImage */
+        /* Check that the container is not a swapchain member */
+
+        IWineD3DSwapChain *tmpSwapChain;
+        if(D3D_OK != IWineD3DSurface_GetContainer(This->renderTarget, &IID_IWineD3DSwapChain, (void **)&tmpSwapChain)){
+            This->renderUpsideDown = TRUE;
+        }else{
+            This->renderUpsideDown = FALSE;
+            IWineD3DSwapChain_Release(tmpSwapChain);
+        }
+        /* Force updating the cull mode */
+        TRACE("setting render state\n");
+        IWineD3DDevice_GetRenderState(iface, WINED3DRS_CULLMODE, &value);
+        IWineD3DDevice_SetRenderState(iface, WINED3DRS_CULLMODE, value);
+
+        /* Force updating projection matrix */
+        This->last_was_rhw = FALSE;
+        This->proj_valid = FALSE;
+    }
+
+    ret = D3D_OK;
+
+    if(cfgs != NULL){
+        XFree(cfgs);
+    } else {
+        ERR("cannot get valides GLXFBConfig for (%u,%s)/(%u,%s)\n", BackBufferFormat,
+            debug_d3dformat(BackBufferFormat), StencilBufferFormat, debug_d3dformat(StencilBufferFormat));
+    }
+
+#undef PUSH1
+#undef PUSH2
+    if( NULL != impSwapChain) {
+        IWineD3DSwapChain_Release((IWineD3DSwapChain *)impSwapChain);
+    }
+    LEAVE_GL();
+
+#endif
+#else
+
+    IWineD3DSurface *tmp;
+    /* This should be handled outside of this function */
+    tmp = This->renderTarget;
+    This->renderTarget = RenderSurface;
+    IWineD3DSurface_AddRef(This->renderTarget);
+    IWineD3DSurface_Release( tmp);
+    tmp = This->stencilBufferTarget;
+    This->stencilBufferTarget = StencilSurface;
+
+#endif
+    return ret;
 
-    FIXME("(%p) : stub\n", This);
-    return D3D_OK;
 }
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_SetCursorProperties(IWineD3DDevice* iface, UINT XHotSpot,
                                                         UINT YHotSpot, IWineD3DSurface *pCursorBitmap) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;    
-    /* TODO: the use of Impl is deprecated. */
-    /* some basic validation checks */    
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
     IWineD3DSurfaceImpl * pSur = (IWineD3DSurfaceImpl *) pCursorBitmap;
-
+    /* some basic validation checks */
     TRACE("(%p) : Spot Pos(%u,%u)\n", This, XHotSpot, YHotSpot);
 
     if (WINED3DFMT_A8R8G8B8 != pSur->resource.format) {
@@ -4268,37 +6227,38 @@
       return D3DERR_INVALIDCALL;
     }
     /* TODO: make the cursor 'real' */
-    
+
     This->xHotSpot = XHotSpot;
     This->yHotSpot = YHotSpot;
-    
-    return D3D_OK;    
+
+    return D3D_OK;
 }
 
 void     WINAPI  IWineD3DDeviceImpl_SetCursorPosition(IWineD3DDevice* iface, int XScreenSpace, int YScreenSpace, DWORD Flags) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
     TRACE("(%p) : SetPos to (%u,%u)\n", This, XScreenSpace, YScreenSpace);
-    
+
     This->xScreenSpace = XScreenSpace;
     This->yScreenSpace = YScreenSpace;
-    
+
     return;
 
 }
 
 BOOL     WINAPI  IWineD3DDeviceImpl_ShowCursor(IWineD3DDevice* iface, BOOL bShow) {
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;    
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
     TRACE("(%p) : visible(%d)\n", This, bShow);
-    
+
     This->bCursorVisible = bShow;
-    
-    return D3D_OK;    
+
+    return D3D_OK;
 }
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_TestCooperativeLevel(IWineD3DDevice* iface) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
     FIXME("(%p) : stub\n", This); /* No way of notifying yet! */
     return D3D_OK;
+
 }
 
 
@@ -4319,7 +6279,7 @@
     * textures out of video memory and deletes all glTextures (glDeleteTextures)
     * and should clear down the context and set it up according to pPresentationParameters
      ***********************************************************/
-    FIXME("(%p) : stub\n", This);    
+    FIXME("(%p) : stub\n", This);
     return D3D_OK;
 }
 
@@ -4329,43 +6289,132 @@
     if(bEnableDialogs == FALSE){
         FIXME("(%p) Dialogs cannot be disabled yet\n", This);
     }
-    return D3D_OK; 
+    return D3D_OK;
 }
 
 
 HRESULT  WINAPI  IWineD3DDeviceImpl_GetCreationParameters(IWineD3DDevice *iface, D3DDEVICE_CREATION_PARAMETERS *pParameters) {
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
-    
+
     FIXME("(%p) : stub\n", This);
     /* Setup some reasonable defaults */
     pParameters->AdapterOrdinal = 0; /* always for now */
     pParameters->DeviceType = D3DDEVTYPE_HAL; /* always for now */
     pParameters->hFocusWindow = 0;
-    pParameters->BehaviorFlags =0;    
+    pParameters->BehaviorFlags =0;
     return D3D_OK;
 }
 
+void WINAPI IWineD3DDeviceImpl_GetGammaRamp(IWineD3DDevice *iface, UINT iSwapChain, D3DGAMMARAMP* pRamp) {
+
+    IWineD3DSwapChain *swapchain;
+    HRESULT hrc = D3D_OK;
+
+    TRACE("Relaying  to swapchain\n");
+
+    if((hrc = IWineD3DDeviceImpl_GetSwapChain(iface, iSwapChain, &swapchain)) == D3D_OK){
+        hrc =IWineD3DSwapChain_GetGammaRamp(swapchain, pRamp);
+        IWineD3DSwapChain_Release(swapchain);
+    }
+    return;
+
+}
+
 void WINAPI IWineD3DDeviceImpl_SetGammaRamp(IWineD3DDevice * iface, UINT iSwapChain, DWORD Flags, CONST D3DGAMMARAMP* pRamp) {
-    HDC hDC;
-    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
-    
-    FIXME("(%p) : pRamp@%p\n", This, pRamp);
-    hDC = GetDC(This->win_handle);
-    SetDeviceGammaRamp(hDC, (LPVOID) pRamp);
-    ReleaseDC(This->win_handle, hDC);
+
+    IWineD3DSwapChain *swapchain;
+    HRESULT hrc = D3D_OK;
+
+    TRACE("Relaying  to swapchain\n");
+
+    if((hrc = IWineD3DDeviceImpl_GetSwapChain(iface, iSwapChain, &swapchain)) == D3D_OK){
+        IWineD3DSwapChain_SetGammaRamp(swapchain, Flags, (D3DGAMMARAMP *)pRamp);
+        IWineD3DSwapChain_Release(swapchain);
+    }
     return;
+
 }
+/** ********************************************************
+*   Notification functions
+** ********************************************************/
+#if 0  /** TODO: notification **/
+/** This function must be called in the release of a resource when ref == 0,
+* the contents of resource must still be correct,
+* any handels to other resource held by the caller must be closed
+* (e.g. a texture should release all held surfaces because telling the device that it's been released.)
+ *****************************************************/
+void IWineD3DDeviceImpl_ResourceReleased(IWineD3DDevice *iface, IWineD3DResource *resource){
 
-void WINAPI IWineD3DDeviceImpl_GetGammaRamp(IWineD3DDevice *iface, UINT iSwapChain, D3DGAMMARAMP* pRamp) {
-    HDC hDC;
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
+#if 0
+    switch(IWineD3DResource_GetType(resource)){
+        case D3DRESOURCE_SURFACE:
+        /* TODO: check front and back buffers, rendertargets etc..  possibly swapchains? */
+        break;
+        case D3DRTYPE_TEXTURE:
+        case D3DRTYPE_CUBETEXTURE:
+        case D3DRTYPE_VOLUMETEXTURE:
+
+        /* TODO: nothing really? */
+        break;
+        case D3DRTYPE_VERTEXBUFFER:
+            int streamNumber;
+            for(streamNumber = 0; streamNumber < MAX_STREAMS; streamNumber ++){
+                /* FINDOUT: should a warn be generated if were recording and updateStateBlock->streamSource is lost?
+                FINDOUT: should changes.streamSource[StreamNumber] be set ?
+                */
+                if((IWineD3DResource *)This->updateStateBlock->streamSource[StreamNumber] == vertexBuffer){
+                    This->updateStateBlock->streamSource[StreamNumber] = 0;
+                }
+                if((IWineD3DResource *)This->stateBlock->streamSource[StreamNumber] == vertexBuffer){
+                    This->updateStateBlock->streamSource[StreamNumber] = 0;
+                }
+
+            }
+        break;
+        case D3DRTYPE_INDEXBUFFER:
+
+        break;
+    }
+
+    HRESULT hr;
+    /* Remove the resoruce from the resourceStore */
+    IListOperator *listOperator;
+    IListStore_CreateListOperator(This->resourceStore, &listOperator);
+    hr = IListOperator_remove(listOperator, (void *)object);
+    if(hr != D3D_OK){
+        FIXME("failed to remove %p from the list\n", object);
+    }
+    IListOperator_Release(listOperator);
+#else
+    FIXME("stub\n");
+#endif
+
+}
+
+/** This function is to be called by the swapchain when it is released and it's ref = 0
+ *****************************************************/
+void IWineD3DDeviceImpl_SwapChainReleased(IWineD3DDevice *iface, IWineD3DSwapChain *swapChain){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *) iface;
+#if 0
+    /** TODO: Use a list operator to remove the swapcahin from the swapchainstore,
+    * check rendertargets still in use **/
+    /* Remove the resoruce from the resourceStore */
+    IListOperator *listOperator;
+    IListStore_CreateListOperator(This->swapChainStore, &listOperator);
+    hr = IListOperator_remove(listOperator, (void *)object);
+    if(hr != D3D_OK){
+        FIXME("failed to remove %p from the list\n", object);
+    }
+    IListOperator_Release(listOperator);
+#else
+    FIXME("stub\n");
+#endif
+
 
-    FIXME("(%p) : pRamp@%p\n", This, pRamp);
-    hDC = GetDC(This->win_handle);
-    GetDeviceGammaRamp(hDC, pRamp);
-    ReleaseDC(This->win_handle, hDC);
-    return;
 }
+#endif
+
 
 /**********************************************************
  * IWineD3DDevice VTbl follows
@@ -4393,9 +6442,9 @@
     IWineD3DDeviceImpl_CreateVertexDeclaration,
     IWineD3DDeviceImpl_CreateVertexShader,
     IWineD3DDeviceImpl_CreatePixelShader,
-    
+
     /*** Odd functions **/
-    IWineD3DDeviceImpl_EvictManagedResources,        
+    IWineD3DDeviceImpl_EvictManagedResources,
     IWineD3DDeviceImpl_GetAvailableTextureMem,
     IWineD3DDeviceImpl_GetBackBuffer,
     IWineD3DDeviceImpl_GetCreationParameters,
@@ -4423,9 +6472,9 @@
     IWineD3DDeviceImpl_SetFVF,
     IWineD3DDeviceImpl_GetFVF,
     IWineD3DDeviceImpl_SetGammaRamp,
-    IWineD3DDeviceImpl_GetGammaRamp,    
+    IWineD3DDeviceImpl_GetGammaRamp,
     IWineD3DDeviceImpl_SetIndices,
-    IWineD3DDeviceImpl_GetIndices,    
+    IWineD3DDeviceImpl_GetIndices,
     IWineD3DDeviceImpl_SetLight,
     IWineD3DDeviceImpl_GetLight,
     IWineD3DDeviceImpl_SetLightEnable,
@@ -4433,7 +6482,7 @@
     IWineD3DDeviceImpl_SetMaterial,
     IWineD3DDeviceImpl_GetMaterial,
     IWineD3DDeviceImpl_SetNPatchMode,
-    IWineD3DDeviceImpl_GetNPatchMode,    
+    IWineD3DDeviceImpl_GetNPatchMode,
     IWineD3DDeviceImpl_SetPaletteEntries,
     IWineD3DDeviceImpl_GetPaletteEntries,
     IWineD3DDeviceImpl_SetPixelShader,
@@ -4459,7 +6508,7 @@
     IWineD3DDeviceImpl_SetStreamSourceFreq,
     IWineD3DDeviceImpl_GetStreamSourceFreq,
     IWineD3DDeviceImpl_SetTexture,
-    IWineD3DDeviceImpl_GetTexture,    
+    IWineD3DDeviceImpl_GetTexture,
     IWineD3DDeviceImpl_SetTextureStageState,
     IWineD3DDeviceImpl_GetTextureStageState,
     IWineD3DDeviceImpl_SetTransform,
@@ -4503,4 +6552,114 @@
     IWineD3DDeviceImpl_GetFrontBufferData,
     /*** Internal use IWineD3DDevice methods ***/
     IWineD3DDeviceImpl_SetupTextureStates
+    /*** Notification functions ***/
+#if 0 /* TODO: part of the interface cleanup work */
+    IWineD3DDeviceImpl_ResourceReleased,
+    IWineD3DDeviceImpl_SwapChainReleased
+#endif
+};
+
+
+DWORD SavedPixelStates_R[NUM_SAVEDPIXELSTATES_R] = {
+    WINED3DRS_ALPHABLENDENABLE   ,
+    WINED3DRS_ALPHAFUNC          ,
+    WINED3DRS_ALPHAREF           ,
+    WINED3DRS_ALPHATESTENABLE    ,
+    WINED3DRS_BLENDOP            ,
+    WINED3DRS_COLORWRITEENABLE   ,
+    WINED3DRS_DESTBLEND          ,
+    WINED3DRS_DITHERENABLE       ,
+    WINED3DRS_FILLMODE           ,
+    WINED3DRS_FOGDENSITY         ,
+    WINED3DRS_FOGEND             ,
+    WINED3DRS_FOGSTART           ,
+    WINED3DRS_LASTPIXEL          ,
+    WINED3DRS_SHADEMODE          ,
+    WINED3DRS_SRCBLEND           ,
+    WINED3DRS_STENCILENABLE      ,
+    WINED3DRS_STENCILFAIL        ,
+    WINED3DRS_STENCILFUNC        ,
+    WINED3DRS_STENCILMASK        ,
+    WINED3DRS_STENCILPASS        ,
+    WINED3DRS_STENCILREF         ,
+    WINED3DRS_STENCILWRITEMASK   ,
+    WINED3DRS_STENCILZFAIL       ,
+    WINED3DRS_TEXTUREFACTOR      ,
+    WINED3DRS_WRAP0              ,
+    WINED3DRS_WRAP1              ,
+    WINED3DRS_WRAP2              ,
+    WINED3DRS_WRAP3              ,
+    WINED3DRS_WRAP4              ,
+    WINED3DRS_WRAP5              ,
+    WINED3DRS_WRAP6              ,
+    WINED3DRS_WRAP7              ,
+    WINED3DRS_ZENABLE            ,
+    WINED3DRS_ZFUNC              ,
+    WINED3DRS_ZWRITEENABLE
+};
+
+DWORD SavedPixelStates_T[NUM_SAVEDPIXELSTATES_T] = {
+    D3DTSS_ADDRESSW              ,
+    D3DTSS_ALPHAARG0             ,
+    D3DTSS_ALPHAARG1             ,
+    D3DTSS_ALPHAARG2             ,
+    D3DTSS_ALPHAOP               ,
+    D3DTSS_BUMPENVLOFFSET        ,
+    D3DTSS_BUMPENVLSCALE         ,
+    D3DTSS_BUMPENVMAT00          ,
+    D3DTSS_BUMPENVMAT01          ,
+    D3DTSS_BUMPENVMAT10          ,
+    D3DTSS_BUMPENVMAT11          ,
+    D3DTSS_COLORARG0             ,
+    D3DTSS_COLORARG1             ,
+    D3DTSS_COLORARG2             ,
+    D3DTSS_COLOROP               ,
+    D3DTSS_RESULTARG             ,
+    D3DTSS_TEXCOORDINDEX         ,
+    D3DTSS_TEXTURETRANSFORMFLAGS
+};
+
+DWORD SavedPixelStates_S[NUM_SAVEDPIXELSTATES_S] = {
+};
+
+DWORD SavedVertexStates_R[NUM_SAVEDVERTEXSTATES_R] = {
+    WINED3DRS_AMBIENT                       ,
+    WINED3DRS_AMBIENTMATERIALSOURCE         ,
+    WINED3DRS_CLIPPING                      ,
+    WINED3DRS_CLIPPLANEENABLE               ,
+    WINED3DRS_COLORVERTEX                   ,
+    WINED3DRS_DIFFUSEMATERIALSOURCE         ,
+    WINED3DRS_EMISSIVEMATERIALSOURCE        ,
+    WINED3DRS_FOGDENSITY                    ,
+    WINED3DRS_FOGEND                        ,
+    WINED3DRS_FOGSTART                      ,
+    WINED3DRS_FOGTABLEMODE                  ,
+    WINED3DRS_FOGVERTEXMODE                 ,
+    WINED3DRS_INDEXEDVERTEXBLENDENABLE      ,
+    WINED3DRS_LIGHTING                      ,
+    WINED3DRS_LOCALVIEWER                   ,
+    WINED3DRS_MULTISAMPLEANTIALIAS          ,
+    WINED3DRS_MULTISAMPLEMASK               ,
+    WINED3DRS_NORMALIZENORMALS              ,
+    WINED3DRS_PATCHEDGESTYLE                ,
+    WINED3DRS_POINTSCALE_A                  ,
+    WINED3DRS_POINTSCALE_B                  ,
+    WINED3DRS_POINTSCALE_C                  ,
+    WINED3DRS_POINTSCALEENABLE              ,
+    WINED3DRS_POINTSIZE                     ,
+    WINED3DRS_POINTSIZE_MAX                 ,
+    WINED3DRS_POINTSIZE_MIN                 ,
+    WINED3DRS_POINTSPRITEENABLE             ,
+    WINED3DRS_RANGEFOGENABLE                ,
+    WINED3DRS_SPECULARMATERIALSOURCE        ,
+    WINED3DRS_TWEENFACTOR                   ,
+    WINED3DRS_VERTEXBLEND
+};
+
+DWORD SavedVertexStates_T[NUM_SAVEDVERTEXSTATES_T] = {
+    D3DTSS_TEXCOORDINDEX         ,
+    D3DTSS_TEXTURETRANSFORMFLAGS
+};
+
+DWORD SavedVertexStates_S[NUM_SAVEDVERTEXSTATES_S] = {
 };
diff -urN wine.20050419/dlls/wined3d/directx.c wine.20050419.dx9/dlls/wined3d/directx.c
--- wine.20050419/dlls/wined3d/directx.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/directx.c	2005-04-20 01:52:56.000000000 -0600
@@ -4,6 +4,7 @@
  * Copyright 2002-2004 Jason Edmeades
  * Copyright 2003-2004 Raphael Junqueira
  * Copyright 2004 Christian Costa
+ * Copyright 2005 Oliver Stieber
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -31,6 +32,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 WINE_DECLARE_DEBUG_CHANNEL(d3d_caps);
+extern long DeviceMemory;
+static long DeviceMemory = 0; /*Only look this up once!*/
+
 #define GLINFO_LOCATION This->gl_info
 
 /**********************************************************
@@ -57,6 +61,12 @@
     return display;
 }
 
+
+long int IWineD3DImpl_CalculateGraphicsMemory( int maxAlloc);
+void IWineD3DImpl_CheckGraphicsMemory(void);
+
+
+
 /**
  * Note: GL seems to trap if GetDeviceCaps is called before any HWND's created
  * ie there is no GL Context - Get a default rendering context to enable the 
@@ -65,7 +75,7 @@
 static WineD3D_Context* WineD3D_CreateFakeGLContext(void) {
     static WineD3D_Context ctx = { NULL, NULL, NULL, 0, 0 };
     WineD3D_Context* ret = NULL;
-
+    TRACE("Creating fake context\n");
     if (glXGetCurrentContext() == NULL) {
        BOOL         gotContext  = FALSE;
        BOOL         created     = FALSE;
@@ -112,6 +122,7 @@
        }
      
        /* Make it the current GL context */
+       /* What happens if were already rendering? */
        if (!failed && glXMakeCurrent(ctx.display, ctx.drawable, ctx.glCtx) == False) {
            glXDestroyContext(ctx.display, ctx.glCtx);
            LEAVE_GL();
@@ -140,6 +151,7 @@
     /* If we created a dummy context, throw it away */
     if (NULL != ctx) {
         if (0 == InterlockedDecrement(&ctx->ref)) {
+            TRACE("Destroying fake context\n");
             glXMakeCurrent(ctx->display, None, NULL);
             glXDestroyContext(ctx->display, ctx->glCtx);
             ctx->display = NULL;
@@ -183,6 +195,8 @@
     TRACE("(%p) : Releasing from %ld\n", This, This->ref);
     ref = InterlockedDecrement(&This->ref);
     if (ref == 0) {
+        /* release the critical section */
+        DeleteCriticalSection(&This->wined3dCriticalSection);
         HeapFree(GetProcessHeap(), 0, This);
     }
     
@@ -204,6 +218,9 @@
 
     TRACE_(d3d_caps)("(%p, %p)\n", gl_info, display);
 
+    
+    
+    
     /* Fill in the GL info retrievable depending on the display */
     if (NULL != display) {
         test = glXQueryVersion(display, &major, &minor);
@@ -222,6 +239,12 @@
         gl_info->gl_vendor = VENDOR_WINE;
     }
    
+    
+    #if 0
+    /*auxiliery buffers would be great for speeding up rendering to offscreens (if the graphics card support them!)*/
+    glGetIntegerv(GL_AUX_BUFFERS, &gl_max);    
+    FIXME("Maximum number of auxiliery buffers %d\n" , gl_max);
+    #endif
     TRACE_(d3d_caps)("found GL_VENDOR (%s)->(0x%04x)\n", debugstr_a(gl_string), gl_info->gl_vendor);
     
     /* Parse the GL_VERSION field into major and minor information */
@@ -275,13 +298,6 @@
             if (error)
                 gl_string_cursor = 0;
         }
-
-        if (!gl_string_cursor)
-            WARN_(d3d_caps)("malformed GL_VERSION (%s)\n", debugstr_a(gl_string));
-        else {
-            major = *gl_string_cursor - '0';
-            minor = (*(gl_string_cursor+2) - '0') * 256 + (*(gl_string_cursor+4) - '0');
-        }      
         break;
 
     default:
@@ -347,7 +363,11 @@
     glGetIntegerv(GL_MAX_LIGHTS, &gl_max);
     gl_info->max_lights = gl_max;
     TRACE_(d3d_caps)("Lights support - max lights=%d\n", gl_max);
-
+#if 0
+    glGetIntegerv(MAX_DRAW_BUFFERS_ATI, &gl_max);
+    TRACE_(d3d_caps)("Render targets supported - max render targets=%d\n", gl_max);
+    gl_info->max_render_targets = gl_max;
+#endif    
     /* Parse the gl supported features, in theory enabling parts of our code appropriately */
     GL_Extensions = glGetString(GL_EXTENSIONS);
     TRACE_(d3d_caps)("GL_Extensions reported:\n");  
@@ -404,6 +424,14 @@
             } else if (strcmp(ThisExtn, "GL_ARB_texture_mirrored_repeat") == 0) {
                 TRACE_(d3d_caps)(" FOUND: ARB Texture mirrored repeat support\n");
                 gl_info->supported[ARB_TEXTURE_MIRRORED_REPEAT] = TRUE;
+            } else if (strcmp(ThisExtn, "GLX_ARB_multisample") == 0) {
+                TRACE_(d3d_caps)(" FOUND: ARB multisample support\n");
+                gl_info->supported[ARB_MULTISAMPLE] = TRUE;
+#if 0
+            } else if (strcmp(ThisExtn, "GL_ARB_point_sprite") == 0) {
+                TRACE_(d3d_caps)(" FOUND: ARB point sprint support\n");
+                gl_info->supported[ARB_POINT_SPRITE] = TRUE;
+#endif
             } else if (strstr(ThisExtn, "GL_ARB_vertex_program")) {
                 gl_info->vs_arb_version = VS_VERSION_11;
                 TRACE_(d3d_caps)(" FOUND: ARB Vertex Shader support - version=%02x\n", gl_info->vs_arb_version);
@@ -457,6 +485,11 @@
             } else if (strcmp(ThisExtn, "GL_EXT_vertex_weighting") == 0) {
                 TRACE_(d3d_caps)(" FOUND: EXT Vertex weighting support\n");
                 gl_info->supported[EXT_VERTEX_WEIGHTING] = TRUE;
+            } else if (strcmp(ThisExtn, "GL_EXT_texture_filter_anisotropic") == 0) {
+                TRACE_(d3d_caps)(" FOUND: EXT anisotropic filtering support\n");
+                gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC] = TRUE;
+                
+                
 
             /**
              * NVIDIA 
@@ -508,6 +541,20 @@
                 gl_info->vs_ati_version = VS_VERSION_11;
                 TRACE_(d3d_caps)(" FOUND: ATI (EXT) Vertex Shader support - version=%02x\n", gl_info->vs_ati_version);
                 gl_info->supported[EXT_VERTEX_SHADER] = TRUE;
+#if 0
+            } else if (strcmp(ThisExtn, "GL_ATI_draw_buffers") == 0){
+                TRACE_(d3d_caps)(" FOUND: ATI draw buffers support\n");
+                gl_info->supported[GL_ATI_DRAW_BUFFERS] = TRUE;
+            } else if (strcmp(ThisExtn, "GL_SGIS_generate_mipmap\n"){
+                TRACE_(d3d_caps)(" FOUND: SGIS generate mipmaps support\n");
+                gl_info->supported[GL_SGIS_GENERATE_MIPMAPS] = TRUE;
+            } else if(strcmp(ThisExtn, "GLX_ATI_pixel_format_float\n"){
+                TRACE_(d3d_caps)(" FOUND ATI pixel format float support\n");
+                gl_info->supported[GLX_ATI_PIXEL_FORMAT_FLOAT] = TRUE;
+            } else if(strcmp(ThisExtn, "GLX_ATI_render_texture\n"){
+                TRACE_(d3d_caps)(" FOUND: ATI render to texture support\n");
+                gl_info->supported[GLX_ATI_RENDER_TEXTURE] = TRUE;
+#endif                
             }
 
 
@@ -762,7 +809,7 @@
         pMode->Width        = DevModeW.dmPelsWidth;
         pMode->Height       = DevModeW.dmPelsHeight;
         bpp                 = DevModeW.dmBitsPerPel;
-        pMode->RefreshRate  = D3DADAPTER_DEFAULT;
+        pMode->RefreshRate  = 80; /* D3DADAPTER_DEFAULT; */
         if (DevModeW.dmFields&DM_DISPLAYFREQUENCY)
         {
             pMode->RefreshRate = DevModeW.dmDisplayFrequency;
@@ -1029,7 +1076,7 @@
 HRESULT  WINAPI  IWineD3DImpl_CheckDeviceFormatConversion(IWineD3D *iface, UINT Adapter, D3DDEVTYPE DeviceType, WINED3DFORMAT SourceFormat, WINED3DFORMAT TargetFormat) {
     IWineD3DImpl *This = (IWineD3DImpl *)iface;
 
-    FIXME_(d3d_caps)("(%p)-> (STUB) (Adptr:%d, DevType:(%u,%s), SrcFmt:(%u,%s), TgtFmt:(%u,%s))",
+    FIXME_(d3d_caps)("(%p)-> (STUB) (Adptr:%d, DevType:(%u,%s), SrcFmt:(%u,%s), TgtFmt:(%u,%s))\n",
           This, 
           Adapter, 
           DeviceType, debug_d3ddevicetype(DeviceType), 
@@ -1040,22 +1087,27 @@
 
 /* Note: d3d8 passes in a pointer to a D3DCAPS8 structure, which is a true 
       subset of a D3DCAPS9 structure. However, it has to come via a void * 
-      as the d3d8 interface cannot import the d3d9 header                  */
-HRESULT WINAPI IWineD3DImpl_GetDeviceCaps(IWineD3D *iface, UINT Adapter, D3DDEVTYPE DeviceType, WINED3DCAPS* pCapsIn) {
+      as the d3d8 interface cannot import the d3d9 header
+      see  http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/graphics/reference/d3d/structures/d3dcaps9.asp
+       */
+ /* This is buggy if no window or device is created */
+HRESULT WINAPI IWineD3DImpl_GetDeviceCaps(IWineD3D *iface, UINT Adapter, D3DDEVTYPE DeviceType, WINED3DCAPS* pCaps) {
 
     IWineD3DImpl    *This = (IWineD3DImpl *)iface;
     BOOL             gotContext  = FALSE;
     GLint            gl_tex_size = 0;    
     WineD3D_Context *fake_ctx = NULL;
-    D3DCAPS9        *pCaps = (D3DCAPS9 *)pCapsIn;
 
+   /*TODO: only do this once per adapter please! */
     TRACE_(d3d_caps)("(%p)->(Adptr:%d, DevType: %x, pCaps: %p)\n", This, Adapter, DeviceType, pCaps);
 
     if (Adapter >= IWineD3D_GetAdapterCount(iface)) {
         return D3DERR_INVALIDCALL;
     }
 
-    /* Note: GL seems to trap if GetDeviceCaps is called before any HWND's created
+    /* Note: GL seems to trap if GetDeviceCaps is c
+trace:d3d9:IDirect3DSurface9Impl_Release (0x4048e928) : ReleaseRef to 2
+alled before any HWND's created
        ie there is no GL Context - Get a default rendering context to enable the 
        function query some info from GL                                           */    
     if (glXGetCurrentContext() == NULL) {
@@ -1069,18 +1121,20 @@
 
         FIXME_(d3d_caps)("GetDeviceCaps called but no GL Context - Returning dummy values\n");
         gl_tex_size=65535;
-        pCaps->MaxTextureBlendStages = 2;
-        pCaps->MaxSimultaneousTextures = 2;
-        pCaps->MaxUserClipPlanes = 8;
-        pCaps->MaxActiveLights = 8;
-        pCaps->MaxVertexBlendMatrices = 0;
-        pCaps->MaxVertexBlendMatrixIndex = 1;
-        pCaps->MaxAnisotropy = 0;
-        pCaps->MaxPointSize = 255.0;
+        *pCaps->MaxTextureBlendStages       = 2;
+        *pCaps->MaxSimultaneousTextures     = 2;
+        *pCaps->MaxUserClipPlanes           = 8;
+        *pCaps->MaxActiveLights             = 8;
+        *pCaps->MaxVertexBlendMatrices      = 0;
+        *pCaps->MaxVertexBlendMatrixIndex   = 1;
+        *pCaps->MaxAnisotropy               = 0;
+        *pCaps->MaxPointSize                = 255.0;
+
     } else {
         glGetIntegerv(GL_MAX_TEXTURE_SIZE, &gl_tex_size);
     }
 
+
     /* If we don't know the device settings, go query them now */
     if (This->isGLInfoValid == FALSE) {
         BOOL rc = IWineD3DImpl_FillGLCaps(&This->gl_info, NULL);
@@ -1092,21 +1146,23 @@
     /* ------------------------------------------------
        The following fields apply to both d3d8 and d3d9
        ------------------------------------------------ */
-    pCaps->DeviceType = (DeviceType == D3DDEVTYPE_HAL) ? D3DDEVTYPE_HAL : D3DDEVTYPE_REF;  /* Not quite true, but use h/w supported by opengl I suppose */
-    pCaps->AdapterOrdinal = Adapter;
+    *pCaps->DeviceType              = (DeviceType == D3DDEVTYPE_HAL) ? D3DDEVTYPE_HAL : D3DDEVTYPE_REF;  /* Not quite true, but use h/w supported by opengl I suppose */
+    *pCaps->AdapterOrdinal          = Adapter;
+
+    *pCaps->Caps                    = 0;
+    *pCaps->Caps2                   = D3DCAPS2_CANRENDERWINDOWED;
+    *pCaps->Caps3                   = D3DDEVCAPS_HWTRANSFORMANDLIGHT;
+    *pCaps->PresentationIntervals   = D3DPRESENT_INTERVAL_IMMEDIATE;
 
-    pCaps->Caps = 0;
-    pCaps->Caps2 = D3DCAPS2_CANRENDERWINDOWED;
-    pCaps->Caps3 = D3DDEVCAPS_HWTRANSFORMANDLIGHT;
-    pCaps->PresentationIntervals = D3DPRESENT_INTERVAL_IMMEDIATE;
+    *pCaps->CursorCaps              = 0;
 
-    pCaps->CursorCaps = 0;
 
-    pCaps->DevCaps = D3DDEVCAPS_DRAWPRIMTLVERTEX    | 
+    *pCaps->DevCaps                 = D3DDEVCAPS_DRAWPRIMTLVERTEX    |
                      D3DDEVCAPS_HWTRANSFORMANDLIGHT |
                      D3DDEVCAPS_PUREDEVICE;
 
-    pCaps->PrimitiveMiscCaps = D3DPMISCCAPS_CULLCCW               | 
+
+    *pCaps->PrimitiveMiscCaps       = D3DPMISCCAPS_CULLCCW               |
                                D3DPMISCCAPS_CULLCW                | 
                                D3DPMISCCAPS_COLORWRITEENABLE      |
                                D3DPMISCCAPS_CLIPTLVERTS           |
@@ -1114,7 +1170,7 @@
                                D3DPMISCCAPS_MASKZ; 
                                /*NOT: D3DPMISCCAPS_TSSARGTEMP*/
 
-    pCaps->RasterCaps = D3DPRASTERCAPS_DITHER   | 
+    *pCaps->RasterCaps              = D3DPRASTERCAPS_DITHER    |
                         D3DPRASTERCAPS_PAT      | 
 			D3DPRASTERCAPS_WFOG |
 			D3DPRASTERCAPS_ZFOG |
@@ -1123,18 +1179,18 @@
                         D3DPRASTERCAPS_FOGRANGE;
 
     if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
-      pCaps->RasterCaps |= D3DPRASTERCAPS_ANISOTROPY;
+      *pCaps->RasterCaps |= D3DPRASTERCAPS_ANISOTROPY    |
+                            D3DPRASTERCAPS_ZBIAS         |
+                            D3DPRASTERCAPS_MIPMAPLODBIAS;
     }
                         /* FIXME Add:
-			   D3DPRASTERCAPS_MIPMAPLODBIAS
-			   D3DPRASTERCAPS_ZBIAS
 			   D3DPRASTERCAPS_COLORPERSPECTIVE
 			   D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE
 			   D3DPRASTERCAPS_ANTIALIASEDGES
 			   D3DPRASTERCAPS_ZBUFFERLESSHSR
 			   D3DPRASTERCAPS_WBUFFER */
 
-    pCaps->ZCmpCaps = D3DPCMPCAPS_ALWAYS       | 
+    *pCaps->ZCmpCaps = D3DPCMPCAPS_ALWAYS       |
                       D3DPCMPCAPS_EQUAL        | 
                       D3DPCMPCAPS_GREATER      | 
                       D3DPCMPCAPS_GREATEREQUAL |
@@ -1143,89 +1199,100 @@
                       D3DPCMPCAPS_NEVER        |
                       D3DPCMPCAPS_NOTEQUAL;
 
-    pCaps->SrcBlendCaps  = 0xFFFFFFFF;   /*FIXME: Tidy up later */
-    pCaps->DestBlendCaps = 0xFFFFFFFF;   /*FIXME: Tidy up later */
-    pCaps->AlphaCmpCaps  = 0xFFFFFFFF;   /*FIXME: Tidy up later */
+    *pCaps->SrcBlendCaps  = 0xFFFFFFFF;   /*FIXME: Tidy up later */
+    *pCaps->DestBlendCaps = 0xFFFFFFFF;   /*FIXME: Tidy up later */
+    *pCaps->AlphaCmpCaps  = 0xFFFFFFFF;   /*FIXME: Tidy up later */
 
-    pCaps->ShadeCaps = D3DPSHADECAPS_SPECULARGOURAUDRGB | 
+    *pCaps->ShadeCaps     = D3DPSHADECAPS_SPECULARGOURAUDRGB |
                        D3DPSHADECAPS_COLORGOURAUDRGB;
 
-    pCaps->TextureCaps =  D3DPTEXTURECAPS_ALPHA        | 
+    *pCaps->TextureCaps =  D3DPTEXTURECAPS_ALPHA              |
                           D3DPTEXTURECAPS_ALPHAPALETTE | 
-                          D3DPTEXTURECAPS_POW2         | 
                           D3DPTEXTURECAPS_VOLUMEMAP    | 
                           D3DPTEXTURECAPS_MIPMAP       |
-                          D3DPTEXTURECAPS_PROJECTED;
+                           D3DPTEXTURECAPS_PROJECTED          |
+                           D3DPTEXTURECAPS_PERSPECTIVE        |
+                           D3DPTEXTURECAPS_VOLUMEMAP_POW2 ;
+                          /* TODO: add support for NON-POW2 if avaialble
+
+                          */                                                  
+    if (This->dxVersion > 8){
+        *pCaps->TextureCaps |= D3DPTEXTURECAPS_NONPOW2CONDITIONAL;
+
+    }else{  /* NONPOW2 isn't accessable by d3d8 yet */
+        *pCaps->TextureCaps |= D3DPTEXTURECAPS_POW2;
+    }  
 
     if (GL_SUPPORT(ARB_TEXTURE_CUBE_MAP)) {
-      pCaps->TextureCaps |= D3DPTEXTURECAPS_CUBEMAP      | 
+        *pCaps->TextureCaps |= D3DPTEXTURECAPS_CUBEMAP     |
 	                    D3DPTEXTURECAPS_MIPCUBEMAP   | 
 	                    D3DPTEXTURECAPS_CUBEMAP_POW2;
+                                 
     }
 
-    pCaps->TextureFilterCaps = D3DPTFILTERCAPS_MAGFLINEAR | 
+    *pCaps->TextureFilterCaps = D3DPTFILTERCAPS_MAGFLINEAR |
                                D3DPTFILTERCAPS_MAGFPOINT  | 
                                D3DPTFILTERCAPS_MINFLINEAR | 
                                D3DPTFILTERCAPS_MINFPOINT  |
                                D3DPTFILTERCAPS_MIPFLINEAR | 
                                D3DPTFILTERCAPS_MIPFPOINT;
 
-    pCaps->CubeTextureFilterCaps = 0;
-    pCaps->VolumeTextureFilterCaps = 0;
+    *pCaps->CubeTextureFilterCaps = 0;
+    *pCaps->VolumeTextureFilterCaps = 0;
 
-    pCaps->TextureAddressCaps =  D3DPTADDRESSCAPS_BORDER | 
+    *pCaps->TextureAddressCaps =  D3DPTADDRESSCAPS_BORDER |
                                  D3DPTADDRESSCAPS_CLAMP  | 
                                  D3DPTADDRESSCAPS_WRAP;
 
     if (GL_SUPPORT(ARB_TEXTURE_BORDER_CLAMP)) {
-      pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_BORDER;
+        *pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_BORDER;
     }
     if (GL_SUPPORT(ARB_TEXTURE_MIRRORED_REPEAT)) {
-      pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_MIRROR;
+        *pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_MIRROR;
     }
     if (GL_SUPPORT(ATI_TEXTURE_MIRROR_ONCE)) {
-      pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_MIRRORONCE;
+        *pCaps->TextureAddressCaps |= D3DPTADDRESSCAPS_MIRRORONCE;
     }
 
-    pCaps->VolumeTextureAddressCaps = 0;
+    *pCaps->VolumeTextureAddressCaps = 0;
 
-    pCaps->LineCaps = D3DLINECAPS_TEXTURE | 
+    *pCaps->LineCaps = D3DLINECAPS_TEXTURE |
                       D3DLINECAPS_ZTEST;
                       /* FIXME: Add 
 			 D3DLINECAPS_BLEND
 			 D3DLINECAPS_ALPHACMP
 			 D3DLINECAPS_FOG */
 
-    pCaps->MaxTextureWidth = gl_tex_size;
-    pCaps->MaxTextureHeight = gl_tex_size;
+    *pCaps->MaxTextureWidth = gl_tex_size;
+    *pCaps->MaxTextureHeight = gl_tex_size;
 
-    pCaps->MaxVolumeExtent = 0;
+    *pCaps->MaxVolumeExtent = 0;
 
-    pCaps->MaxTextureRepeat = 32768;
-    pCaps->MaxTextureAspectRatio = 32768;
-    pCaps->MaxVertexW = 1.0;
+    *pCaps->MaxTextureRepeat = 32768;
+    *pCaps->MaxTextureAspectRatio = 32768;
+    *pCaps->MaxVertexW = 1.0;
 
-    pCaps->GuardBandLeft = 0;
-    pCaps->GuardBandTop = 0;
-    pCaps->GuardBandRight = 0;
-    pCaps->GuardBandBottom = 0;
+    *pCaps->GuardBandLeft = 0;
+    *pCaps->GuardBandTop = 0;
+    *pCaps->GuardBandRight = 0;
+    *pCaps->GuardBandBottom = 0;
 
-    pCaps->ExtentsAdjust = 0;
+    *pCaps->ExtentsAdjust = 0;
 
-    pCaps->StencilCaps =  D3DSTENCILCAPS_DECRSAT | 
+    *pCaps->StencilCaps =  D3DSTENCILCAPS_DECRSAT |
                           D3DSTENCILCAPS_INCRSAT | 
                           D3DSTENCILCAPS_INVERT  | 
                           D3DSTENCILCAPS_KEEP    | 
                           D3DSTENCILCAPS_REPLACE | 
                           D3DSTENCILCAPS_ZERO;
     if (GL_SUPPORT(EXT_STENCIL_WRAP)) {
-      pCaps->StencilCaps |= D3DSTENCILCAPS_DECR    | 
+      *pCaps->StencilCaps |= D3DSTENCILCAPS_DECR  |
 	                    D3DSTENCILCAPS_INCR;
     }
 
-    pCaps->FVFCaps = D3DFVFCAPS_PSIZE | 0x0008; /* 8 texture coords */
+    *pCaps->FVFCaps = D3DFVFCAPS_PSIZE | 0x0008; /* 8 texture coords */
 
-    pCaps->TextureOpCaps =  D3DTEXOPCAPS_ADD         | 
+    *pCaps->TextureOpCaps =  D3DTEXOPCAPS_ADD         |
                             D3DTEXOPCAPS_ADDSIGNED   | 
                             D3DTEXOPCAPS_ADDSIGNED2X |
                             D3DTEXOPCAPS_MODULATE    | 
@@ -1235,20 +1302,20 @@
                             D3DTEXOPCAPS_SELECTARG2  | 
                             D3DTEXOPCAPS_DISABLE;
 #if defined(GL_VERSION_1_3)
-    pCaps->TextureOpCaps |= D3DTEXOPCAPS_DOTPRODUCT3 | 
+    *pCaps->TextureOpCaps |= D3DTEXOPCAPS_DOTPRODUCT3 |
                             D3DTEXOPCAPS_SUBTRACT;
 #endif
     if (GL_SUPPORT(ARB_TEXTURE_ENV_COMBINE) || 
 	GL_SUPPORT(EXT_TEXTURE_ENV_COMBINE) || 
 	GL_SUPPORT(NV_TEXTURE_ENV_COMBINE4)) {
-      pCaps->TextureOpCaps |= D3DTEXOPCAPS_BLENDDIFFUSEALPHA |
+        *pCaps->TextureOpCaps |= D3DTEXOPCAPS_BLENDDIFFUSEALPHA |
 	                      D3DTEXOPCAPS_BLENDTEXTUREALPHA | 
 			      D3DTEXOPCAPS_BLENDFACTORALPHA  |
 			      D3DTEXOPCAPS_BLENDCURRENTALPHA |
 			      D3DTEXOPCAPS_LERP;
     }
     if (GL_SUPPORT(NV_TEXTURE_ENV_COMBINE4)) {
-      pCaps->TextureOpCaps |= D3DTEXOPCAPS_ADDSMOOTH | 
+        *pCaps->TextureOpCaps |= D3DTEXOPCAPS_ADDSMOOTH             |
 			      D3DTEXOPCAPS_MULTIPLYADD |
 			      D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR |
 			      D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA |
@@ -1256,7 +1323,7 @@
     }
     
 #if 0
-    pCaps->TextureOpCaps |= D3DTEXOPCAPS_BUMPENVMAP;
+    *pCaps->TextureOpCaps |= D3DTEXOPCAPS_BUMPENVMAP;
                             /* FIXME: Add 
 			      D3DTEXOPCAPS_BUMPENVMAPLUMINANCE 
 			      D3DTEXOPCAPS_PREMODULATE */
@@ -1271,38 +1338,38 @@
         glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &gl_max);
 #endif
         TRACE_(d3d_caps)("GLCaps: GL_MAX_TEXTURE_UNITS_ARB=%d\n", gl_max);
-        pCaps->MaxTextureBlendStages = min(8, gl_max);
-        pCaps->MaxSimultaneousTextures = min(8, gl_max);
+        *pCaps->MaxTextureBlendStages = min(8, gl_max);
+        *pCaps->MaxSimultaneousTextures = min(8, gl_max);
 
         glGetIntegerv(GL_MAX_CLIP_PLANES, &gl_max);
-        pCaps->MaxUserClipPlanes = min(D3DMAXUSERCLIPPLANES, gl_max);
-        TRACE_(d3d_caps)("GLCaps: GL_MAX_CLIP_PLANES=%ld\n", pCaps->MaxUserClipPlanes);
+        *pCaps->MaxUserClipPlanes = min(D3DMAXUSERCLIPPLANES, gl_max);
+        TRACE_(d3d_caps)("GLCaps: GL_MAX_CLIP_PLANES=%ld\n", *pCaps->MaxUserClipPlanes);
 
         glGetIntegerv(GL_MAX_LIGHTS, &gl_max);
-        pCaps->MaxActiveLights = gl_max;
-        TRACE_(d3d_caps)("GLCaps: GL_MAX_LIGHTS=%ld\n", pCaps->MaxActiveLights);
+        *pCaps->MaxActiveLights = gl_max;
+        TRACE_(d3d_caps)("GLCaps: GL_MAX_LIGHTS=%ld\n", *pCaps->MaxActiveLights);
 
         if (GL_SUPPORT(ARB_VERTEX_BLEND)) {
 	   glGetIntegerv(GL_MAX_VERTEX_UNITS_ARB, &gl_max);
-	   pCaps->MaxVertexBlendMatrices = gl_max;
-	   pCaps->MaxVertexBlendMatrixIndex = 1;
+            *pCaps->MaxVertexBlendMatrices      = gl_max;
+            *pCaps->MaxVertexBlendMatrixIndex   = 1;
         } else {
-           pCaps->MaxVertexBlendMatrices = 0;
-           pCaps->MaxVertexBlendMatrixIndex = 1;
+           *pCaps->MaxVertexBlendMatrices       = 0;
+           *pCaps->MaxVertexBlendMatrixIndex    = 1;
         }
 
         if (GL_SUPPORT(EXT_TEXTURE_FILTER_ANISOTROPIC)) {
           glGetIntegerv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &gl_max);
-          pCaps->MaxAnisotropy = gl_max;
+            *pCaps->MaxAnisotropy = gl_max;
         } else {
-          pCaps->MaxAnisotropy = 0;
+            *pCaps->MaxAnisotropy = 0;
         }
 
         glGetFloatv(GL_POINT_SIZE_RANGE, &gl_float);
-        pCaps->MaxPointSize = gl_float;
+        *pCaps->MaxPointSize = gl_float;
     }
 
-    pCaps->VertexProcessingCaps = D3DVTXPCAPS_DIRECTIONALLIGHTS | 
+    *pCaps->VertexProcessingCaps = D3DVTXPCAPS_DIRECTIONALLIGHTS |
                                   D3DVTXPCAPS_MATERIALSOURCE7   | 
                                   D3DVTXPCAPS_POSITIONALLIGHTS  | 
                                   D3DVTXPCAPS_LOCALVIEWER |
@@ -1310,57 +1377,90 @@
                                   /* FIXME: Add 
                                      D3DVTXPCAPS_TWEENING */
 
-    pCaps->MaxPrimitiveCount = 0xFFFFFFFF;
-    pCaps->MaxVertexIndex = 0xFFFFFFFF;
-    pCaps->MaxStreams = MAX_STREAMS;
-    pCaps->MaxStreamStride = 1024;
+    *pCaps->MaxPrimitiveCount   = 0xFFFFFFFF;
+    *pCaps->MaxVertexIndex      = 0xFFFFFFFF;
+    *pCaps->MaxStreams          = MAX_STREAMS;
+    *pCaps->MaxStreamStride     = 1024;
 
     if (((vs_mode == VS_HW) && GL_SUPPORT(ARB_VERTEX_PROGRAM)) || (vs_mode == VS_SW) || (DeviceType == D3DDEVTYPE_REF)) {
-      pCaps->VertexShaderVersion = D3DVS_VERSION(1,1);
+      *pCaps->VertexShaderVersion = D3DVS_VERSION(1,1);
       
       if (This->gl_info.gl_vendor == VENDOR_MESA || 
           This->gl_info.gl_vendor == VENDOR_WINE) {
-        pCaps->MaxVertexShaderConst = 95;
+        *pCaps->MaxVertexShaderConst = 95;
       } else {
-        pCaps->MaxVertexShaderConst = WINED3D_VSHADER_MAX_CONSTANTS;
+        *pCaps->MaxVertexShaderConst = WINED3D_VSHADER_MAX_CONSTANTS;
       }
     } else {
-      pCaps->VertexShaderVersion = 0;
-      pCaps->MaxVertexShaderConst = 0;
+        *pCaps->VertexShaderVersion = 0;
+        *pCaps->MaxVertexShaderConst = 0;
     }
 
     if ((ps_mode == PS_HW) && GL_SUPPORT(ARB_FRAGMENT_PROGRAM) && (DeviceType != D3DDEVTYPE_REF)) {
-        pCaps->PixelShaderVersion = D3DPS_VERSION(1,4);
-        pCaps->MaxPixelShaderValue = 1.0;
+        *pCaps->PixelShaderVersion = D3DPS_VERSION(1,4);
+	#if 0 /*FIXME: d3d8*/
+        *pCaps->MaxPixelShaderValue = 1.0;
+	#endif
     } else {
-        pCaps->PixelShaderVersion = 0;
-        pCaps->MaxPixelShaderValue = 0.0;
+        *pCaps->PixelShaderVersion = 0;
+	#if 0 /*FIXME: d3d8*/
+        *pCaps->MaxPixelShaderValue = 0.0;
+	#endif
     }
+    /* TODO: ARB_FRAGMENT_PROGRAM_100 */
 
     /* ------------------------------------------------
        The following fields apply to d3d9 only
        ------------------------------------------------ */
     if (This->dxVersion > 8) {
-        FIXME("Caps support for directx9 is nonexistent at the moment!\n");
-        pCaps->DevCaps2 = 0;
-        pCaps->MaxNpatchTessellationLevel = 0;
-        pCaps->MasterAdapterOrdinal = 0;
-        pCaps->AdapterOrdinalInGroup = 0;
-        pCaps->NumberOfAdaptersInGroup = 1;
-        pCaps->DeclTypes = 0;
-        pCaps->NumSimultaneousRTs = 0;
-        pCaps->StretchRectFilterCaps = 0;
-        pCaps->VS20Caps.Caps = 0;
-        pCaps->PS20Caps.Caps = 0;
-        pCaps->VertexTextureFilterCaps = 0;
-        pCaps->MaxVShaderInstructionsExecuted = 0;
-        pCaps->MaxPShaderInstructionsExecuted = 0;
-        pCaps->MaxVertexShader30InstructionSlots = 0;
-        pCaps->MaxPixelShader30InstructionSlots = 0;
+        GLint max_buffers=1;
+
+	TRACE("Caps support for directx9 is non-existent at the moment!\n");
+        *pCaps->DevCaps2                          = 0;
+        /* TODO: add support for, this may have to be done in software though, so should be optional?
+            D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES
+            
+        */
+        *pCaps->MaxNpatchTessellationLevel        = 0;
+        *pCaps->MasterAdapterOrdinal              = 0;
+        *pCaps->AdapterOrdinalInGroup             = 0;
+        *pCaps->NumberOfAdaptersInGroup           = 1;
+        *pCaps->DeclTypes                         = 0;
+        #if 0 /*FIXME: Simultaneous render targets*/
+        #ifndef GL_MAX_DRAW_BUFFERS_ATI
+        #define GL_MAX_DRAW_BUFFERS_ATI  0x00008824
+        #endif
+            ENTER_GL();
+/*        if(GL_SUPPORT(GL_MAX_DRAW_BUFFERS_ATI) ){	*/
+            glEnable(GL_MAX_DRAW_BUFFERS_ATI);
+            glGetIntegerv(GL_MAX_DRAW_BUFFERS_ATI, &max_buffers);
+            glDisable(GL_MAX_DRAW_BUFFERS_ATI);
+            FIXME("Setting maxbuffers to %d\n", max_buffers);
+            LEAVE_GL();
+/*        }*/
+        #endif
+        *pCaps->NumSimultaneousRTs                = max_buffers;/*max_buffers*/
+        *pCaps->StretchRectFilterCaps             = 0;
+        /* TODO: add
+           D3DPTFILTERCAPS_MINFPOINT
+           D3DPTFILTERCAPS_MAGFPOINT
+           D3DPTFILTERCAPS_MINFLINEAR
+           D3DPTFILTERCAPS_MAGFLINEAR           
+        */
+        #if 0
+        pCaps.VS20Caps->Caps                     = 0;
+        pCaps.PS20Caps->Caps                     = 0;
+        #endif
+        *pCaps->VertexTextureFilterCaps           = 0;
+        *pCaps->MaxVShaderInstructionsExecuted    = 0;
+        *pCaps->MaxPShaderInstructionsExecuted    = 0;
+        *pCaps->MaxVertexShader30InstructionSlots = 0;
+        *pCaps->MaxPixelShader30InstructionSlots  = 0;
     }
 
     /* If we created a dummy context, throw it away */
     if (NULL != fake_ctx) WineD3D_ReleaseFakeGLContext(fake_ctx);
+
     return D3D_OK;
 }
 
@@ -1368,14 +1468,14 @@
    and fields being inserted in the middle, a new structure is used in place    */
 HRESULT  WINAPI  IWineD3DImpl_CreateDevice(IWineD3D *iface, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow,
                                            DWORD BehaviourFlags, WINED3DPRESENT_PARAMETERS* pPresentationParameters,
-                                           IWineD3DDevice** ppReturnedDeviceInterface, IUnknown *parent, D3DCB_CREATERENDERTARGETFN D3DCB_CreateRenderTarget) {
+                                           IWineD3DDevice** ppReturnedDeviceInterface, IUnknown *parent,
+                                           D3DCB_CREATERENDERTARGETFN D3DCB_CreateRenderTarget,
+                                           D3DCB_CREATEDEPTHSTENCILSURFACEFN D3DCB_CreateDepthStencil,
+                                           D3DCB_CREATEADDITIONALSWAPCHAIN D3DCB_CreateAdditionalSwapChain) {
 
-    HWND                whichHWND;
-    HDC                 hDc;
     IWineD3DDeviceImpl *object  = NULL;
     IWineD3DImpl       *This    = (IWineD3DImpl *)iface;
-    int                 num;
-    XVisualInfo         template;
+    IWineD3DSwapChainImpl *swapchain;
 
     /* Validate the adapter number */
     if (Adapter >= IWineD3D_GetAdapterCount(iface)) {
@@ -1387,6 +1487,7 @@
     *ppReturnedDeviceInterface = (IWineD3DDevice *)object;
     TRACE("Created WineD3DDevice object @ %p \n", object);
     if (NULL == object) {
+      ppReturnedDeviceInterface = NULL;
       return D3DERR_OUTOFVIDEOMEMORY;
     }
 
@@ -1397,6 +1498,7 @@
     IWineD3D_AddRef(object->wineD3D);
     object->parent  = parent;
     
+    
     TRACE("(%p)->(Adptr:%d, DevType: %x, FocusHwnd: %p, BehFlags: %lx, PresParms: %p, RetDevInt: %p)\n", This, Adapter, DeviceType,
           hFocusWindow, BehaviourFlags, pPresentationParameters, ppReturnedDeviceInterface);
     TRACE("(%p)->(DepthStencil:(%u,%s), BackBufferFormat:(%u,%s))\n", This, 
@@ -1408,221 +1510,55 @@
     object->createParms.DeviceType     = DeviceType;
     object->createParms.hFocusWindow   = hFocusWindow;
     object->createParms.BehaviorFlags  = BehaviourFlags;
-
-    /* Initialize other useful values */
-    object->presentParms.BackBufferCount = 1; /* Opengl only supports one? */
     object->adapterNo                    = Adapter;
     object->devType                      = DeviceType;
 
-    /* Setup hwnd we are using, plus which display this equates to */
-    whichHWND = *(pPresentationParameters->hDeviceWindow);
-    if (!whichHWND) {
-        whichHWND = hFocusWindow;
-    }
-    object->win_handle = whichHWND;
-    object->win        = (Window)GetPropA( whichHWND, "__wine_x11_whole_window" );
-    hDc                = GetDC(whichHWND);
-    object->display    = get_display(hDc);
-    ReleaseDC(whichHWND, hDc);
 
     /* FIXME: Use for dx8 code eventually too! */
     /* Deliberately no indentation here, as this if will be removed when dx8 support merged in */
     if (This->dxVersion > 8) {   
 
-    /* Create a context based off the properties of the existing visual */
-    /*   Note the visual is chosen as the window is created and the glcontext cannot
-         use different properties after that point in time. FIXME: How to handle when requested format 
-         doesn't match actual visual? Cannot choose one here - code removed as it ONLY works if the one
-         it chooses is identical to the one already being used!                                        */
-    /* FIXME: Handle stencil appropriately via EnableAutoDepthStencil / AutoDepthStencilFormat */
-    ENTER_GL();
-    template.visualid = (VisualID)GetPropA(GetDesktopWindow(), "__wine_x11_visual_id");
-    object->visInfo   = XGetVisualInfo(object->display, VisualIDMask, &template, &num);
-    if (NULL == object->visInfo) {
-        ERR("cannot really get XVisual\n"); 
-        LEAVE_GL();
-        return D3DERR_NOTAVAILABLE;
-    }
-    object->glCtx = glXCreateContext(object->display, object->visInfo, NULL, GL_TRUE);
-    if (NULL == object->glCtx) {
-        ERR("cannot create glxContext\n"); 
-        LEAVE_GL();
-        return D3DERR_NOTAVAILABLE;
-    }
-    LEAVE_GL();
-
-    if (object->glCtx == NULL) {
-        ERR("Error in context creation !\n");
-        return D3DERR_INVALIDCALL;
-    } else {
-        TRACE("Context created (HWND=%p, glContext=%p, Window=%ld, VisInfo=%p)\n",
-                whichHWND, object->glCtx, object->win, object->visInfo);
-    }
-
-    /* If not windowed, need to go fullscreen, and resize the HWND to the appropriate  */
-    /*        dimensions                                                               */
-    if (!*(pPresentationParameters->Windowed)) {
-
-        DEVMODEW devmode;
-        HDC      hdc;
-        int      bpp = 0;
-
-        /* Get info on the current display setup */
-        hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
-        bpp = GetDeviceCaps(hdc, BITSPIXEL);
-        DeleteDC(hdc);
-
-        /* Change the display settings */
-        memset(&devmode, 0, sizeof(DEVMODEW));
-        devmode.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT; 
-        devmode.dmBitsPerPel = (bpp >= 24) ? 32 : bpp;   /*Stupid XVidMode cannot change bpp D3DFmtGetBpp(object, pPresentationParameters->BackBufferFormat);*/
-        devmode.dmPelsWidth  = *(pPresentationParameters->BackBufferWidth);
-        devmode.dmPelsHeight = *(pPresentationParameters->BackBufferHeight);
-        MultiByteToWideChar(CP_ACP, 0, "Gamers CG", -1, devmode.dmDeviceName, CCHDEVICENAME);
-        ChangeDisplaySettingsExW(devmode.dmDeviceName, &devmode, object->win_handle, CDS_FULLSCREEN, NULL);
-
-        /* Make popup window */
-        SetWindowLongA(whichHWND, GWL_STYLE, WS_POPUP);
-        SetWindowPos(object->win_handle, HWND_TOP, 0, 0, 
-                     *(pPresentationParameters->BackBufferWidth),
-                     *(pPresentationParameters->BackBufferHeight), SWP_SHOWWINDOW | SWP_FRAMECHANGED);
-    }
-
-    /* MSDN: If Windowed is TRUE and either of the BackBufferWidth/Height values is zero,
-       then the corresponding dimension of the client area of the hDeviceWindow
-       (or the focus window, if hDeviceWindow is NULL) is taken. */
-    if (*(pPresentationParameters->Windowed) && 
-        ((*(pPresentationParameters->BackBufferWidth)  == 0) ||
-         (*(pPresentationParameters->BackBufferHeight) == 0))) {
-
-        RECT Rect;
-        GetClientRect(whichHWND, &Rect);
-
-        if (*(pPresentationParameters->BackBufferWidth) == 0) {
-           *(pPresentationParameters->BackBufferWidth) = Rect.right;
-           TRACE("Updating width to %d\n", *(pPresentationParameters->BackBufferWidth));
-        }
-        if (*(pPresentationParameters->BackBufferHeight) == 0) {
-           *(pPresentationParameters->BackBufferHeight) = Rect.bottom;
-           TRACE("Updating height to %d\n", *(pPresentationParameters->BackBufferHeight));
-        }
-    }
-
-    /* Save the presentation parms now filled in correctly */
-    object->presentParms.BackBufferWidth                = *(pPresentationParameters->BackBufferWidth);
-    object->presentParms.BackBufferHeight               = *(pPresentationParameters->BackBufferHeight);           
-    object->presentParms.BackBufferFormat               = *(pPresentationParameters->BackBufferFormat);           
-    object->presentParms.BackBufferCount                = *(pPresentationParameters->BackBufferCount);            
-    object->presentParms.MultiSampleType                = *(pPresentationParameters->MultiSampleType);            
-    object->presentParms.MultiSampleQuality             = *(pPresentationParameters->MultiSampleQuality);         
-    object->presentParms.SwapEffect                     = *(pPresentationParameters->SwapEffect);                 
-    object->presentParms.hDeviceWindow                  = *(pPresentationParameters->hDeviceWindow);              
-    object->presentParms.Windowed                       = *(pPresentationParameters->Windowed);                   
-    object->presentParms.EnableAutoDepthStencil         = *(pPresentationParameters->EnableAutoDepthStencil);     
-    object->presentParms.AutoDepthStencilFormat         = *(pPresentationParameters->AutoDepthStencilFormat);     
-    object->presentParms.Flags                          = *(pPresentationParameters->Flags);                      
-    object->presentParms.FullScreen_RefreshRateInHz     = *(pPresentationParameters->FullScreen_RefreshRateInHz); 
-    object->presentParms.PresentationInterval           = *(pPresentationParameters->PresentationInterval);       
-
     /* Creating the startup stateBlock - Note Special Case: 0 => Don't fill in yet! */
     IWineD3DDevice_CreateStateBlock((IWineD3DDevice *)object, 
                                     (D3DSTATEBLOCKTYPE) 0, 
                                     (IWineD3DStateBlock **)&object->stateBlock,
                                     NULL);   /* Note: No parent needed for initial internal stateblock */
     object->updateStateBlock = object->stateBlock;
-
+    IWineD3DStateBlock_AddRef((IWineD3DStateBlock*)object->updateStateBlock);
     /* Setup surfaces for the backbuffer, frontbuffer and depthstencil buffer */
-    TRACE("Creating initial device surfaces\n");
 
-    /* We need to 'magic' either d3d8 or d3d9 surfaces for the front and backbuuffer 
-       but the respective CreateRenderTarget functions take a differing number of
-       parms. Fix this by passing in a function to call which takes identical parms
-       and handles the differences at the d3dx layer, and returns the IWineD3DSurface
-       pointer rather than the created D3D8/9 one                                      */
-    D3DCB_CreateRenderTarget((IUnknown *) parent,
-                             *(pPresentationParameters->BackBufferWidth),
-                             *(pPresentationParameters->BackBufferHeight),
-                             *(pPresentationParameters->BackBufferFormat),
-                             *(pPresentationParameters->MultiSampleType),
-                             *(pPresentationParameters->MultiSampleQuality),
-                             TRUE,
-                             (IWineD3DSurface **) &object->frontBuffer,
-                             NULL);
-
-    D3DCB_CreateRenderTarget((IUnknown *) parent,
-                             *(pPresentationParameters->BackBufferWidth),
-                             *(pPresentationParameters->BackBufferHeight),
-                             *(pPresentationParameters->BackBufferFormat),
-                             *(pPresentationParameters->MultiSampleType),
-                             *(pPresentationParameters->MultiSampleQuality),
-                             TRUE,
-                             (IWineD3DSurface **) &object->backBuffer,
-                             NULL);
-
-/* TODO: 
-    if (*(pPresentationParameters->EnableAutoDepthStencil)) {
-       IWineD3DDevice_CreateDepthStencilSurface((IWineD3DDevice *) object,
-                                                *(pPresentationParameters->BackBufferWidth),
-                                                *(pPresentationParameters->BackBufferHeight),
-                                                *(pPresentationParameters->AutoDepthStencilFormat,
-                                                D3DMULTISAMPLE_NONE,
-                                                (IWineD3DSurface *) &object->depthStencilBuffer);
-    } else {
-      object->depthStencilBuffer = NULL;
-    }
-    TRACE("FrontBuf @ %p, BackBuf @ %p, DepthStencil @ %p\n",object->frontBuffer, object->backBuffer, object->depthStencilBuffer);
-*/    
+    TRACE("Creating implicite swapchain\n");
 
-    /* init the default renderTarget management */
-    object->drawable     = object->win;
-    object->render_ctx   = object->glCtx;
-    object->renderTarget = object->backBuffer;
+    D3DCB_CreateAdditionalSwapChain((IUnknown *) object->parent, pPresentationParameters, (IWineD3DSwapChain **)&swapchain);        
     
-    IWineD3DSurface_AddRef((IWineD3DSurface *) object->renderTarget);
-/* TODO: Depth Stencil support
+    object->renderTarget =swapchain->backBuffer;
+    IWineD3DSurface_AddRef(object->renderTarget);
+    /* Depth Stencil support */
     object->stencilBufferTarget = object->depthStencilBuffer;
     if (NULL != object->stencilBufferTarget) {
-      IDirect3DSurface8Impl_AddRef((LPDIRECT3DSURFACE8) object->stencilBufferTarget);
+      IWineD3DSurface_AddRef(object->stencilBufferTarget);
     }
-*/    
-
-    /* Set up some starting GL setup */
-    ENTER_GL();
-
-    if (glXMakeCurrent(object->display, object->win, object->glCtx) == False) {
-      ERR("Error in setting current context (context %p drawable %ld)!\n", object->glCtx, object->win);
-    }
-    checkGLcall("glXMakeCurrent");
-
-    /* Clear the screen */
-    glClearColor(1.0, 0.0, 0.0, 0.0);
-    checkGLcall("glClearColor");
-    glColor3f(1.0, 1.0, 1.0);
-    checkGLcall("glColor3f");
-
-    glEnable(GL_LIGHTING);
-    checkGLcall("glEnable");
-
-    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
-    checkGLcall("glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);");
 
-    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);
-    checkGLcall("glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);");
 
-    glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);
-    checkGLcall("glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);");
+    /* Set up some starting GL setup */
 
+    ENTER_GL();
     /* 
      * Initialize openGL extension related variables
      *  with Default values 
      */
-    This->isGLInfoValid = IWineD3DImpl_FillGLCaps(&This->gl_info, object->display);
+     
+
+    This->isGLInfoValid = IWineD3DImpl_FillGLCaps(&This->gl_info, swapchain->display);
 
     /* Setup all the devices defaults */
     IWineD3DStateBlock_InitStartupStateBlock((IWineD3DStateBlock *)object->stateBlock); 
-
+    #if 0
+    IWineD3DImpl_CheckGraphicsMemory();
+    #endif
     LEAVE_GL();
 
+    
     { /* Set a default viewport */
        D3DVIEWPORT9 vp;
        vp.X      = 0;
@@ -1645,18 +1581,129 @@
     /* Clear the screen */
     IWineD3DDevice_Clear((IWineD3DDevice *) object, 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_ZBUFFER|D3DCLEAR_TARGET, 0x00, 1.0, 0);
 
-    } /* End of FIXME: remove when dx8 merged in */
+    }else { /* End of FIXME: remove when dx8 merged in */
+     FIXME("(%p) Incomplete stub for d3d8\n", This);
+    }
 
     return D3D_OK;
 }
 
 HRESULT WINAPI IWineD3DImpl_GetParent(IWineD3D *iface, IUnknown **pParent) {
     IWineD3DImpl *This = (IWineD3DImpl *)iface;
-    IUnknown_AddRef(This->parent);
     *pParent = This->parent;
+    TRACE("(%p) returning %p\n", This, *pParent);
+    IUnknown_AddRef(*pParent);    
     return D3D_OK;
 }
 
+/*This is a very simple 'hackish' check for Video memory, but the best you can do with OpenGL
+AGP memory can be assitained from 
+*/
+void IWineD3DImpl_CheckGraphicsMemory(void){
+
+
+   if (DeviceMemory == 0){
+      DeviceMemory = IWineD3DImpl_CalculateGraphicsMemory(0);      
+      FIXME("Memmory calculated as %ld\n",DeviceMemory);
+   }
+
+   
+   if(DeviceMemory == -1){
+      FIXME("Unable to determin the ammount of memory for the display adapter\n");
+      DeviceMemory =0;
+      return;
+   }
+   
+}
+ #include <stdio.h>
+
+long int IWineD3DImpl_CalculateGraphicsMemory(int maxAlloc){
+
+/*This function calculates the amount of grahpics memory on a device (or atleast the ammount left)
+Do not use in the middle of rendering as it will clobber all you textures!
+(This doesn't work on a ati9600 on linux with 8.8.25 drivers, it never reports any textures as resident) 
+
+*/
+    int      i, j;
+    int      counter = 0;
+    long     videoMemoryGuess = 0;
+    GLclampf priority1 = 1;
+    int*     texturedata;
+    GLuint          texture[2048]; /*upto 2gb of textures*/
+    GLboolean       residences[2048];
+    if(maxAlloc <= 0) maxAlloc = 256; /* should look at the agp apeture or the system memory size and guess */
+    for(i=0;i<maxAlloc;i++){
+        residences[i]=0;
+        texture[i] = 0;
+    }
+    glGenTextures(maxAlloc, texture); 
+    checkGLcall("glGenTextures");
+    
+    texturedata = HeapAlloc(GetProcessHeap(), 0, 512*512*4 /*1Mib*/);
+        if(texturedata == 0 ) {
+        FIXME("Memmory allocation error\n");
+        return 0;
+    }
+    
+    for(i=0;i<maxAlloc;i++){            
+        texturedata[i] = 1;
+        texturedata[i*512] = 1;  
+
+        
+        /* Give it priority 1 so that it should be put into videoram */
+
+        glEnable(GL_TEXTURE_2D);
+        glBindTexture(GL_TEXTURE_2D, texture[i]);
+        checkGLcall("glBindTexture");
+        glPrioritizeTextures(i, texture, &priority1);
+        glTexImage2D(GL_TEXTURE_2D
+                , 0 /* level */
+                , GL_RGBA 
+                , 512 /* width */
+                , 512 /* height */
+                , 0             
+                , GL_RGBA
+                , GL_UNSIGNED_BYTE
+                , texturedata);
+            checkGLcall("glTexImage2D");
+            
+     glPrioritizeTextures(i, texture, &priority1);
+     checkGLcall("glPrioritizeTextures");
+    
+        /* When we reach the next locical memory size 2,4,8,176,32,64,128,256 Mib check to see if any of the textures are no longer resident
+        giving a crude approximation as to the amout of memory that the video card has.
+        */ 
+        glPrioritizeTextures(i, texture, &priority1);
+        if(i == (1<<counter)-1){
+            int rescount=0;
+            TRACE("checking for %d textures\n",i);
+            videoMemoryGuess = 1<<counter;
+            /*Well, my ATI9600 !never! returns any resident textures*/
+            glAreTexturesResident(i, texture, residences);
+            counter++;
+            for(j=i;j>=0;j--){
+                if(residences[j])
+                    rescount++;
+            }                
+            FIXME("Resident textures %d\n",rescount);            
+            }
+    
+        }     
+    /* clean up */
+    FIXME("clean up %d\n",i);    
+    glDeleteTextures(maxAlloc,texture);    
+    /* return out guess */   
+    HeapFree(GetProcessHeap(), 0, texturedata);
+    FIXME("Guessing as %ld\n",videoMemoryGuess);    
+    return videoMemoryGuess;
+}
+#if 0 /* TODO: part of the interface cleanup */
+/* TODO: think about making this inline? */
+WineD3D_GL_Info WINAPI IWineD3DImpl_GetGLInfo(IWineD3D *iface){
+    IWineD3DImpl *This = (IWineD3DImpl *)iface;
+    return This->gl_info;
+}
+#endif 
 /**********************************************************
  * IWineD3D VTbl follows
  **********************************************************/
@@ -1681,4 +1728,7 @@
     IWineD3DImpl_CheckDeviceFormatConversion,
     IWineD3DImpl_GetDeviceCaps,
     IWineD3DImpl_CreateDevice
+    #if 0 /* TODO: part of the interface cleanup */
+    ,IWineD3DImpl_GetGLInfo
+    #endif
 };
diff -urN wine.20050419/dlls/wined3d/drawprim.c wine.20050419.dx9/dlls/wined3d/drawprim.c
--- wine.20050419/dlls/wined3d/drawprim.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/drawprim.c	2005-04-20 03:38:00.000000000 -0600
@@ -4,6 +4,7 @@
  * Copyright 2002-2004 Jason Edmeades
  * Copyright 2002-2004 Raphael Junqueira
  * Copyright 2004 Christian Costa
+ * Copyright 2005 Oliver Stieber
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -23,7 +24,7 @@
 #include "config.h"
 #include "wined3d_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d_draw);
 WINE_DECLARE_DEBUG_CHANNEL(d3d_shader);
 #define GLINFO_LOCATION ((IWineD3DImpl *)(This->wineD3D))->gl_info
 
@@ -39,12 +40,16 @@
    a vertex shader will be in use. Note the fvf bits returned may be split over
    multiple streams only if the vertex shader was created, otherwise it all relates
    to stream 0                                                                      */
+/* It may be better to just use the new vertex shaders, and off load this code to the setFVF functions on the device
+ *
+ * */
 BOOL initializeFVF(IWineD3DDevice *iface, 
                    DWORD *FVFbits,                 /* What to expect in the FVF across all streams */
                    BOOL *useVertexShaderFunction)  /* Should we use the vertex shader              */
 {
 
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    static BOOL fixmes = TRUE;/* only write out FIXME's if fixmes*/
 
 #if 0 /* TODO: d3d8 call setvertexshader needs to set the FVF in the state block when implemented */
     /* The first thing to work out is if we are using the fixed function pipeline 
@@ -63,6 +68,7 @@
         TRACE("FVF explicitally defined, using fixed function pipeline with FVF=%lx\n", *FVFbits);
 
     } else {
+        FIXME("line %d Vertex shaders\n", __LINE__);
 
 #if 0 /* TODO */
         /* Use created shader */
@@ -91,7 +97,11 @@
             }
         }
 #else
+	if(fixmes == TRUE){
         FIXME("Vertex Shaders not moved into wined3d yet\n");
+	fixmes = FALSE;
+	}
+	
 #endif
     }
     return FALSE;
@@ -142,13 +152,14 @@
         break;
 
     default:
-        FIXME("Unhandled primitive\n");
+        FIXME("Unhandled primitive, defaulting to GL_POINT\n");
         *primType    = GL_POINTS;
         break;
     }  
     return NumVertexes;
 }
 
+
 /* Ensure the appropriate material states are set up - only change
    state if really required                                        */
 void init_materials(IWineD3DDevice *iface, BOOL isDiffuseSupplied) {
@@ -186,7 +197,6 @@
         This->tracking_color = DISABLED_TRACKING;
         requires_material_reset = TRUE; /* Restore material settings as will be used */
     }
-
     /* Reset the material colors which may have been tracking the color*/
     if (requires_material_reset) {
         glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, (float*) &This->stateBlock->material.Ambient);
@@ -222,16 +232,21 @@
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
     /* If no normals, DISABLE lighting otherwise, don't touch lighing as it is
-       set by the appropriate render state. Note Vertex Shader output is already lit */
-    if (vtx_lit || useVS) {
+       set by the appropriate render state. Note Vertex Shader output is already lit
+
+
+
+       */
         isLightingOn = glIsEnabled(GL_LIGHTING);
+    if (vtx_lit || useVS) {
+        if(!isLightingOn){
         glDisable(GL_LIGHTING);
         checkGLcall("glDisable(GL_LIGHTING);");
         TRACE("Disabled lighting as no normals supplied, old state = %d\n", isLightingOn);
     }
+    }
 
     if (!useVS && vtx_transformed) {
-
         /* If the last draw was transformed as well, no need to reapply all the matrixes */
         if (!This->last_was_rhw) {
 
@@ -275,22 +290,70 @@
     } else {
 
         /* Untransformed, so relies on the view and projection matrices */
+        /* TODO: blends */
 
         if (!useVS && (This->last_was_rhw || !This->modelview_valid)) {
             /* Only reapply when have to */
             This->modelview_valid = TRUE;
+
             glMatrixMode(GL_MODELVIEW);
-            checkGLcall("glMatrixMode");
+            checkGLcall("glMatrixMode(GL_MODELVIEW)");
 
             /* In the general case, the view matrix is the identity matrix */
             if (This->view_ident) {
+                checkGLcall("glMatrixMode(GL_MODELVIEW)");
                 glLoadMatrixf((float *) &This->stateBlock->transforms[D3DTS_WORLDMATRIX(0)].u.m[0][0]);
                 checkGLcall("glLoadMatrixf");
             } else {
+
+                    switch (This->stateBlock->renderState[D3DRS_VERTEXBLEND]) {
+#if 0 /* TODO: Vertex blending */
+                    default:
+                    case D3DVBF_3WEIGHTS:
+                        glMatrixMode(GL_MODELVIEW3_ARB);
+                        checkGLcall("glMatrixMode(GL_MODELVIEW3_ARB)");
+                        glLoadMatrixf((float *)&This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
+                        checkGLcall("glLoadMatrixf");
+                        glMultMatrixf((float *)&This->stateBlock->transforms[D3DTS_WORLDMATRIX(3)].u.m[0][0]);
+                        checkGLcall("glMultMatrixf");
+                    case D3DVBF_2WEIGHTS:         /* fall through */
+                        glMatrixMode(GL_MODELVIEW2_ARB);
+                        checkGLcall("glMatrixMode(GL_MODELVIEW2_ARB)");
+                        glLoadMatrixf((float *)&This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
+                        checkGLcall("glLoadMatrixf");
+                        glMultMatrixf((float *)&This->stateBlock->transforms[D3DTS_WORLDMATRIX(2)].u.m[0][0]);
+                        checkGLcall("glMultMatrixf");
+                    case D3DVBF_1WEIGHTS:         /* fall through */
+                        glMatrixMode(GL_MODELVIEW1_ARB);
+                        checkGLcall("glMatrixMode(GL_MODELVIEW2_ARB)");
+                        glLoadMatrixf((float *)&This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
+                        checkGLcall("glLoadMatrixf");
+                        glMultMatrixf((float *)&This->stateBlock->transforms[D3DTS_WORLDMATRIX(1)].u.m[0][0]);
+                        checkGLcall("glMultMatrixf");
+#else
+                    default:
+                    case D3DVBF_3WEIGHTS:
+                    case D3DVBF_2WEIGHTS:
+                    case D3DVBF_1WEIGHTS:
+#endif
+                    case  D3DVBF_DISABLE: /* default state (fall through) */
+                        glMatrixMode(GL_MODELVIEW);
+                        checkGLcall("glMatrixMode(GL_MODELVIEW)");
                 glLoadMatrixf((float *) &This->stateBlock->transforms[D3DTS_VIEW].u.m[0][0]);
                 checkGLcall("glLoadMatrixf");
                 glMultMatrixf((float *) &This->stateBlock->transforms[D3DTS_WORLDMATRIX(0)].u.m[0][0]);
                 checkGLcall("glMultMatrixf");
+                    break;
+                    case D3DVBF_0WEIGHTS:  /* identity */
+                        glMatrixMode(GL_MODELVIEW);
+                        checkGLcall("glMatrixMode(GL_MODELVIEW)");
+                        glLoadMatrixf((float *) &This->stateBlock->transforms[D3DTS_WORLDMATRIX(0)].u.m[0][0]);
+                        checkGLcall("glLoadMatrixf");
+                    break;
+                    case D3DVBF_TWEENING:
+                        FIXME("TODO: Tweening\n");
+                    break;
+                    };
             }
         }
 
@@ -346,7 +409,147 @@
     return isLightingOn;
 }
 
+
+
+
+void primitiveDeclarationConvertToStridedData(IWineD3DDevice *iface, Direct3DVertexStridedData *strided, LONG BaseVertexIndex, DWORD *fvf) {
+     /* We need to deal with frequency data!*/
+
+    int           textureNo =0;
+    BYTE  *data    = NULL;
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    IWineD3DVertexDeclarationImpl* vertexDeclaration = (IWineD3DVertexDeclarationImpl*)This->stateBlock->vertexDecl;
+    int i;
+    D3DVERTEXELEMENT9 *element;
+    DWORD stride;
+    for(i = 0 ; i <vertexDeclaration->declaration9NumElements -1; i++){
+        element=vertexDeclaration->pDeclaration9+i;
+        if (This->stateBlock->streamIsUP) {
+            data    = (BYTE *)This->stateBlock->streamSource[element->Stream];
+        } else {
+            data    = ((IWineD3DVertexBufferImpl *)This->stateBlock->streamSource[element->Stream])->resource.allocatedMemory;
+        }
+        stride  = This->stateBlock->streamStride[element->Stream];
+        data = data + (BaseVertexIndex * stride);
+        data+= element->Offset;
+        /* Why can't I just use a lookup table instead of a switch statment?*/
+        switch(element->Usage){
+        case D3DDECLUSAGE_POSITION:
+                switch(element->UsageIndex){
+                case 0: /* N-patch */
+                    strided->u.s.position.lpData    = data;
+                    strided->u.s.position.dwType    = element->Type;
+                    strided->u.s.position.dwStride  = stride;
+                break;
+                case 1: /* skinning */
+                    FIXME("Skinning positions\n");
+                break;
+                }
+        break;
+        case D3DDECLUSAGE_NORMAL:
+                switch(element->UsageIndex){
+                case 0: /* N-patch */
+                    strided->u.s.normal.lpData    = data;
+                    strided->u.s.normal.dwType    = element->Type;
+                    strided->u.s.normal.dwStride  = stride;
+                break;
+                case 1: /* skinning */
+                   FIXME("Skinning normals\n");
+                break;
+                }
+                *fvf |=  D3DFVF_NORMAL;
+        break;
+        case D3DDECLUSAGE_BLENDINDICES:
+            strided->u.s.blendMatrixIndices.lpData  = data;
+            strided->u.s.blendMatrixIndices.dwType  = element->Type;
+            strided->u.s.blendMatrixIndices.dwStride= stride;
+        break;
+        case D3DDECLUSAGE_BLENDWEIGHT:
+            strided->u.s.blendWeights.lpData        = data;
+            strided->u.s.blendWeights.dwType        = element->Type;
+            strided->u.s.blendWeights.dwStride      = stride;
+        break;
+        case D3DDECLUSAGE_PSIZE:
+            strided->u.s.pSize.lpData               = data;
+            strided->u.s.pSize.dwType               = element->Type;
+            strided->u.s.pSize.dwStride             = stride;
+        break;
+        case D3DDECLUSAGE_COLOR:
+        switch(element->UsageIndex){
+        case 0:/* diffuse */
+            strided->u.s.diffuse.lpData             = data;
+            strided->u.s.diffuse.dwType             = element->Type;
+            strided->u.s.diffuse.dwStride           = stride;
+        break;
+        case 1: /* specular */
+            strided->u.s.specular.lpData            = data;
+            strided->u.s.specular.dwType            = element->Type;
+            strided->u.s.specular.dwStride          = stride;
+        }
+
+        break;
+        case D3DDECLUSAGE_TEXCOORD:
+        /* For some odd reason Microsoft desided to sum usage accross all the streams,
+        which means we need to do a count and not just use the usage number */
+
+            strided->u.s.texCoords[textureNo].lpData    = data;
+            strided->u.s.texCoords[textureNo].dwType    = element->Type;
+            strided->u.s.texCoords[textureNo].dwStride  = stride;
+
+        textureNo++;
+        break;
+        case D3DDECLUSAGE_TANGENT:
+        /* example of using tangents in opengl http://opengl.nutty.org/*/
+        /* here's a description of not using tangents! http://www.3dkingdoms.com/tutorial.htm (should a tangent just be the perpendicular of the normal anyhow?)
+        */
+        FIXME("Tangents\n");
+        break;
+        case D3DDECLUSAGE_BINORMAL:
+        /* don't know what d3d uses this for but I would expect it to be
+        something like     y=mx+c    */
+        FIXME("BI-Normal\n");
+        break;
+        case D3DDECLUSAGE_TESSFACTOR:
+        FIXME("Tess Factor\n");
+        break;
+        case D3DDECLUSAGE_POSITIONT:
+
+               switch(element->UsageIndex){
+                case 0: /* N-patch */
+                    strided->u.s.position.lpData    = data;
+                    strided->u.s.position.dwType    = element->Type;
+                    strided->u.s.position.dwStride  = stride;
+                break;
+                case 1: /* skinning */
+                    FIXME("Skinning positionsT?\n");
+                break;
+                }
+                *fvf |= D3DFVF_XYZRHW;
+            /* FIXME: were faking this flag so that we don't transform the data again */
+        break;
+        case D3DDECLUSAGE_FOG:
+        FIXME("Fog\n");
+        break;
+        case D3DDECLUSAGE_DEPTH: /* Who knows!*/
+        FIXME("depth\n");
+        break;
+#if 0
+        case D3DDECLUSAGE_SAMPLE:
+        break:
+#endif
+        };
+
+    };
+
+}
+
+
+
+
+
+
 void primitiveConvertToStridedData(IWineD3DDevice *iface, Direct3DVertexStridedData *strided, LONG BaseVertexIndex) {
+     /* We need to deal with frequency data!*/
 
     short         LoopThroughTo = 0;
     short         nStream;
@@ -356,9 +559,15 @@
     int           textureNo;
     int           coordIdxInfo = 0x00;    /* Information on number of coords supplied */
     int           numCoords[8];           /* Holding place for D3DFVF_TEXTUREFORMATx  */
+    BYTE         *data    = NULL;
+    DWORD         thisFVF = 0;
+    DWORD         stride;
+  
+  
 
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
 
+   /* We also mage vertex declarations to manage!*/
     /* OK, Now to setup the data locations 
        For the non-created vertex shaders, the VertexShader var holds the real 
           FVF and only stream 0 matters
@@ -367,39 +576,48 @@
         LoopThroughTo = MAX_STREAMS;
     } else {
         LoopThroughTo = 1;
+        if(This->updateStateBlock->vertexShader){
+                    FIXME("line %d Vertex shaders\n", __LINE__);
+        }
     }
 
     /* Work through stream by stream */
     for (nStream=0; nStream<LoopThroughTo; nStream++) {
-        DWORD  stride  = This->stateBlock->stream_stride[nStream];
-        BYTE  *data    = NULL;
-        DWORD  thisFVF = 0;
+        if(This->stateBlock->streamFreq[nStream]!=1 && This->stateBlock->streamFreq[nStream] != 0){
+            FIXME("Indexed or instanced data arn't managed properly yet\n");
+            /*
+            continue;
+            */
+        }else{
+            TRACE("stream fres %d \n", This->stateBlock->streamFreq[nStream]);
+        }
+        stride  = This->stateBlock->streamStride[nStream];
 
         /* Skip empty streams */
-        if (This->stateBlock->stream_source[nStream] == NULL) continue;
-
+        if (This->stateBlock->streamSource[nStream] == NULL) continue;
         /* Retrieve appropriate FVF */
         if (LoopThroughTo == 1) { /* Use FVF, not vertex shader */
             thisFVF = This->updateStateBlock->fvf;
             /* Handle memory passed directly as well as vertex buffers */
             if (This->stateBlock->streamIsUP) {
-                data    = (BYTE *)This->stateBlock->stream_source[nStream];
+                data    = (BYTE *)This->stateBlock->streamSource[nStream];
             } else {
-                data    = ((IWineD3DVertexBufferImpl *)This->stateBlock->stream_source[nStream])->resource.allocatedMemory;
+                data    = ((IWineD3DVertexBufferImpl *)This->stateBlock->streamSource[nStream])->resource.allocatedMemory;
             }
         } else {
-#if 0 /* TODO: Vertex shader support */
-            thisFVF = This->stateBlock->vertexShaderDecl->fvf[nStream];
-            data    = ((IDirect3DVertexBuffer8Impl *)This->stateBlock->stream_source[nStream])->allocatedMemory;
-#endif
+        /*
+        FIXME("TODO: vertex shader support\n");
+            thisFVF = ((IWineD3DVertexDeclarationImpl *)This->stateBlock->vertexDecl)->fvf[nStream];
+            data    = ((IWineD3DVertexBufferImpl *)This->stateBlock->streamSource[nStream])->allocatedMemory;
+            */
         }
         VTRACE(("FVF for stream %d is %lx\n", nStream, thisFVF));
-        if (thisFVF == 0) continue;
+        if (thisFVF == 0 /*|| thisFVF == 274 */) continue;
 
         /* Now convert the stream into pointers */
 
         /* Shuffle to the beginning of the vertexes to render and index from there */
-        data = data + (BaseVertexIndex * stride);
+        data += (BaseVertexIndex * stride);
 
         /* Either 3 or 4 floats depending on the FVF */
         /* FIXME: Can blending data be in a different stream to the position data? 
@@ -417,15 +635,20 @@
 
         /* Blending is numBlends * FLOATs followed by a DWORD for UBYTE4 */
         /** do we have to Check This->updateStateBlock->renderState[D3DRS_INDEXEDVERTEXBLENDENABLE] ? */
-        numBlends = ((thisFVF & D3DFVF_POSITION_MASK) >> 1) - 2 + 
-                    ((FALSE == (thisFVF & D3DFVF_LASTBETA_UBYTE4)) ? 0 : -1);    /* WARNING can be < 0 because -2 */
+        /* What about this */
+
+        numBlends = ((thisFVF & D3DFVF_XYZB4) == D3DFVF_XYZB4)?4:(((thisFVF &  D3DFVF_XYZB3) == D3DFVF_XYZB3)?3:0);
+        if(thisFVF & D3DFVF_LASTBETA_UBYTE4) numBlends--;
+
         if (numBlends > 0) {
             canDoViaGLPointers = FALSE; 
+
             strided->u.s.blendWeights.lpData    = data;
-            strided->u.s.blendWeights.dwType    = D3DDECLTYPE_FLOAT1 + (numBlends - 1);
+            strided->u.s.blendWeights.dwType    = D3DDECLTYPE_FLOAT1 +numBlends -1;
             strided->u.s.blendWeights.dwStride  = stride;
             data += numBlends * sizeof(FLOAT);
 
+            /* setup matrix indicies */
             if (thisFVF & D3DFVF_LASTBETA_UBYTE4) {
                 strided->u.s.blendMatrixIndices.lpData = data;
                 strided->u.s.blendMatrixIndices.dwType  = D3DDECLTYPE_UBYTE4; 
@@ -637,7 +860,7 @@
  * Faster GL version using pointers to data, harder to debug though 
  * Note does not handle vertex shaders yet                             
  */
-void drawStridedFast(IWineD3DDevice *iface, Direct3DVertexStridedData *sd, 
+BOOL drawStridedFast(IWineD3DDevice *iface, Direct3DVertexStridedData *sd,
                      int PrimitiveType, ULONG NumPrimitives,
                      const void *idxData, short idxSize, ULONG minIndex, ULONG startIdx) {
     unsigned int textureNo   = 0;
@@ -647,82 +870,112 @@
 
     TRACE("Using fast vertex array code\n");
 
-    /* Vertex Pointers -----------------------------------------*/
-    if (sd->u.s.position.lpData != NULL) {
 
-        /* Note dwType == float3 or float4 == 2 or 3 */
-        VTRACE(("glVertexPointer(%ld, GL_FLOAT, %ld, %p)\n", 
-                sd->u.s.position.dwStride, 
-                sd->u.s.position.dwType + 1, 
-                sd->u.s.position.lpData));
-
-        /* Disable RHW mode as 'w' coord handling for rhw mode should
-           not impact screen position whereas in GL it does. This may 
-           result in very slightly distored textures in rhw mode, but
-           a very minimal different                                   */
-        glVertexPointer(3, GL_FLOAT,  /* RHW: Was 'sd->u.s.position.dwType + 1' */
-                        sd->u.s.position.dwStride, 
-                        sd->u.s.position.lpData);
-        checkGLcall("glVertexPointer(...)");
-        glEnableClientState(GL_VERTEX_ARRAY);
-        checkGLcall("glEnableClientState(GL_VERTEX_ARRAY)");
-
-    } else {
-
-        glDisableClientState(GL_VERTEX_ARRAY);
-        checkGLcall("glDisableClientState(GL_VERTEX_ARRAY)");
-    }
 
     /* Blend Data ----------------------------------------------*/
     if ((sd->u.s.blendWeights.lpData != NULL) || 
         (sd->u.s.blendMatrixIndices.lpData != NULL)) {
-#if 1 /* Vertex blend support needs to be added */
+
+
         if (GL_SUPPORT(ARB_VERTEX_BLEND)) {   
-	  DWORD fvf = (sd->u.s.blendWeights.dwType - D3DDECLTYPE_FLOAT1) + 1;
-	  int numBlends = ((fvf & D3DFVF_POSITION_MASK) >> 1) - 2 + ((FALSE == (fvf & D3DFVF_LASTBETA_UBYTE4)) ? 0 : -1);
      
+           int numBlends = sd->u.s.blendWeights.dwType - D3DDECLTYPE_FLOAT1 + 1;
+
+            glEnableClientState(GL_WEIGHT_ARRAY_ARB);
+            checkGLcall("glEnableClientState(GL_WEIGHT_ARRAY_ARB)");
+
+
+            TRACE("Blend %d %ld %p %ld\n", numBlends, startIdx, sd->u.s.blendWeights.lpData, sd->u.s.blendWeights.dwStride);
 	  /*FIXME("TODO\n");*/
 	  /* Note dwType == float3 or float4 == 2 or 3 */
 	  VTRACE(("glWeightPointerARB(%ld, GL_FLOAT, %ld, %p)\n", 
 		  numBlends, 
 	          sd->u.s.blendWeights.dwStride, 
 		  sd->u.s.blendWeights.lpData));
+
 	  GL_EXTCALL(glWeightPointerARB)(numBlends, GL_FLOAT,
 					 sd->u.s.blendWeights.dwStride, 
 					 sd->u.s.blendWeights.lpData);
-	  checkGLcall("glWeightPointerARB(...)");
-	  glEnableClientState(GL_WEIGHT_ARRAY_ARB);
-	  checkGLcall("glEnableClientState(GL_VERTEX_ARRAY)");
+
+            checkGLcall("glWeightPointerARB");
+#if 0 /* TODO: Vertex blending TODO: move this to before drawstrided so that it is shared with slow and fast */
+            /* with this on, the normals appear to be being modified,
+               but the textices aren't being translated as they should be
+               Maybe the world matrix aren't being setup properly? */
+
+                glEnable(GL_VERTEX_BLEND_ARB);
+                GL_EXTCALL(glVertexBlendARB)(numBlends + 1);
+#endif
+
+            if(sd->u.s.blendMatrixIndices.lpData != NULL){
+                FIXME("blendMatrixIndices support\n");
+            }
+
+
         } else if (GL_SUPPORT(EXT_VERTEX_WEIGHTING)) {
             /*FIXME("TODO\n");*/
-            /*
-            GLExtCall(glVertexWeightPointerEXT)(numBlends, GL_FLOAT, skip, curPos); 
+#if 0
+            GL_EXTCALL(glVertexWeightPointerEXT)(numBlends, GL_FLOAT,
+                                                sd->u.s.blendWeights.dwStride,
+                                                sd->u.s.blendWeights.lpData);
             checkGLcall("glVertexWeightPointerEXT(numBlends, ...)");
             glEnableClientState(GL_VERTEX_WEIGHT_ARRAY_EXT);
             checkGLcall("glEnableClientState(GL_VERTEX_WEIGHT_ARRAY_EXT)");
-            */
+#endif
+
         } else {
             FIXME("unsupported blending in openGl\n");
+            return FALSE;
         }
     } else {
         if (GL_SUPPORT(ARB_VERTEX_BLEND)) {
-            FIXME("TODO\n");
+#if 0    /* TODO: Vertex blending */
+            glDisable(GL_VERTEX_BLEND_ARB);
+#endif
+            TRACE("ARB_VERTEX_BLEND \n");
         } else if (GL_SUPPORT(EXT_VERTEX_WEIGHTING)) {
-            FIXME("TODO\n");
-            /*
+            TRACE(" EXT_VERTEX_WEIGHTING\n");
             glDisableClientState(GL_VERTEX_WEIGHT_ARRAY_EXT);
             checkGLcall("glDisableClientState(GL_VERTEX_WEIGHT_ARRAY_EXT)");
-            */
+
         }
-#else
-        /* FIXME: Won't get here as will drop to slow method        */
-        FIXME("Blending not supported in fast draw routine\n");
-#endif
+    }
+
+    /* Point Size ----------------------------------------------*/
+    if (sd->u.s.pSize.lpData != NULL) {
+
+        /* no such functionality in the fixed function GL pipeline */
+        TRACE("Cannot change ptSize here in openGl\n");
+        return FALSE;
+
+    }
+
+    /* Vertex Pointers -----------------------------------------*/
+    if (sd->u.s.position.lpData != NULL) {
+        /* Note dwType == float3 or float4 == 2 or 3 */
+        VTRACE(("glVertexPointer(%ld, GL_FLOAT, %ld, %p)\n",
+                sd->u.s.position.dwStride,
+                sd->u.s.position.dwType + 1,
+                sd->u.s.position.lpData));
+
+        /* Disable RHW mode as 'w' coord handling for rhw mode should
+           not impact screen position whereas in GL it does. This may
+           result in very slightly distored textures in rhw mode, but
+           a very minimal different                                   */
+        glVertexPointer(3, GL_FLOAT,  /* RHW: Was 'sd->u.s.position.dwType + 1' */
+                        sd->u.s.position.dwStride,
+                        sd->u.s.position.lpData);
+        checkGLcall("glVertexPointer(...)");
+        glEnableClientState(GL_VERTEX_ARRAY);
+        checkGLcall("glEnableClientState(GL_VERTEX_ARRAY)");
+
+    } else {
+        glDisableClientState(GL_VERTEX_ARRAY);
+        checkGLcall("glDisableClientState(GL_VERTEX_ARRAY)");
     }
 
     /* Normals -------------------------------------------------*/
     if (sd->u.s.normal.lpData != NULL) {
-
         /* Note dwType == float3 or float4 == 2 or 3 */
         VTRACE(("glNormalPointer(GL_FLOAT, %ld, %p)\n", 
                 sd->u.s.normal.dwStride, 
@@ -735,31 +988,22 @@
         checkGLcall("glEnableClientState(GL_NORMAL_ARRAY)");
 
     } else {
-
         glDisableClientState(GL_NORMAL_ARRAY);
         checkGLcall("glDisableClientState(GL_NORMAL_ARRAY)");
         glNormal3f(0, 0, 1);
         checkGLcall("glNormal3f(0, 0, 1)");
     }
 
-    /* Point Size ----------------------------------------------*/
-    if (sd->u.s.pSize.lpData != NULL) {
-
-        /* no such functionality in the fixed function GL pipeline */
-        /* FIXME: Won't get here as will drop to slow method        */
-        FIXME("Cannot change ptSize here in openGl\n");
-    }
-
     /* Diffuse Colour ------------------------------------------*/
     /*  WARNING: Data here MUST be in RGBA format, so cannot    */
     /*     go directly into fast mode from app pgm, because     */
     /*     directx requires data in BGRA format.                */
     if (sd->u.s.diffuse.lpData != NULL) {
-
         /* Note dwType == float3 or float4 == 2 or 3 */
         VTRACE(("glColorPointer(4, GL_UNSIGNED_BYTE, %ld, %p)\n", 
                 sd->u.s.diffuse.dwStride, 
                 sd->u.s.diffuse.lpData));
+
         glColorPointer(4, GL_UNSIGNED_BYTE, 
                        sd->u.s.diffuse.dwStride, 
                        sd->u.s.diffuse.lpData);
@@ -768,7 +1012,6 @@
         checkGLcall("glEnableClientState(GL_COLOR_ARRAY)");
 
     } else {
-
         glDisableClientState(GL_COLOR_ARRAY);
         checkGLcall("glDisableClientState(GL_COLOR_ARRAY)");
         glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
@@ -777,7 +1020,7 @@
 
     /* Specular Colour ------------------------------------------*/
     if (sd->u.s.specular.lpData != NULL) {
-
+        TRACE("setting specular colour\n");
         /* Note dwType == float3 or float4 == 2 or 3 */
         VTRACE(("glSecondaryColorPointer(4, GL_UNSIGNED_BYTE, %ld, %p)\n", 
                 sd->u.s.specular.dwStride, 
@@ -791,17 +1034,19 @@
             glEnableClientState(GL_SECONDARY_COLOR_ARRAY_EXT);
             vcheckGLcall("glEnableClientState(GL_SECONDARY_COLOR_ARRAY_EXT)");
         } else {
+
 	  /* Missing specular color is not critical, no warnings */
 	  VTRACE(("Specular colour is not supported in this GL implementation\n"));
 	}
 
     } else {
-
       if (GL_SUPPORT(EXT_SECONDARY_COLOR)) {
+
 	glDisableClientState(GL_SECONDARY_COLOR_ARRAY_EXT);
 	checkGLcall("glDisableClientState(GL_SECONDARY_COLOR_ARRAY_EXT)");
 	GL_EXTCALL(glSecondaryColor3fEXT)(0, 0, 0);
 	checkGLcall("glSecondaryColor3fEXT(0, 0, 0)");
+	
       } else {
 	/* Missing specular color is not critical, no warnings */
 	VTRACE(("Specular colour is not supported in this GL implementation\n"));
@@ -809,12 +1054,11 @@
     }
 
     /* Texture coords -------------------------------------------*/
+
     for (textureNo = 0; textureNo < GL_LIMITS(textures); ++textureNo) {
 
         /* Select the correct texture stage */
         GLCLIENTACTIVETEXTURE(textureNo);
-
-        /* Query tex coords */
         if (This->stateBlock->textures[textureNo] != NULL) {
             int coordIdx = This->updateStateBlock->textureState[textureNo][D3DTSS_TEXCOORDINDEX];
 
@@ -852,7 +1096,6 @@
     		default: FIXME("Unrecognized data type %ld\n", sd->u.s.texCoords[coordIdx].dwType);
                       size = 4; type = GL_UNSIGNED_BYTE;
     		}
-
     		glTexCoordPointer(size, type, sd->u.s.texCoords[coordIdx].dwStride, sd->u.s.texCoords[coordIdx].lpData);
     		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
     	    }
@@ -865,15 +1108,16 @@
     /* Ok, Work out which primitive is requested and how many vertexes that 
        will be                                                              */
     NumVertexes = primitiveToGl(PrimitiveType, NumPrimitives, &glPrimType);
-
     /* Finally do the drawing */
-    if (idxData != NULL) {
 
-        TRACE("glElements(%x, %d, %ld, ...)\n", glPrimType, NumVertexes, minIndex);
-#if 1  /* FIXME: Want to use DrawRangeElements, but wrong calculation! */
+    if (idxData != NULL /* This crashes sometimes!*/) {
+        VTRACE(("glElements(%x, %d, %ld, ...)\n", glPrimType, NumVertexes, minIndex));	
+#if 0
+
         glDrawElements(glPrimType, NumVertexes, idxSize==2?GL_UNSIGNED_SHORT:GL_UNSIGNED_INT,
                       (const char *)idxData+(idxSize * startIdx));
-#else
+#else /* This calcualtion works fine for my ATI-9600!*/
+
         glDrawRangeElements(glPrimType, minIndex, minIndex+NumVertexes-1, NumVertexes, 
                       idxSize==2?GL_UNSIGNED_SHORT:GL_UNSIGNED_INT, 
                       (const char *)idxData+(idxSize * startIdx));
@@ -888,6 +1132,7 @@
         checkGLcall("glDrawArrays");
 
     }
+    return TRUE;
 }
 
 /* 
@@ -905,20 +1150,50 @@
     const long                *pIdxBufL     = NULL;
     LONG                       SkipnStrides = 0;
     LONG                       vx_index;
+    int                        numBlends    = 0;
     float x  = 0.0f, y  = 0.0f, z = 0.0f;  /* x,y,z coordinates          */
     float nx = 0.0f, ny = 0.0, nz = 0.0f;  /* normal x,y,z coordinates   */
     float rhw = 0.0f;                      /* rhw                        */
     float ptSize = 0.0f;                   /* Point size                 */
+    float *bw; /* blend weights */
     DWORD diffuseColor = 0xFFFFFFFF;       /* Diffuse Color              */
     DWORD specularColor = 0;               /* Specular Color             */
     IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+    /* For each primitive */
+    float *ptrToCoords;
+
+    char *position                 = sd->u.s.position.lpData;
+    int   positionStrideSize       = sd->u.s.position.dwStride;
+    char *blendWeights             = sd->u.s.blendWeights.lpData;
+    int   blendWeightsStrideSize   = sd->u.s.blendWeights.dwStride;
+
+    char *normal                   = sd->u.s.normal.lpData;
+    int   normalStrideSize         = sd->u.s.normal.dwStride;
+    char *pSize                    = sd->u.s.pSize.lpData;
+    int   pSizeStrideSize          = sd->u.s.pSize.dwStride;
+
+    char *diffuse                  = sd->u.s.diffuse.lpData;
+    int   diffuseStrideSize        = sd->u.s.diffuse.dwStride;
+    char *specular                 = sd->u.s.specular.lpData;
+    int   specularStrideSize       = sd->u.s.specular.dwStride;
 
-    TRACE("Using slow vertex array code\n");
+    /* OK this is a bit of a mess... tidy up, use pointer arythnamitic to make things a lot clearer!*/
+    /* Ok, what the hell is u.s.[name].dwStride */
 
+
+    TRACE("Using slow vertex array code %p type%d, count:%ld ,idxData%p, idxSize%d min%ld start%ld\n" ,sd, PrimitiveType, NumPrimitives, idxData, idxSize, minIndex, startIdx);
+#if 0
+    /* dodgy stuff in Axis&Allies !! s*/
+    if((int) sd ==  0x406ef5c4) return;
+    if((int) sd ==  0x406ef588) return;
+    if((int) sd ==  0x406efad4 && NumPrimitives == 2) return; /* another bad one!*/
+#endif
     /* Variable Initialization */
     if (idxData != NULL) {
-        if (idxSize == 2) pIdxBufS = (const short *) idxData;
-        else pIdxBufL = (const long *) idxData;
+        if (idxSize == 2)
+            pIdxBufS = ((const short *) idxData) + startIdx;
+        else
+            pIdxBufL = ((const long *) idxData) + startIdx;
     }
 
     /* Ok, Work out which primitive is requested and how many vertexes that will be */
@@ -928,90 +1203,80 @@
     VTRACE(("glBegin(%x)\n", glPrimType));
     glBegin(glPrimType);
 
-    /* For each primitive */
+    /* It may be a good idea to split into draw indexes and draw non-indexed to help the compiler out (and make this function a bit smaller! */
     for (vx_index = 0; vx_index < NumVertexes; vx_index++) {
 
-        /* Initialize diffuse color */
-        diffuseColor = 0xFFFFFFFF;
-
-        /* For indexed data, we need to go a few more strides in */
         if (idxData != NULL) {
-
-            /* Indexed so work out the number of strides to skip */
-            if (idxSize == 2) {
-                VTRACE(("Idx for vertex %ld = %d\n", vx_index, pIdxBufS[startIdx+vx_index]));
-                SkipnStrides = pIdxBufS[startIdx+vx_index];
-            } else {
-                VTRACE(("Idx for vertex %ld = %ld\n", vx_index, pIdxBufL[startIdx+vx_index]));
-                SkipnStrides = pIdxBufL[startIdx+vx_index];
-            }
+            if (idxSize == 2)
+                SkipnStrides = *pIdxBufS++;
+            else
+                SkipnStrides = *pIdxBufL++;
         }
 
-        /* Position Information ------------------ */
-        if (sd->u.s.position.lpData != NULL) {
+        /* Initialize diffuse color */
+        diffuseColor = 0xFFFFFFFF;
 
-            float *ptrToCoords = (float *)(sd->u.s.position.lpData + (SkipnStrides * sd->u.s.position.dwStride));
-            x = ptrToCoords[0];
-            y = ptrToCoords[1];
-            z = ptrToCoords[2];
-            rhw = 1.0;
-            VTRACE(("x,y,z=%f,%f,%f\n", x,y,z));
+        /* Position information ------------------- */
+        if(position != NULL){
+            ptrToCoords = (float*)(position + (SkipnStrides * positionStrideSize));
+            x = *ptrToCoords++;
+            y = *ptrToCoords++;
+            z = *ptrToCoords++;
 
             /* RHW follows, only if transformed, ie 4 floats were provided */
             if (sd->u.s.position.dwType == D3DDECLTYPE_FLOAT4) {
-                rhw = ptrToCoords[3];
-                VTRACE(("rhw=%f\n", rhw));
+                rhw = *ptrToCoords;
+            } else {
+                rhw = 1.0;
             }
+            VTRACE(("x,y,z,rhw=%f,%f,%f,%f\n", x,y,z,rhw));
         }
 
         /* Blending data -------------------------- */
-        if (sd->u.s.blendWeights.lpData != NULL) {
-            /*float *ptrToCoords = (float *)(sd->u.s.blendWeights.lpData + (SkipnStrides * sd->u.s.blendWeights.dwStride));*/
-            FIXME("Blending not supported yet\n");
-
+        if (blendWeights != NULL) {
+            bw = (float *)(blendWeights + (SkipnStrides * blendWeightsStrideSize));
+            numBlends = sd->u.s.blendWeights.dwType - D3DDECLTYPE_FLOAT1 + 1;
             if (sd->u.s.blendMatrixIndices.lpData != NULL) {
-                /*DWORD *ptrToCoords = (DWORD *)(sd->u.s.blendMatrixIndices.lpData + (SkipnStrides * sd->u.s.blendMatrixIndices.dwStride));*/
+                DWORD *ptrToCoords = (DWORD *)(sd->u.s.blendMatrixIndices.lpData + (SkipnStrides * sd->u.s.blendMatrixIndices.dwStride));
+                TRACE("Blending matrix not supported yet %p\n", ptrToCoords);
             }
         }
 
         /* Vertex Normal Data (untransformed only)- */
-        if (sd->u.s.normal.lpData != NULL) {
-
-            float *ptrToCoords = (float *)(sd->u.s.normal.lpData + (SkipnStrides * sd->u.s.normal.dwStride));
-            nx = ptrToCoords[0];
-            ny = ptrToCoords[1];
-            nz = ptrToCoords[2];
+        if (normal != NULL) {
+            ptrToCoords = (float *)(normal + (SkipnStrides * normalStrideSize));
+            nx = *ptrToCoords++;
+            ny = *ptrToCoords++;
+            nz = *ptrToCoords++;
             VTRACE(("nx,ny,nz=%f,%f,%f\n", nx, ny, nz));
         }
 
-        /* Point Size ----------------------------- */
-        if (sd->u.s.pSize.lpData != NULL) {
 
-            float *ptrToCoords = (float *)(sd->u.s.pSize.lpData + (SkipnStrides * sd->u.s.pSize.dwStride));
-            ptSize = ptrToCoords[0];
+        /* Point Size ----------------------------- */
+        if (pSize != NULL) {
+            ptSize = * (float *)(pSize + (SkipnStrides * pSizeStrideSize));
             VTRACE(("ptSize=%f\n", ptSize));
-            FIXME("No support for ptSize yet\n");
+            /* FIXME: Only do this once, not for every itteration! */
+            TRACE("No support for ptSize yet\n");
+            /* Just do a glPointSize(ptSize)*/
         }
 
         /* Diffuse -------------------------------- */
-        if (sd->u.s.diffuse.lpData != NULL) {
-
-            DWORD *ptrToCoords = (DWORD *)(sd->u.s.diffuse.lpData + (SkipnStrides * sd->u.s.diffuse.dwStride));
-            diffuseColor = ptrToCoords[0];
+        if (diffuse != NULL) {
+            diffuseColor = *(DWORD *)(diffuse + (SkipnStrides * diffuseStrideSize));
             VTRACE(("diffuseColor=%lx\n", diffuseColor));
         }
 
         /* Specular  -------------------------------- */
-        if (sd->u.s.specular.lpData != NULL) {
-
-            DWORD *ptrToCoords = (DWORD *)(sd->u.s.specular.lpData + (SkipnStrides * sd->u.s.specular.dwStride));
-            specularColor = ptrToCoords[0];
+        if (specular != NULL) {
+            specularColor = *(DWORD *)(specular + (SkipnStrides * specularStrideSize));
             VTRACE(("specularColor=%lx\n", specularColor));
+
         }
 
         /* Texture coords --------------------------- */
         for (textureNo = 0; textureNo < GL_LIMITS(textures); ++textureNo) {
-
+            /* FIXME: , do this first, instead of every single call*/
             if (!GL_SUPPORT(ARB_MULTITEXTURE) && textureNo > 0) {
                 FIXME("Program using multiple concurrent textures which this opengl implementation doesn't support\n");
                 continue ;
@@ -1020,6 +1285,7 @@
             /* Query tex coords */
             if (This->stateBlock->textures[textureNo] != NULL) {
 
+                /* This kind of looking up can be done once, instead of thousnads of times*/
                 int    coordIdx = This->updateStateBlock->textureState[textureNo][D3DTSS_TEXCOORDINDEX];
                 float *ptrToCoords = (float *)(sd->u.s.texCoords[coordIdx].lpData + (SkipnStrides * sd->u.s.texCoords[coordIdx].dwStride));
                 float  s = 0.0, t = 0.0, r = 0.0, q = 0.0;
@@ -1035,6 +1301,24 @@
                     int coordsToUse = sd->u.s.texCoords[coordIdx].dwType + 1; /* 0 == D3DDECLTYPE_FLOAT1 etc */
 
                     /* The coords to supply depend completely on the fvf / vertex shader */
+
+
+
+                    /* FIXME: we need to adjust textures by 0x5 pixels in all directions because opengl uses cordners and d3d uses centers*/
+                    if(This->stateBlock->vertexDecl){
+                    /* It looks like vertex declarations can have the texture co-ordinates a weird was around (or some kind of wrapping's been set up!)*/
+
+
+                    switch (coordsToUse) {
+                    case 4: q = ptrToCoords[3]; /* drop through */
+                    case 3: r = ptrToCoords[2]; /* drop through */
+                    case 2: t = ptrToCoords[1]; /* drop through, vertexDeclarations seem to have transposed co-ords (x==1 y==0) */
+                    case 1: s = ptrToCoords[0];
+                      TRACE("Coords are q%f r%f t%f s%f\n", q ,r ,t ,s);
+
+
+                    }
+                    }else{
                     switch (coordsToUse) {
                     case 4: q = ptrToCoords[3]; /* drop through */
                     case 3: r = ptrToCoords[2]; /* drop through */
@@ -1042,12 +1326,18 @@
                     case 1: s = ptrToCoords[0]; 
                     }
 
+                    }
+
+
                     /* Projected is more 'fun' - Move the last coord to the 'q'
                           parameter (see comments under D3DTSS_TEXTURETRANSFORMFLAGS */
                     if ((This->updateStateBlock->textureState[textureNo][D3DTSS_TEXTURETRANSFORMFLAGS] != D3DTTFF_DISABLE) &&
                         (This->updateStateBlock->textureState[textureNo][D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED)) {
-
+                        FIXME("projected texture\n");
                         if (This->updateStateBlock->textureState[textureNo][D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED) {
+                            /* According to god.....
+                            all four floating point values must be written to the corresponding texture register. Each texture coordinate is divided by the last element before being passed to the rasterizer.
+                            */
                             switch (coordsToUse) {
                             case 0:  /* Drop Through */
                             case 1:
@@ -1072,9 +1362,16 @@
                         }
                     }
 
+                    /* TODO: replace with a texture matrix when the non-pow2 texture is created in device.c (this will choke on cube textures!!!) */
+                    /* Non-pow-two scaling, I should be able to do this via a texture transform?  */
+                    if(((IWineD3DSurfaceImpl *) ((IWineD3DTextureImpl *)This->stateBlock->textures[textureNo])->surfaces[0])->nonpow2){
+                        t *= ((IWineD3DSurfaceImpl *)((IWineD3DTextureImpl *)This->stateBlock->textures[textureNo])->surfaces[0])->pow2scalingFactorY;
+                        s *= ((IWineD3DSurfaceImpl *)((IWineD3DTextureImpl *)This->stateBlock->textures[textureNo])->surfaces[0])->pow2scalingFactorX;
+
+                    }
                     switch (coordsToUse) {   /* Supply the provided texture coords */
                     case D3DTTFF_COUNT1:
-                        VTRACE(("tex:%d, s=%f\n", textureNo, s));
+                        VTRACE(("glMultiTexCoord1f:%d, s=%f\n", textureNo, s));
                         if (GL_SUPPORT(ARB_MULTITEXTURE)) {
                             GLMULTITEXCOORD1F(textureNo, s);
                         } else {
@@ -1082,7 +1379,7 @@
                         }
                         break;
                     case D3DTTFF_COUNT2:
-                        VTRACE(("tex:%d, s=%f, t=%f\n", textureNo, s, t));
+                        VTRACE(("glMultiTexCoord2f:%d, s=%f, t=%f\n", textureNo, s, t));
                         if (GL_SUPPORT(ARB_MULTITEXTURE)) {
                             GLMULTITEXCOORD2F(textureNo, s, t);
                         } else {
@@ -1090,7 +1387,7 @@
                         }
                         break;
                     case D3DTTFF_COUNT3:
-                        VTRACE(("tex:%d, s=%f, t=%f, r=%f\n", textureNo, s, t, r));
+                        VTRACE(("glMultiTexCoord3f:%d, s=%f, t=%f, r=%f\n", textureNo, s, t, r));
                         if (GL_SUPPORT(ARB_MULTITEXTURE)) {
                             GLMULTITEXCOORD3F(textureNo, s, t, r);
                         } else {
@@ -1098,7 +1395,7 @@
                         }
                         break;
                     case D3DTTFF_COUNT4:
-                        VTRACE(("tex:%d, s=%f, t=%f, r=%f, q=%f\n", textureNo, s, t, r, q));
+                        VTRACE(("glMultiTexCoord4f:%d, s=%f, t=%f, r=%f, q=%f\n", textureNo, s, t, r, q));
                         if (GL_SUPPORT(ARB_MULTITEXTURE)) {
                             GLMULTITEXCOORD4F(textureNo, s, t, r, q);
                         } else {
@@ -1112,8 +1409,9 @@
             }
         } /* End of textures */
 
+
         /* Diffuse -------------------------------- */
-        if (sd->u.s.diffuse.lpData != NULL) {
+        if (diffuse != NULL) {
             glColor4ub((diffuseColor >> 16) & 0xFF,
                        (diffuseColor >>  8) & 0xFF,
                        (diffuseColor >>  0) & 0xFF,
@@ -1124,11 +1422,14 @@
                     ((diffuseColor >>  0) & 0xFF) / 255.0f, 
                     ((diffuseColor >> 24) & 0xFF) / 255.0f));
         } else {
-            if (vx_index == 0) glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+            if (vx_index == 0) {
+                glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+                VTRACE(("glColor4f: r,g,b,a=%f,%f,%f,%f\n", 1.0f, 1.0f, 1.0f, 1.0f));
+            }
         }
 
         /* Specular ------------------------------- */
-        if (sd->u.s.diffuse.lpData != NULL) {
+        if (specular != NULL) {
             VTRACE(("glSecondaryColor4ub: r,g,b=%f,%f,%f\n", 
                     ((specularColor >> 16) & 0xFF) / 255.0f, 
                     ((specularColor >>  8) & 0xFF) / 255.0f,
@@ -1145,6 +1446,7 @@
         } else {
             if (vx_index == 0) {
 	      if (GL_SUPPORT(EXT_SECONDARY_COLOR)) {
+		 VTRACE(("glSecondaryColor3fEXT: %d,%d,%d\n",0,0,0));
                 GL_EXTCALL(glSecondaryColor3fEXT)(0, 0, 0);
 	      } else {
 		/* Do not worry if specular colour missing and disable request */
@@ -1154,15 +1456,18 @@
         }
 
         /* Normal -------------------------------- */
-        if (sd->u.s.normal.lpData != NULL) {
+        if (normal != NULL) {
             VTRACE(("glNormal:nx,ny,nz=%f,%f,%f\n", nx,ny,nz));
             glNormal3f(nx, ny, nz);
         } else {
-            if (vx_index == 0) glNormal3f(0, 0, 1);
+            if (vx_index == 0) {
+                VTRACE(("glNormal:nx,ny,nz=%f,%f,%f\n", 0F,0F,1F));	
+                glNormal3f(0, 0, 1);
+	    }
         }
         
         /* Position -------------------------------- */
-        if (sd->u.s.position.lpData != NULL) {
+        if (position != NULL) {
             if (1.0f == rhw || ((rhw < 0.0001f) && (rhw > -0.0001f))) {
                 VTRACE(("Vertex: glVertex:x,y,z=%f,%f,%f\n", x,y,z));
                 glVertex3f(x, y, z);
@@ -1173,12 +1478,48 @@
             }
         }
 
+        if (blendWeights != NULL) {
+            if (GL_SUPPORT(ARB_VERTEX_BLEND)) {
+#if 0 /* TODO: blend support */
+                GL_EXTCALL(glWeightfvARB)(numBlends, (float *)bw);
+#endif
+            } else {
+            /* For a full software implementation do .... */
+            /* opengl translate the normal into eyespace using
+                              n-1
+              (nx' ny' nz') =  SUM w_i * (nx ny nz) Inv(Mu_i)
+                              i=0
+            where Mu_i is the upper leftmost 3x3 matrix taken from the
+              model-view for vertex unit i, w_i is the vertex's
+              associated weight for vertex unit i, and
+
+              and
+
+            "When vertex blending is enabled, the vertex's eye
+            coordinates are found as:
+
+                (xe)    n-1               (xo)
+                (ye)  =  SUM  w_i * M_i * (yo)
+                (ze)    i=0               (zo)
+                (we)                      (wo)
+
+            where M_i is the i'th model-view matrix, w_i is the
+            vertex's associated weight for vertex unit i,
+
+                and
+
+                n = ACTIVE_VERTEX_UNITS_ARB
+            "
+            */
+            }
+        }
+
         /* For non indexed mode, step onto next parts */
         if (idxData == NULL) {
-            SkipnStrides += 1;
+            SkipnStrides++;
         }
     }
-
+    VTRACE("glEnd\n");
     glEnd();
     checkGLcall("glEnd and previous calls");
 }
@@ -1405,71 +1746,51 @@
 }
 #endif
 
-/* Routine common to the draw primitive and draw indexed primitive routines */
-void drawPrimitive(IWineD3DDevice *iface,
-                    int PrimitiveType, long NumPrimitives,
 
-                    /* for Indexed: */
-                    long  StartVertexIndex,
-                    long  StartIdx,
-                    short idxSize,
-                    const void *idxData,
-                    int   minIndex) {
 
-    BOOL                          rc = FALSE;
-    DWORD                         fvf = 0;
+/* Routine common to the draw primitive and draw indexed primitive routines
+ I'm going to split this out because it's a bit of a mess at the moment (and broken)
+ */
+inline void drawPimitiveVertexShaderInitilize(IWineD3DDeviceImpl *This, IWineD3DVertexShader **vertex_shader, int *useHW){
 #if 0 /* TODO: vertex and pixel shaders */
-    IDirect3DVertexShaderImpl    *vertex_shader = NULL;
-    IDirect3DPixelShaderImpl     *pixel_shader = NULL;
-#endif
-    IWineD3DDeviceImpl           *This = (IWineD3DDeviceImpl *)iface;
-    unsigned int                  i;
-    BOOL                          useVertexShaderFunction = FALSE;
-    BOOL                          isLightingOn = FALSE;
-    Direct3DVertexStridedData     dataLocations;
-    int                           useHW = FALSE;
 
-    /* Work out what the FVF should look like */
-    rc = initializeFVF(iface, &fvf, &useVertexShaderFunction);
-    if (rc) return;
-
-    /* If we will be using a vertex shader, do some initialization for it */
-    if (useVertexShaderFunction) {
-#if 0 /* TODO: vertex and pixel shaders */
-        vertex_shader = VERTEX_SHADER(This->updateStateBlock->VertexShader);
-        memset(&vertex_shader->input, 0, sizeof(VSHADERINPUTDATA8));
+        *vertex_shader = VERTEX_SHADER(This->updateStateBlock->VertexShader);
+        memset(&(*vertex_shader)->input, 0, sizeof(VSHADERINPUTDATA0));
 
-    	useHW = (((vs_mode == VS_HW) && GL_SUPPORT(ARB_VERTEX_PROGRAM)) &&
+    	*useHW = (((vs_mode == VS_HW) && GL_SUPPORT(ARB_VERTEX_PROGRAM)) &&
                  This->devType != D3DDEVTYPE_REF &&
 	         !This->stateBlock->renderState[D3DRS_SOFTWAREVERTEXPROCESSING] &&
-		 vertex_shader->usage != D3DUSAGE_SOFTWAREPROCESSING);
+		(*vertex_shader)->usage != D3DUSAGE_SOFTWAREPROCESSING);
 
         /** init Constants */
         if (This->updateStateBlock->Changed.vertexShaderConstant) {
             TRACE_(d3d_shader)("vertex shader initializing constants\n");
-            IDirect3DVertexShaderImpl_SetConstantF(vertex_shader, 0, (CONST FLOAT*) &This->updateStateBlock->vertexShaderConstant[0], 96);
+            IDirect3DVertexShaderImpl_SetConstantF(*vertex_shader, 0, (CONST FLOAT*) &This->updateStateBlock->vertexShaderConstant[0], 96);
         }
+
 #endif /* TODO: vertex and pixel shaders */
+
     }
 
-    /* Ok, we will be updating the screen from here onwards so grab the lock */
-    ENTER_GL();
 
-#if 0 /* TODO: vertex and pixel shaders */
+inline void drawPrimitivePixelShaderCrap(IWineD3DDeviceImpl *This, IWineD3DPixelShader  **pixel_shader ){
+
+#if 0
+    int i;
     /* If we will be using a pixel, do some initialization for it */
-    if ((pixel_shader = PIXEL_SHADER(This->updateStateBlock->PixelShader))) {
+    if ((*pixel_shader = PIXEL_SHADER(This->updateStateBlock->PixelShader))) {
         TRACE("drawing with pixel shader handle %p\n", pixel_shader);
-        memset(&pixel_shader->input, 0, sizeof(PSHADERINPUTDATA8));
+        memset(&(*pixel_shader)->input, 0, sizeof(PSHADERINPUTDATA8));
 
-        GL_EXTCALL(glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, pixel_shader->prgId));
-        checkGLcall("glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, pixel_shader->prgId);");
+        GL_EXTCALL(glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, (*pixel_shader)->prgId));
+        checkGLcall("glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, (*pixel_shader)->prgId);");
         glEnable(GL_FRAGMENT_PROGRAM_ARB);
         checkGLcall("glEnable(GL_FRAGMENT_PROGRAM_ARB);");	
 
         /* init Constants */
         if (This->updateStateBlock->Changed.pixelShaderConstant) {
-            TRACE_(d3d_shader)("pixel shader initializing constants %p\n",pixel_shader);
-            IDirect3DPixelShaderImpl_SetConstantF(pixel_shader, 0, (CONST FLOAT*) &This->updateStateBlock->pixelShaderConstant[0], 8);
+            TRACE_(d3d_shader)("pixel shader initializing constants %p\n",*pixel_shader);
+            IDirect3DPixelShaderImpl_SetConstantF((*pixel_shader), 0, (CONST FLOAT*) &This->updateStateBlock->pixelShaderConstant[0], 8);/* FIXME: use a global define instead of [0], 8*/
         }
         /* Update the constants */
         for (i=0; i<D3D8_PSHADER_MAX_CONSTANTS; i++) {
@@ -1477,107 +1798,226 @@
             checkGLcall("glProgramEnvParameter4fvARB(GL_FRAGMENT_PROGRAM_ARB");
         }
     }
-#endif /* TODO: vertex and pixel shaders */
+#endif
+}
 
+/* This should be performed POST processing og FVF and vertexDecl*/
+BOOL inline  drawPrimitiveSetupTransformMatrices(IWineD3DDevice *iface, int useHW, DWORD fvf, BOOL useVertexShaderFunction){
+    int isLightingOn;
     /* Setup transform matrices and sort out */
     if (useHW) {
 	/* Lighting is not completely bypassed with ATI drivers although it should be. Mesa is ok from this respect...
 	   So make sure lighting is disabled. */
+
         isLightingOn = glIsEnabled(GL_LIGHTING);
         glDisable(GL_LIGHTING);
         checkGLcall("glDisable(GL_LIGHTING);");
         TRACE("Disabled lighting as no normals supplied, old state = %d\n", isLightingOn); 
-    } else
+    } else {
+	if(((IWineD3DDeviceImpl*)iface)->stateBlock->vertexDecl != NULL){
+
+        isLightingOn = primitiveInitState(iface, fvf & D3DFVF_XYZRHW, !(fvf & D3DFVF_NORMAL), useVertexShaderFunction);
+
+	}else{
         isLightingOn = primitiveInitState(iface, 
                                           fvf & D3DFVF_XYZRHW, 
                                           !(fvf & D3DFVF_NORMAL),
                                           useVertexShaderFunction);
+	}
+    }
 
-    /* Initialize all values to null */
-    if (useVertexShaderFunction == FALSE) {
-        memset(&dataLocations, 0x00, sizeof(dataLocations));
+    return isLightingOn;
+}
+
+void inline drawPrimitiveTraceDataLocations(Direct3DVertexStridedData *dataLocations,DWORD fvf){
 
-        /* Convert to strided data */
-        primitiveConvertToStridedData(iface, &dataLocations, StartVertexIndex); 
+    if((int) dataLocations ==  0x406ef5c4) FIXME("Bad conversion\n");
+    if((int) dataLocations ==  0x406ef588) FIXME("Bad conversion\n");
+    if((int) dataLocations ==  0x406efad4) FIXME("Bad conversion\n");
 
         /* Dump out what parts we have supplied */
         TRACE("Strided Data (from FVF/VS): %lx\n", fvf);
-        TRACE_STRIDED((&dataLocations), position);
-        TRACE_STRIDED((&dataLocations), blendWeights);
-        TRACE_STRIDED((&dataLocations), blendMatrixIndices);
-        TRACE_STRIDED((&dataLocations), normal);
-        TRACE_STRIDED((&dataLocations), pSize);
-        TRACE_STRIDED((&dataLocations), diffuse);
-        TRACE_STRIDED((&dataLocations), specular);
-        TRACE_STRIDED((&dataLocations), texCoords[0]);
-        TRACE_STRIDED((&dataLocations), texCoords[1]);
-        TRACE_STRIDED((&dataLocations), texCoords[2]);
-        TRACE_STRIDED((&dataLocations), texCoords[3]);
-        TRACE_STRIDED((&dataLocations), texCoords[4]);
-        TRACE_STRIDED((&dataLocations), texCoords[5]);
-        TRACE_STRIDED((&dataLocations), texCoords[6]);
-        TRACE_STRIDED((&dataLocations), texCoords[7]);
-    }
-
-    /* Now initialize the materials state */
-    init_materials(iface, (dataLocations.u.s.diffuse.lpData != NULL));
+    TRACE_STRIDED((dataLocations), position);
+    TRACE_STRIDED((dataLocations), blendWeights);
+    TRACE_STRIDED((dataLocations), blendMatrixIndices);
+    TRACE_STRIDED((dataLocations), normal);
+    TRACE_STRIDED((dataLocations), pSize);
+    TRACE_STRIDED((dataLocations), diffuse);
+    TRACE_STRIDED((dataLocations), specular);
+    TRACE_STRIDED((dataLocations), texCoords[0]);
+    TRACE_STRIDED((dataLocations), texCoords[1]);
+    TRACE_STRIDED((dataLocations), texCoords[2]);
+    TRACE_STRIDED((dataLocations), texCoords[3]);
+    TRACE_STRIDED((dataLocations), texCoords[4]);
+    TRACE_STRIDED((dataLocations), texCoords[5]);
+    TRACE_STRIDED((dataLocations), texCoords[6]);
+    TRACE_STRIDED((dataLocations), texCoords[7]);
+    return;
 
+}
 
+void inline drawPrimitiveUploadDirtyTextures(IWineD3DDeviceImpl* This){
+    int i;
     /* And re-upload any dirty textures */
     for (i=0; i<GL_LIMITS(textures); i++) {
-        
         if ((This->stateBlock->textures[i] != NULL) && 
             (IWineD3DBaseTexture_GetDirty(This->stateBlock->textures[i])))
         {
             /* Load up the texture now */
             IWineD3DTexture_PreLoad((IWineD3DTexture *) This->stateBlock->textures[i]);
-            /* TODO: Is this right, as its cast all texture types to texture8... checkme */
         }
     }
 
+}
+
+void inline  drawPrimitiveDrawStrided(IWineD3DDevice *iface, BOOL useVertexShaderFunction, int useHW, Direct3DVertexStridedData *dataLocations, int PrimitiveType, long NumPrimitives, const void *idxData, short idxSize, int minIndex, long StartIdx){
+    IWineD3DDeviceImpl *This = (IWineD3DDeviceImpl *)iface;
+
+
     /* Now draw the graphics to the screen */
     if  (useVertexShaderFunction) {
-
+                FIXME("line %d Vertex shaders\n", __LINE__);
         /* Ideally, we should have software FV and hardware VS, possibly
            depending on the device type?                                 */
 
         if (useHW) {
-            TRACE("Swap HW vertex shader\n");
+            FIXME("Swap HW vertex shader\n");
 #if 0 /* TODO: vertex and pixel shaders */
-            drawStridedHardwareVS(iface, &dataLocations, PrimitiveType, NumPrimitives, 
+            drawStridedHardwareVS(iface, dataLocations, PrimitiveType, NumPrimitives,
                         idxData, idxSize, minIndex, StartIdx);            
 #endif
 	} else {
             /* We will have to use the very, very slow emulation layer */
-            TRACE("Swap SW vertex shader\n");
+            FIXME("Swap SW vertex shader\n");
 #if 0 /* TODO: vertex and pixel shaders */
-	    drawStridedSoftwareVS(iface, &dataLocations, PrimitiveType, NumPrimitives, 
+            drawStridedSoftwareVS(iface, dataLocations, PrimitiveType, NumPrimitives,
                         idxData, idxSize, minIndex, StartIdx);            
 #endif
         }
 
-    } else if ((dataLocations.u.s.pSize.lpData           != NULL) 
-               || (dataLocations.u.s.diffuse.lpData      != NULL) 
-	       /*|| (dataLocations.u.s.blendWeights.lpData != NULL)*/) {
-
-        /* Fixme, Ideally, only use the per-vertex code for software HAL 
-           but until opengl supports all the functions returned to setup 
-           vertex arrays, we need to drop down to the slow mechanism for  
-           certain functions                                              */
+    } else
+    {
+        /* FIXME: change non-power2 textures to use a texture transform matrix
+        make this check 'cheeper' by flagging nonpower2 textures in setTexture. */
+        BOOL nonpower2 = FALSE;
+        int textureNo;
+        for (textureNo = 0 ; textureNo < 8  ;textureNo++){
+            if(This->stateBlock->textures[textureNo] != NULL){
+                if(((IWineD3DSurfaceImpl *) ((IWineD3DTextureImpl *)This->stateBlock->textures[textureNo])->surfaces[0])->nonpow2){
+                    nonpower2 = TRUE;
+                    break;
+
+                }
+            }
+        }
 
-        /* We will have to use the slow version of GL per vertex setup */
-        drawStridedSlow(iface, &dataLocations, PrimitiveType, NumPrimitives, 
+        if(nonpower2){
+            /* each texture coord gets rescaled for non-power-2, so we can't use hardware drawing
+               TODO: use a texture transform martix so that ahardware cna be used to draw nom-power-2 textures
+               */
+            drawStridedSlow(iface, dataLocations, PrimitiveType, NumPrimitives,
                         idxData, idxSize, minIndex, StartIdx); 
+        }else{
+        /* We can use the fast version of GL pointers
+            NOTE: ATI-drivers < 8.10.19 have problems with this method */
+            if(!drawStridedFast(iface, dataLocations, PrimitiveType, NumPrimitives,
+                    idxData, idxSize, minIndex, StartIdx)){
+            drawStridedSlow(iface, dataLocations, PrimitiveType, NumPrimitives,
+                    idxData, idxSize, minIndex, StartIdx);
+
+            }
+
+        }
+    }
+
+
+}
+
+void drawPrimitive(IWineD3DDevice *iface,
+                    int PrimitiveType, long NumPrimitives,
+
+                    /* for Indexed: */
+                    long  StartVertexIndex,
+                    long  StartIdx,
+                    short idxSize,
+                    const void *idxData,
+                    int   minIndex) {
+
+    BOOL                          rc = FALSE;
+    DWORD			  fvf =0;
+#if 0 /* TODO: vertex and pixel shaders */
+    IDirect3DVertexShaderImpl    *vertex_shader = NULL;
+    IDirect3DPixelShaderImpl     *pixel_shader = NULL;
+#endif
+    IWineD3DDeviceImpl           *This = (IWineD3DDeviceImpl *)iface;
+    BOOL                          useVertexShaderFunction = FALSE; /* needs to be moved to flags so
+                                                                    that extensations can easly be added*/
+    BOOL                          isLightingOn = FALSE;
+    Direct3DVertexStridedData     dataLocations;
+    int                           useHW = FALSE;
+
+
+#if 0
+    /* If we will be using a vertex shader, do some initialization for it */
+    if (useVertexShaderFunction) {
+        drawPimitiveVertexShaderInitilize(This, vertex_shader, useHW);
+    }
+#endif
+    if(This->stateBlock->vertexDecl == NULL){
+        /* This needs to be a bit differnt for vertexDecl's
+	  Work out what the FVF should look like */	
+	   rc = initializeFVF(iface, &fvf, &useVertexShaderFunction);
+    	if (rc) return;
 
     } else {
+                TRACE("using vertex declaration\n");
+    }
+    /* Ok, we will be updating the screen from here onwards so grab the lock */
+    ENTER_GL();
 
-        /* We can use the fast version of GL pointers */
-        drawStridedFast(iface, &dataLocations, PrimitiveType, NumPrimitives, 
-                        idxData, idxSize, minIndex, StartIdx);
+#if 0 /* TODO: vertex and pixel shaders */
+    drawPrimitivePixelShaderCrap(This, &pixel_shader );
+#endif /* TODO: vertex and pixel shaders */
+
+
+
+
+    /* Initialize all values to null */
+    if (useVertexShaderFunction == FALSE) {
+        memset(&dataLocations, 0x00, sizeof(dataLocations));
+
+        /* Convert to strided data, this isn't working properly at the moment,
+         probably because DirectX not supports data split across streams */
+         if(This->stateBlock->vertexDecl != NULL){
+/*            TRACE("================ Vertex Declaration ++ ===================\n");*/
+            primitiveDeclarationConvertToStridedData(iface, &dataLocations, StartVertexIndex, &fvf);
+         }else{
+/*            TRACE("================ Vertex Declaration -- ===================\n");*/
+            primitiveConvertToStridedData(iface, &dataLocations, StartVertexIndex);
+    }
+        /* write out some debug information*/
+        drawPrimitiveTraceDataLocations(&dataLocations, fvf);
+    }else{
+                FIXME("line %d Vertex shaders\n", __LINE__);
     }
 
+    /* This must happen after setting up the data, because we don't have a fvf*/
+    isLightingOn = drawPrimitiveSetupTransformMatrices(iface, useHW, fvf, useVertexShaderFunction);
+
+
+    /* Now initialize the materials state */
+    TRACE("init_materials\n");
+    init_materials(iface, (dataLocations.u.s.diffuse.lpData != NULL));
+
+    drawPrimitiveUploadDirtyTextures(This);
+
+    drawPrimitiveDrawStrided(iface, useVertexShaderFunction, useHW, &dataLocations, PrimitiveType, NumPrimitives, idxData, idxSize, minIndex, StartIdx);
+
+
+
     /* If vertex shaders or no normals, restore previous lighting state */
     if (useVertexShaderFunction || !(fvf & D3DFVF_NORMAL)) {
+
         if (isLightingOn) glEnable(GL_LIGHTING);
         else glDisable(GL_LIGHTING);
         TRACE("Restored lighting to original state\n");
@@ -1600,35 +2040,37 @@
     LEAVE_GL();
     TRACE("Done all gl drawing\n");
 
-    /* Diagnostics */
-#if defined(SHOW_FRAME_MAKEUP)
+
+    /* Diagnostics (may be an idea to save out the strided data too so that the whole draw can be recreated) */
+#ifdef SHOW_FRAME_MAKEUP
     {
         if (isDumpingFrames) {
             D3DLOCKED_RECT r;
             char buffer[80];
-            IDirect3DSurface8Impl_LockRect((LPDIRECT3DSURFACE8) This->renderTarget, &r, NULL, D3DLOCK_READONLY);
+            IWineD3DSurface_LockRect((IWineD3DSurface*) This->renderTarget, &r, NULL, D3DLOCK_READONLY);
             sprintf(buffer, "/tmp/backbuffer_%ld.ppm", primCounter);
             TRACE("Saving screenshot %s\n", buffer);
-            IDirect3DSurface8Impl_SaveSnapshot((LPDIRECT3DSURFACE8) This->renderTarget, buffer);
-            IDirect3DSurface8Impl_UnlockRect((LPDIRECT3DSURFACE8) This->renderTarget);
+            IWineD3DSurface_SaveSnapshot((IWineD3DSurface*) This->renderTarget, buffer);
+            IWineD3DSurface_UnlockRect((IWineD3DSurface*) This->renderTarget);
 
-#if defined(SHOW_TEXTURE_MAKEUP)
+#ifdef SHOW_TEXTURE_MAKEUP
            {
-            LPDIRECT3DSURFACE8 pSur;
+            IWineD3DSurface* pSur;
             int textureNo;
             for (textureNo = 0; textureNo < GL_LIMITS(textures); ++textureNo) {
                 if (This->stateBlock->textures[textureNo] != NULL) {
                     sprintf(buffer, "/tmp/texture_%ld_%d.ppm", primCounter, textureNo);
-                    TRACE("Saving texture %s (Format:%s)\n", buffer, debug_d3dformat(((IDirect3DBaseTexture8Impl *)This->stateBlock->textures[textureNo])->format));
-                    IDirect3DTexture8Impl_GetSurfaceLevel((LPDIRECT3DTEXTURE8) This->stateBlock->textures[textureNo], 0, &pSur);
-                    IDirect3DSurface8Impl_SaveSnapshot(pSur, buffer);
-                    IDirect3DSurface8Impl_Release(pSur);
+                    TRACE("Saving texture %s (Format:%s)\n", buffer, debug_d3dformat(((IWineD3DBaseTextureImpl *)This->stateBlock->textures[textureNo])->format));
+                    IWineD3DTexture_GetSurfaceLevel((IWineD3DTexture*) This->stateBlock->textures[textureNo], 0, &pSur);
+                    IWineD3DSurface_SaveSnapshot(pSur, buffer);
+                    IWineD3DSurface_Release(pSur);
                 }
             }
            }
 #endif
-           primCounter = primCounter + 1; 
+           primCounter++;
         }
     }
 #endif
+
 }
diff -urN wine.20050419/dlls/wined3d/listfuncs.c wine.20050419.dx9/dlls/wined3d/listfuncs.c
--- wine.20050419/dlls/wined3d/listfuncs.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/listfuncs.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,210 @@
+/*
+ * IListOperator and IListStore implementations
+ *
+ * Copyright 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+ /* NOTE: This code is only here if/until it gets moved to a more central part of wine */
+
+ /** ********************************
+  Basic usage notes
+
+  IListOperator and IListStore provide optionally thread safe
+   asynchronious access to data stored in a linked list.
+
+   To use.
+   
+
+   Create a threadSafe store with a standalone critical section
+   
+   IListStore* myDataStore;   
+   CreateListStore(  TRUE,  NULL, &myDataStore);
+   
+
+   Create a threadSafe store with a shared critical section
+
+   IListStore* myDataStore1;
+   IListStore* myDataStore2;
+   BOOL threadSafe = TRUE;
+   CRITICALSECTION sharedCriticalSection;
+   CreateCriticalSection(&sharedCriticalSection);
+
+   CreateListStore( TRUE, &sharedCriticalSection, &myDataStore1);
+   CreateListStore( TRUE, &sharedCriticalSection, &myDataStore2);
+
+   Using a shared critical section cuts down on the number of critical sections, and may be a better locking policy for your calss.
+
+
+   Create a non-thread safe store
+
+   IListStore* myDataStore;
+   CreateListStore( FALSE,  NULL, &myDataStore);
+
+
+   Using the data...
+   To access, add and remove data from the store you must use IListOperator,
+   this will insure that all data access obays the threading method requested..
+
+
+   asynchrionous thread safe access is provided by reference counting and invalidating list members.
+   The operators garantee that the data was valid when requested,
+   and won't invalidate the data until all opertors using the data are no longer looking at it.
+
+   so you can be sure that the data pointer to by the result of a next statement will be
+   valid until you issue the next 'next' statement, you destroy the iterator or you call release of the data
+   even if another thread can release while you still hold a pointer to the data.
+   ISStillValid sill erturn false if the data has been released by another thread.
+
+   The contents of the data is not gaurenteed,
+   you will need to use your own critical sections or referecning mechinisms to enssure that.
+   (see tests for examples)
+
+   
+ ** ************************************************************************************/
+
+HRESULT WINAPI IListStoreImpl_QueryInterface(IListStore* iface,){
+    IListStoreImpl *This = (IListStoreImpl *)iface;
+    FIXME("This shouldn't be called, no GUIDS generated yet. \n");
+    return E_NOINTERFACE;
+
+}
+
+ULONG WINAPI IListStoreImpl_AddRef(IListStore* iface){
+    IListStoreImpl *This = (IListStoreImpl *)iface;
+
+}
+
+ULONG WINAPI IListStoreImpl_Release(IListStore* iface){
+    IListStoreImpl *This = (IListStoreImpl *)iface;
+
+}
+
+
+HRESULT WINAPI IListStoreImpl_CreateListOperator(IListStore* iface, IListOperator** listOperator){
+    IListStoreImpl *This = (IListStoreImpl *)iface;
+
+}
+
+HRESULT WINAPI IListOperatorImpl_QueryInterface(IListOperator* iface,  REFIID riid, LPVOID *ppobj){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    FIXME("This shouldn't be called, no GUIDS generated yet. \n");
+    return E_NOINTERFACE;
+}
+
+ULONG WINAPI IListOperatorImpl_AddRef(IListOperator* iface){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+
+}
+
+ULONG WINAPI IListOperatorImpl_Release(IListOperator* iface){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    if(This->store->criticalSection != NULL)
+        EnterCriticalSection(This->criticalSection);
+
+    IListItem_Release(currentItem);
+    This->currentItem = NULL;
+    if(This->store->criticalSection != NULL)
+        LeaveCriticalSection(This->criticalSection);
+
+    IListStore_Release(This->list);
+    /* The cricital section may be invalid after the list has been released. */
+    HeapFree(GetProcessHeap() ,0 , This);
+    
+
+}
+HRESULT WINAPI IListOperatorImpl_Remove(IListOperator* iface, void* data){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    /* This invalidates and the releases */
+
+}
+unsigned int WINAPI IListOperatorImpl_Add(IListOperator* iface, void* data){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+
+}
+
+void * WINAPI IListOperatorImpl_Next(IListOperator* iface){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    balh *listItem = NULL;
+    
+    if(This->currentItem != NULL){        
+        if(This->store->criticalSection != NULL)
+            EnterCriticalSection(This->criticalSection);
+            
+            
+        if( 0 == IListItem_Release(currentItem))){
+        /* what's the cleanest way of doing this... */
+                    This->currentItem = This->currentItem->next
+                    HeapFree(GetProcessHeap(), 0, 
+        }else{
+            This->currentItem = This->currentItem->next
+        }
+        while(This->currentItem != NULL && This->currentItem->valid == false)
+            This->currentItem = This->currentItem->next;
+            
+        IListItem_AddRef(This->currentItem);
+        
+        listItem = This->currentItem;
+        
+        if(This->store->criticalSection != NULL)
+            LeaveCriticalSection(This->criticalSection);
+    }
+    
+    return listItem;
+
+}
+unsigned int WINAPI IListOperatorImpl_Find(IListOperator* iface, void* data){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+
+        IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    unsigned int count = 0;
+    balh *listItem;
+    if(This->store->criticalSection != NULL)    
+        EnterCriticalSection(This->criticalSection);
+    
+    for(listItem = This->store->first; (listItem->data != data) && (listItem->valid == TRUE); listItem = listItem->next)
+        count++
+        
+    if(This->store->criticalSection != NULL)
+        LeaveCriticalSection(This->criticalSection);
+            
+    return if(listItem == NULL)?-1:count;    
+}
+
+unsigned int WINAPI IListOperatorImpl_Count(IListOperator* iface){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+    unsigned int count = 0;
+    balh *listItem;
+    if(This->store->criticalSection != NULL)    
+        EnterCriticalSection(This->criticalSection);
+    
+    for(listItem = This->store->first; listItem != NULL; listItem = listItem->next)
+        if(listItem->valid == TRUE) count++
+    if(This->store->criticalSection != NULL)
+        LeaveCriticalSection(This->criticalSection);
+    
+    return count;
+}
+
+HRESULT WINAPI IListOperatorImpl_IsStillValid(IListOperator* iface, void* data){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+
+}
+HRESULT WINAPI IListOperatorImpl_Get(IListOperator* iface, unsigned int pos, void **data){
+    IListOperatorImpl *This = (IListOperatorImpl *)iface;
+
+}
diff -urN wine.20050419/dlls/wined3d/pixelshader.c wine.20050419.dx9/dlls/wined3d/pixelshader.c
--- wine.20050419/dlls/wined3d/pixelshader.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/pixelshader.c	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,122 @@
+/*
+ * shaders implementation
+ *
+ * Copyright 2005      Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+
+#include <math.h>
+
+#include "wined3d_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d_shader);
+
+
+/* *******************************************
+   IWineD3DPixelShader IUnknown parts follow
+   ******************************************* */
+HRESULT WINAPI IWineD3DPixelShaderImpl_QueryInterface(IWineD3DPixelShader *iface, REFIID riid, LPVOID *ppobj)
+{
+    IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)iface;
+    TRACE("(%p)->(%s,%p)\n",This,debugstr_guid(riid),ppobj);    
+    if (IsEqualGUID(riid, &IID_IUnknown)     
+        || IsEqualGUID(riid, &IID_IWineD3DPixelShader)) {
+        IUnknown_AddRef(iface);
+        *ppobj = This;
+        return D3D_OK;
+    }        
+    return E_NOINTERFACE;
+}
+
+ULONG WINAPI IWineD3DPixelShaderImpl_AddRef(IWineD3DPixelShader *iface) {
+    IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)iface;
+    TRACE("(%p) : AddRef increasing from %ld\n", This, This->ref);    
+    return InterlockedIncrement(&This->ref);
+}
+
+ULONG WINAPI IWineD3DPixelShaderImpl_Release(IWineD3DPixelShader *iface) {
+    IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)iface;
+    ULONG ref;
+    TRACE("(%p) : Releasing from %ld\n", This, This->ref);
+    ref = InterlockedDecrement(&This->ref);
+    if (ref == 0) {        
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+/* *******************************************
+   IWineD3DPixelShader IWineD3DPixelShader parts follow
+   ******************************************* */
+
+HRESULT WINAPI IWineD3DPixelShaderImpl_GetParent(IWineD3DPixelShader *iface, IUnknown** parent){
+    IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)iface;
+    
+    *parent= (IUnknown*) parent;
+    IUnknown_AddRef(*parent);
+    TRACE("(%p) : returning %p\n", This, *parent);
+    return D3D_OK;
+}
+   
+HRESULT WINAPI IWineD3DPixelShaderImpl_GetDevice(IWineD3DPixelShader* iface, IWineD3DDevice **pDevice){
+    IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)iface;
+    IWineD3DDevice_AddRef((IWineD3DDevice *)This->wineD3DDevice);
+    *pDevice = (IWineD3DDevice *)This->wineD3DDevice;
+    TRACE("(%p) returning %p\n", This, *pDevice);   
+    return D3D_OK;
+}
+
+
+HRESULT WINAPI IWineD3DPixelShaderImpl_GetFunction(IWineD3DPixelShader* impl, VOID* pData, UINT* pSizeOfData) {
+  IWineD3DPixelShaderImpl *This = (IWineD3DPixelShaderImpl *)impl;
+  FIXME("(%p) : pData(%p), pSizeOfData(%p)\n", This, pData, pSizeOfData);
+
+  if (NULL == pData) {
+    *pSizeOfData = This->functionLength;
+    return D3D_OK;
+  }
+  if (*pSizeOfData < This->functionLength) {
+    *pSizeOfData = This->functionLength;
+    return D3DERR_MOREDATA;
+  }
+  if (NULL == This->function) { /* no function defined */
+    TRACE("(%p) : GetFunction no User Function defined using NULL to %p\n", This, pData);
+    (*(DWORD **) pData) = NULL;
+  } else {
+    if(This->functionLength == 0){
+    
+    }
+    TRACE("(%p) : GetFunction copying to %p\n", This, pData);
+    memcpy(pData, This->function, This->functionLength);
+  }
+  return D3D_OK;
+}
+
+
+
+IWineD3DPixelShaderVtbl IWineD3DPixelShader_Vtbl =
+{
+    /*** IUnknown methods ***/
+    IWineD3DPixelShaderImpl_QueryInterface,
+    IWineD3DPixelShaderImpl_AddRef,
+    IWineD3DPixelShaderImpl_Release,
+    /*** IWineD3DPixelShader methods ***/
+    IWineD3DPixelShaderImpl_GetParent,
+    IWineD3DPixelShaderImpl_GetDevice,
+    IWineD3DPixelShaderImpl_GetFunction
+};
diff -urN wine.20050419/dlls/wined3d/stateblock.c wine.20050419.dx9/dlls/wined3d/stateblock.c
--- wine.20050419/dlls/wined3d/stateblock.c	2005-03-03 06:57:15.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/stateblock.c	2005-04-20 01:52:56.000000000 -0600
@@ -27,7 +27,7 @@
 #define GLINFO_LOCATION ((IWineD3DImpl *)(((IWineD3DDeviceImpl *)This->wineD3DDevice)->wineD3D))->gl_info
 
 /**********************************************************
- * IWineD3DStateBlockImpl IUnknown parts follows
+ * IUnknown parts follows
  **********************************************************/
 HRESULT WINAPI IWineD3DStateBlockImpl_QueryInterface(IWineD3DStateBlock *iface,REFIID riid,LPVOID *ppobj)
 {
@@ -57,15 +57,12 @@
     TRACE("(%p) : Releasing from %ld\n", This, refCount + 1);
 
     if (!refCount) {
-        IWineD3DDevice_Release((IWineD3DDevice *)This->wineD3DDevice);
+        /* The applicaion is responsible for making sure the texture references are cleared down */
         HeapFree(GetProcessHeap(), 0, This);
     }
     return refCount;
 }
 
-/**********************************************************
- * IWineD3DStateBlockImpl parts follows
- **********************************************************/
 HRESULT WINAPI IWineD3DStateBlockImpl_GetParent(IWineD3DStateBlock *iface, IUnknown **pParent) {
     IWineD3DStateBlockImpl *This = (IWineD3DStateBlockImpl *)iface;
     IUnknown_AddRef(This->parent);
@@ -76,10 +73,12 @@
 HRESULT WINAPI IWineD3DStateBlockImpl_InitStartupStateBlock(IWineD3DStateBlock* iface) {
     IWineD3DStateBlockImpl *This = (IWineD3DStateBlockImpl *)iface;
     IWineD3DDeviceImpl     *ThisDevice = (IWineD3DDeviceImpl *)(This->wineD3DDevice);
+    #if 0 /*TODO: d3d8*/
     union {
         D3DLINEPATTERN lp;
         DWORD d;
     } lp;
+    #endif
     union {
         float f;
         DWORD d;
@@ -89,7 +88,7 @@
     /* Note this may have a large overhead but it should only be executed
        once, in order to initialize the complete state of the device and 
        all opengl equivalents                                            */
-    TRACE("-----------------------> Setting up device defaults...\n");
+    TRACE("(%p) -----------------------> Setting up device defaults... %p \n",This,This->wineD3DDevice);
     This->blockType = D3DSBT_ALL;
 
     /* FIXME: Set some of the defaults for lights, transforms etc */
@@ -98,47 +97,52 @@
     for (i = 0; i < 256; ++i) {
       memcpy(&This->transforms[D3DTS_WORLDMATRIX(i)], &identity, sizeof(identity));
     }
- 
+    TRACE("Render states\n");
     /* Render states: */
-    if (ThisDevice->presentParms.EnableAutoDepthStencil) {
-       IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZENABLE, D3DZB_TRUE);
+    if (ThisDevice->depthStencilBuffer != NULL) {
+       IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ZENABLE, D3DZB_TRUE);
     } else {
        IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZENABLE, D3DZB_FALSE);
     }
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FILLMODE, D3DFILL_SOLID);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_SHADEMODE, D3DSHADE_GOURAUD);
-
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FILLMODE, D3DFILL_SOLID);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
+    #if 0 /*FIXME: d3d8*/
     lp.lp.wRepeatFactor = 0; lp.lp.wLinePattern = 0;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_LINEPATTERN, lp.d);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZWRITEENABLE, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ALPHATESTENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_LASTPIXEL, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_SRCBLEND, D3DBLEND_ONE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_DESTBLEND, D3DBLEND_ZERO);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_CULLMODE, D3DCULL_CCW);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZFUNC, D3DCMP_LESSEQUAL);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ALPHAREF, 0xff); /*??*/
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_DITHERENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ALPHABLENDENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_SPECULARENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZVISIBLE, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGCOLOR, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGTABLEMODE, D3DFOG_NONE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_LINEPATTERN, lp.d);
+    #endif
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ZWRITEENABLE, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ALPHATESTENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_LASTPIXEL, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_SRCBLEND, D3DBLEND_ONE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_DESTBLEND, D3DBLEND_ZERO);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_CULLMODE, D3DCULL_CCW);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ALPHAREF, 0xff); /*??*/
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_DITHERENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ALPHABLENDENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FOGENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_SPECULARENABLE, FALSE);
+    #if 0 /*FIXME: d3d8*/
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ZVISIBLE, 0);
+    #endif
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FOGCOLOR, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FOGTABLEMODE, D3DFOG_NONE);
     tmpfloat.f = 0.0f;
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGSTART, tmpfloat.d);
     tmpfloat.f = 1.0f;
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGEND, tmpfloat.d);
     tmpfloat.f = 1.0f;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGDENSITY, tmpfloat.d);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_EDGEANTIALIAS, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_ZBIAS, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_RANGEFOGENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FOGDENSITY, tmpfloat.d);
+    #if 0 /*FIXME: d3d8*/
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_EDGEANTIALIAS, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_ZBIAS, 0);
+    #endif
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_RANGEFOGENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
 
     /* Setting stencil func also uses values for stencil ref/mask, so manually set defaults
      * so only a single call performed (and ensure defaults initialized before making that call)    
@@ -146,58 +150,62 @@
      * IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILREF, 0);
      * IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILMASK, 0xFFFFFFFF);
      */
-    This->renderState[WINED3DRS_STENCILREF] = 0;
-    This->renderState[WINED3DRS_STENCILMASK] = 0xFFFFFFFF;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILFUNC, D3DCMP_ALWAYS);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_STENCILWRITEMASK, 0xFFFFFFFF);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_TEXTUREFACTOR, 0xFFFFFFFF);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP0, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP1, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP2, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP3, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP4, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP5, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP6, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_WRAP7, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_CLIPPING, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_LIGHTING, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_AMBIENT, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_FOGVERTEXMODE, D3DFOG_NONE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_COLORVERTEX, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_LOCALVIEWER, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_NORMALIZENORMALS, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_VERTEXBLEND, D3DVBF_DISABLE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_CLIPPLANEENABLE, 0);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_SOFTWAREVERTEXPROCESSING, FALSE);
+    This->renderState[D3DRS_STENCILREF] = 0;
+    This->renderState[D3DRS_STENCILMASK] = 0xFFFFFFFF;
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_STENCILWRITEMASK, 0xFFFFFFFF);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_TEXTUREFACTOR, 0xFFFFFFFF);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP0, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP1, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP2, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP3, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP4, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP5, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP6, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_WRAP7, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_CLIPPING, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_LIGHTING, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_AMBIENT, 0);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_FOGVERTEXMODE, D3DFOG_NONE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_COLORVERTEX, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_LOCALVIEWER, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_NORMALIZENORMALS, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_CLIPPLANEENABLE, 0);
+    #if 0 /*FIXME: d3d8*/
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_SOFTWAREVERTEXPROCESSING, FALSE);
+    #endif
     tmpfloat.f = 1.0f;
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSIZE, tmpfloat.d);
     tmpfloat.f = 0.0f;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSIZE_MIN, tmpfloat.d);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSPRITEENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSCALEENABLE, FALSE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSCALE_A, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSCALE_B, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSCALE_C, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_MULTISAMPLEANTIALIAS, TRUE);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_MULTISAMPLEMASK, 0xFFFFFFFF);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_PATCHEDGESTYLE, D3DPATCHEDGE_DISCRETE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSIZE_MIN, tmpfloat.d);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSPRITEENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSCALEENABLE, FALSE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSCALE_A, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSCALE_B, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POINTSCALE_C, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_MULTISAMPLEANTIALIAS, TRUE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_MULTISAMPLEMASK, 0xFFFFFFFF);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_PATCHEDGESTYLE, D3DPATCHEDGE_DISCRETE);
+    #if 0 /*FIXME: d3d8*/
     tmpfloat.f = 1.0f;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_PATCHSEGMENTS, tmpfloat.d);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_DEBUGMONITORTOKEN, D3DDMT_DISABLE);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_PATCHSEGMENTS, tmpfloat.d);
+    #endif
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_DEBUGMONITORTOKEN, D3DDMT_DISABLE);
     tmpfloat.f = 64.0f;
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POINTSIZE_MAX, tmpfloat.d);
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
     IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_COLORWRITEENABLE, 0x0000000F);
     tmpfloat.f = 0.0f;
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_TWEENFACTOR, tmpfloat.d);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_BLENDOP, D3DBLENDOP_ADD);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_POSITIONORDER, WINED3DDEGREE_CUBIC);
-    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, WINED3DRS_NORMALORDER, WINED3DDEGREE_LINEAR);
-
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_TWEENFACTOR, tmpfloat.d);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_BLENDOP, D3DBLENDOP_ADD);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_POSITIONDEGREE, D3DDEGREE_CUBIC);
+    IWineD3DDevice_SetRenderState((IWineD3DDevice *)This->wineD3DDevice, D3DRS_NORMALDEGREE, D3DDEGREE_LINEAR);
+    TRACE("clipping status\n");
     /** clipping status */
     This->clip_status.ClipUnion = 0;
     This->clip_status.ClipIntersection = 0xFFFFFFFF;
@@ -217,15 +225,6 @@
         This->textureState[i][D3DTSS_BUMPENVMAT10          ] = (DWORD) 0.0;
         This->textureState[i][D3DTSS_BUMPENVMAT11          ] = (DWORD) 0.0;
         This->textureState[i][D3DTSS_TEXCOORDINDEX         ] = i;
-        This->textureState[i][D3DTSS_ADDRESSU              ] = D3DTADDRESS_WRAP;
-        This->textureState[i][D3DTSS_ADDRESSV              ] = D3DTADDRESS_WRAP;
-        This->textureState[i][D3DTSS_BORDERCOLOR           ] = 0x00;
-        This->textureState[i][D3DTSS_MAGFILTER             ] = D3DTEXF_POINT;
-        This->textureState[i][D3DTSS_MINFILTER             ] = D3DTEXF_POINT;
-        This->textureState[i][D3DTSS_MIPFILTER             ] = D3DTEXF_NONE;
-        This->textureState[i][D3DTSS_MIPMAPLODBIAS         ] = 0;
-        This->textureState[i][D3DTSS_MAXMIPLEVEL           ] = 0;
-        This->textureState[i][D3DTSS_MAXANISOTROPY         ] = 1;
         This->textureState[i][D3DTSS_BUMPENVLSCALE         ] = (DWORD) 0.0;
         This->textureState[i][D3DTSS_BUMPENVLOFFSET        ] = (DWORD) 0.0;
         This->textureState[i][D3DTSS_TEXTURETRANSFORMFLAGS ] = D3DTTFF_DISABLE;
@@ -233,6 +232,22 @@
         This->textureState[i][D3DTSS_COLORARG0             ] = D3DTA_CURRENT;
         This->textureState[i][D3DTSS_ALPHAARG0             ] = D3DTA_CURRENT;
         This->textureState[i][D3DTSS_RESULTARG             ] = D3DTA_CURRENT;
+        This->textureState[i][D3DRS_LASTPIXEL              ] = TRUE;
+        
+    }
+    /* Sampler states*/
+    for ( i = 0 ; i< 16 /* MAX_SAMPLERS*/; i++){
+        TRACE("Setting up default samplers states for sampler %d\n", i);	
+        This->samplerState[i][D3DSAMP_ADDRESSU             ] = D3DTADDRESS_WRAP;
+        This->samplerState[i][D3DSAMP_ADDRESSV             ] = D3DTADDRESS_WRAP;
+        This->samplerState[i][D3DSAMP_BORDERCOLOR          ] = 0x00;
+        This->samplerState[i][D3DSAMP_MAGFILTER            ] = D3DTEXF_POINT;
+        This->samplerState[i][D3DSAMP_MINFILTER            ] = D3DTEXF_POINT;
+        This->samplerState[i][D3DSAMP_MIPFILTER            ] = D3DTEXF_NONE;
+        This->samplerState[i][D3DSAMP_MIPMAPLODBIAS        ] = 0;
+        This->samplerState[i][D3DSAMP_MAXMIPLEVEL          ] = 0;
+        This->samplerState[i][D3DSAMP_MAXANISOTROPY        ] = 1;
+
     }
 
     /* Under DirectX you can have texture stage operations even if no texture is
@@ -293,6 +308,390 @@
     return D3D_OK;
 }
 
+
+HRESULT WINAPI IWineD3DStateBlockImpl_Capture(IWineD3DStateBlock *iface){
+
+    IWineD3DStateBlockImpl *This       = (IWineD3DStateBlockImpl *)iface;
+    IWineD3DDevice*        pDevice     = (IWineD3DDevice*)This->wineD3DDevice;
+    IWineD3DDeviceImpl*    pDeviceImpl = This->wineD3DDevice;
+
+
+
+    TRACE("(%p) : Updating state block %p ------------------v \n", pDeviceImpl, This);
+
+    /* If not recorded, then update can just recapture */
+    if (/*TODO: 'magic' statetype, replace with BOOL This->blockType == D3DSBT_RECORDED  */ 0) {
+        IWineD3DStateBlockImpl* tmpBlock;
+        PLIGHTINFOEL *tmp = This->lights;
+	
+	/*FIXME: I would have thought that CreateStateBlock should call capture... not the other way around!*/
+        IWineD3DDevice_CreateStateBlock(pDevice, This->blockType, (IWineD3DStateBlock**) &tmpBlock, NULL/*parent*/);
+
+
+        /* Note just swap the light chains over so when deleting, the old one goes */
+        memcpy(This, tmpBlock, sizeof(IWineD3DStateBlockImpl));
+        tmpBlock->lights = tmp;
+
+        /* Delete the temporary one (which points to the old light chain though */
+        IWineD3DStateBlock_Release((IWineD3DStateBlock *)tmpBlock);
+        /*IDirect3DDevice_DeleteStateBlock(pDeviceImpl, tmpBlock);*/
+
+    } else {
+        unsigned int i, j;
+	
+        PLIGHTINFOEL *src;
+
+        /* Recorded => Only update 'changed' values */
+        if (This->set.vertexShader && This->vertexShader != pDeviceImpl->stateBlock->vertexShader) {
+            This->vertexShader = pDeviceImpl->stateBlock->vertexShader;
+            TRACE("Updating vertex shader to %p\n", pDeviceImpl->stateBlock->vertexShader);
+        }
+
+        /* TODO: Vertex Shader Constants */
+
+        /* Lights... For a recorded state block, we just had a chain of actions to perform,
+             so we need to walk that chain and update any actions which differ */
+        src = This->lights;
+        while (src != NULL) {
+            PLIGHTINFOEL *realLight = NULL;
+            
+            /* Locate the light in the live lights */
+            realLight = pDeviceImpl->stateBlock->lights;
+            while (realLight != NULL && realLight->OriginalIndex != src->OriginalIndex) realLight = realLight->next;
+
+            if (realLight == NULL) {
+                FIXME("A captured light no longer exists...?\n");
+            } else {
+
+                /* If 'changed' then its a SetLight command. Rather than comparing to see
+                     if the OriginalParms have changed and then copy them (twice through
+                     memory) just do the copy                                              */
+                if (src->changed) {
+                    TRACE("Updating lights for light %ld\n", src->OriginalIndex);
+                    memcpy(&src->OriginalParms, &realLight->OriginalParms, sizeof(PLIGHTINFOEL));
+                }
+
+                /* If 'enabledchanged' then its a LightEnable command */
+                if (src->enabledChanged) {
+                    TRACE("Updating lightEnabled for light %ld\n", src->OriginalIndex);
+                    src->lightEnabled = realLight->lightEnabled;
+                }
+
+            }
+
+            src = src->next;
+        }
+        
+        	
+
+#if 0 /*TODO: Pixel shaders*/
+
+        if (This->set.pixelShader && This->pixelShader != pDeviceImpl->stateBlock->pixelShader) {
+            TRACE("Updating pixel shader to %p\n", pDeviceImpl->stateBlock->pixelShader);
+	    IWineD3DDevice_SetPixelShader(pDevice, This->pixelShader);
+        }
+#endif
+        /* TODO: Pixel Shader Constants */
+
+        /* Others + Render & Texture */
+	for (i = 1; i <= HIGHEST_TRANSFORMSTATE; i++) {
+	  if (This->set.transform[i] && memcmp(&pDeviceImpl->stateBlock->transforms[i], 
+						      &This->transforms[i], 
+						      sizeof(D3DMATRIX)) != 0) {
+	    TRACE("Updating transform %d\n", i);
+	    memcpy(&This->transforms[i], &pDeviceImpl->stateBlock->transforms[i], sizeof(D3DMATRIX));
+	  }
+	}
+
+	if (This->set.indices && ((This->pIndexData != pDeviceImpl->stateBlock->pIndexData)
+					 || (This->baseVertexIndex != pDeviceImpl->stateBlock->baseVertexIndex))) {
+	  TRACE("Updating pindexData to %p, baseVertexIndex to %d\n", 
+		pDeviceImpl->stateBlock->pIndexData, pDeviceImpl->stateBlock->baseVertexIndex);
+	  This->pIndexData = pDeviceImpl->stateBlock->pIndexData;
+	  This->baseVertexIndex = pDeviceImpl->stateBlock->baseVertexIndex;
+	}
+#if 1
+
+       if(This->set.vertexDecl && This->vertexDecl != pDeviceImpl->stateBlock->vertexDecl){
+	       This->vertexDecl = pDeviceImpl->stateBlock->vertexDecl;
+       }
+       
+       if(This->set.fvf && This->fvf != pDeviceImpl->stateBlock->fvf){
+	       This->fvf = pDeviceImpl->stateBlock->fvf;
+        }
+#endif
+       if (This->set.material && memcmp(&pDeviceImpl->stateBlock->material, 
+                                                   &This->material, 
+                                                   sizeof(D3DMATERIAL9)) != 0) {
+                TRACE("Updating material\n");
+                memcpy(&This->material, &pDeviceImpl->stateBlock->material, sizeof(D3DMATERIAL9));
+       }
+           
+       if (This->set.viewport && memcmp(&pDeviceImpl->stateBlock->viewport, 
+                                                   &This->viewport, 
+                                                   sizeof(D3DVIEWPORT9)) != 0) {
+                TRACE("Updating viewport\n");
+                memcpy(&This->viewport, &pDeviceImpl->stateBlock->viewport, sizeof(D3DVIEWPORT9));
+       }
+
+       for (i = 0; i < MAX_STREAMS; i++) {
+           if (This->set.streamSource[i] && 
+                           ((This->streamStride[i] != pDeviceImpl->stateBlock->streamStride[i]) ||
+                           (This->streamSource[i] != pDeviceImpl->stateBlock->streamSource[i]))) {
+               TRACE("Updating stream source %d to %p, stride to %d\n", i, pDeviceImpl->stateBlock->streamSource[i], 
+                                                                        pDeviceImpl->stateBlock->streamStride[i]);
+               This->streamStride[i] = pDeviceImpl->stateBlock->streamStride[i];
+               This->streamSource[i] = pDeviceImpl->stateBlock->streamSource[i];
+           }
+           
+           if (This->set.streamFreq[i] && 
+           (This->streamFreq[i] != pDeviceImpl->stateBlock->streamFreq[i]
+           || This->streamFlags[i] != pDeviceImpl->stateBlock->streamFlags[i])){
+                TRACE("Updating stream frequency %d to %d flags to %d\n", i ,  pDeviceImpl->stateBlock->streamFreq[i] , pDeviceImpl->stateBlock->streamFlags[i]);
+                This->streamFreq[i]  =  pDeviceImpl->stateBlock->streamFreq[i];
+                This->streamFlags[i] =  pDeviceImpl->stateBlock->streamFlags[i];
+           }
+       }
+
+       for (i = 0; i < GL_LIMITS(clipplanes); i++) {
+           if (This->set.clipplane[i] && memcmp(&pDeviceImpl->stateBlock->clipplane[i], 
+                                                       &This->clipplane[i], 
+                                                       sizeof(This->clipplane)) != 0) {
+
+               TRACE("Updating clipplane %d\n", i);
+               memcpy(&This->clipplane[i], &pDeviceImpl->stateBlock->clipplane[i], 
+                                       sizeof(This->clipplane));
+           }
+       }
+
+       /* Render */
+       for (i = 1; i <= WINEHIGHEST_RENDER_STATE; i++) {
+
+           if (This->set.renderState[i] && (This->renderState[i] != 
+                                                       pDeviceImpl->stateBlock->renderState[i])) {
+               TRACE("Updating renderState %d to %ld\n", i, pDeviceImpl->stateBlock->renderState[i]);
+               This->renderState[i] = pDeviceImpl->stateBlock->renderState[i];
+           }
+       }
+
+       /* Texture */
+       for (j = 0; j < GL_LIMITS(textures); j++) {
+           for (i = 1; i <= HIGHEST_TEXTURE_STATE ; i++) {
+
+               if (This->set.textureState[j][i] && (This->textureState[j][i] != 
+                                                                pDeviceImpl->stateBlock->textureState[j][i])) {
+                   TRACE("Updating texturestagestate %d,%d to %ld (was %ld)\n", j,i, pDeviceImpl->stateBlock->textureState[j][i], 
+                               This->textureState[j][i]);
+                   This->textureState[j][i] =  pDeviceImpl->stateBlock->textureState[j][i];
+                                  This->renderState[i] = pDeviceImpl->stateBlock->renderState[i];
+               }
+
+           }
+                
+           if ((This->set.textures[j] && (This->textures[j] != pDeviceImpl->stateBlock->textures[j]))) {
+            TRACE("Updating texture %d to %p (was %p)\n", j, pDeviceImpl->stateBlock->textures[j],  This->textures[j]);
+            This->textures[j] =  pDeviceImpl->stateBlock->textures[j];
+           }
+
+       }
+
+
+        /* TODO: MAX_Samplers */
+        for (j = 0 ; j < 16; j++){
+            for (i = 1; i <= HIGHEST_SAMPLER_STATE ; i++){ /* States are 1 based */
+                if (This->set.samplerState[j][i] && (This->samplerState[j][i] !=
+                                                     pDeviceImpl->stateBlock->samplerState[j][i])) {
+                               TRACE("Updating sampler state %d,%d to %ld (was %ld)\n",
+                               j, i, pDeviceImpl->stateBlock->samplerState[j][i],
+                               This->samplerState[j][i]);
+                               This->samplerState[j][i] =  pDeviceImpl->stateBlock->samplerState[j][i];
+               }        
+        }
+       }
+    }
+
+    TRACE("(%p) : Updated state block %p ------------------^\n", pDeviceImpl, This);
+
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DStateBlockImpl_GetDevice(IWineD3DStateBlock *iface, IWineD3DDevice** ppDevice){
+
+    IWineD3DStateBlockImpl *This   = (IWineD3DStateBlockImpl *)iface;
+    
+    *ppDevice = (IWineD3DDevice*)This->wineD3DDevice;
+    IWineD3DDevice_AddRef(*ppDevice);
+    return D3D_OK;    
+    
+}
+
+HRESULT WINAPI IWineD3DStateBlockImpl_Apply(IWineD3DStateBlock *iface){
+    IWineD3DStateBlockImpl *This = (IWineD3DStateBlockImpl *)iface;
+    IWineD3DDevice*        pDevice     = (IWineD3DDevice*)This->wineD3DDevice;
+
+/*Copy thing over to updateBlock is isRecording otherwise StateBlock, 
+should really perform a delta so that only the changes get updated*/
+
+
+    UINT i;
+    UINT j;    
+
+    TRACE("(%p) : Applying state block %p ------------------v\n", This, pDevice);
+
+    /* FIXME: Only apply applicable states not all states */
+
+    if (/*TODO: 'magic' statetype, replace with BOOL This->blockType == D3DSBT_RECORDED || */This->blockType == D3DSBT_ALL || This->blockType == D3DSBT_VERTEXSTATE) {
+    
+
+        PLIGHTINFOEL *toDo = This->lights;
+        while (toDo != NULL) {
+            if (toDo->changed) 
+                  IWineD3DDevice_SetLight(pDevice, toDo->OriginalIndex, &toDo->OriginalParms);
+            if (toDo->enabledChanged) 
+                  IWineD3DDevice_SetLightEnable(pDevice, toDo->OriginalIndex, toDo->lightEnabled);
+            toDo = toDo->next;
+        }
+
+    #if 0 /*TODO: VertexShaders*/
+        if (This->set.vertexShader && This->changed.vertexShader)
+            IWineD3DDevice_SetTexture(iface, 0, pSB->vertexShader);
+
+        /* TODO: Vertex Shader Constants */
+    
+    #endif
+    }
+    
+    #if 0 /*TODO: Pixel Shaders*/
+    if (/*TODO: 'magic' statetype, replace with BOOL This->blockType == D3DSBT_RECORDED || */ This->blockType == D3DSBT_ALL || This->blockType == D3DSBT_PIXELSTATE) {
+
+        if (This->set.pixelShader && This->changed.pixelShader)
+            IWineD3DDevice_SetPixelShader(pDevice, This->pixelShader);
+
+        /* TODO: Pixel Shader Constants */
+    }
+    #endif
+#if 1
+    if(This->set.fvf && This->changed.fvf){
+	    IWineD3DDevice_SetFVF(pDevice, This->fvf);
+    }
+
+    if(This->set.vertexDecl && This->changed.vertexDecl){
+	    IWineD3DDevice_SetVertexDeclaration(pDevice, This->vertexDecl);
+    }
+#endif
+    /* Others + Render & Texture */    
+    if (/*TODO: 'magic' statetype, replace with BOOL This->blockType == D3DSBT_RECORDED || */ This->blockType == D3DSBT_ALL) {
+        for (i = 1; i <= HIGHEST_TRANSFORMSTATE; i++) {
+            if (This->set.transform[i] && This->changed.transform[i])
+                IWineD3DDevice_SetTransform(pDevice, i, &This->transforms[i]);
+        }
+	TRACE("TODO: Implement vertex buffers\n");
+	#if 0
+        if (pSB->set.Indices && pSB->changed.Indices)
+            IWineD3DDevice_SetIndices(iface, pSB->pIndexData, pSB->baseVertexIndex);
+	#endif
+        if (This->set.material && This->changed.material )
+            IWineD3DDevice_SetMaterial(pDevice, &This->material);
+
+        if (This->set.viewport && This->changed.viewport)
+            IWineD3DDevice_SetViewport(pDevice, &This->viewport);
+	TRACE("TODO: Proper implementation using SetStreamSource offset (set to 0 for the moment)\n");
+        for (i=0; i<MAX_STREAMS; i++) {
+            if (This->set.streamSource[i] && This->changed.streamSource[i])
+                IWineD3DDevice_SetStreamSource(pDevice, i, This->streamSource[i],0, This->streamStride[i]);
+
+            if (This->set.streamFreq[i] && This->changed.streamFreq[i])           
+                IWineD3DDevice_SetStreamSourceFreq(pDevice, i, This->streamFreq[i] | This->streamFlags[i]);
+                
+        }  
+
+        for (i = 0; i < GL_LIMITS(clipplanes); i++) {
+            if (This->set.clipplane[i] && This->changed.clipplane[i]) {
+                float clip[4];
+
+                clip[0] = This->clipplane[i][0];
+                clip[1] = This->clipplane[i][1];
+                clip[2] = This->clipplane[i][2];
+                clip[3] = This->clipplane[i][3];
+                IWineD3DDevice_SetClipPlane(pDevice, i, clip);
+            }
+        }
+
+        /* Render */
+        for (i = 1; i <= WINEHIGHEST_RENDER_STATE; i++) {
+            if (This->set.renderState[i] && This->changed.renderState[i])
+                IWineD3DDevice_SetRenderState(pDevice, i, This->renderState[i]);
+        }
+
+        /* Texture */
+        for (j = 0; j < GL_LIMITS(textures); j++) { /* Set The texture first, just incase it resets the states? */
+            if (This->set.textures[j] && This->changed.textures[j]) {
+                IWineD3DDevice_SetTexture(pDevice, j, This->textures[j]);
+            }
+            for (i = 1; i <= HIGHEST_TEXTURE_STATE; i++) {
+                if (This->set.textureState[j][i] && This->changed.textureState[j][i]) {
+                    IWineD3DDevice_SetTextureStageState(pDevice, j, i, This->textureState[j][i]);
+                }
+            }
+        }
+
+        /* TODO: MAX_Samplers */
+        for (j = 0 ; j< 16; j++){
+            for (i = 1; i <= HIGHEST_SAMPLER_STATE; i++){
+                 if (This->set.samplerState[j][i] && This->changed.samplerState[j][i] && This->samplerState[j][i] != 0) {
+                        IWineD3DDevice_SetSamplerState(pDevice, j, i, This->samplerState[j][i]);
+                 }
+            }
+
+        }
+            
+
+    } else if (This->blockType == D3DSBT_PIXELSTATE) {
+
+        for (i = 0; i < NUM_SAVEDPIXELSTATES_R; i++) {
+            if (This->set.renderState[SavedPixelStates_R[i]] && This->changed.renderState[SavedPixelStates_R[i]])
+                IWineD3DDevice_SetRenderState(pDevice, SavedPixelStates_R[i], This->renderState[SavedPixelStates_R[i]]);
+
+        }
+
+        for (j = 0; j < GL_LIMITS(textures); i++) {
+            for (i = 0; i < NUM_SAVEDPIXELSTATES_T; i++) {
+                if (This->set.textureState[j][SavedPixelStates_T[i]] &&
+                    This->changed.textureState[j][SavedPixelStates_T[i]])
+                    IWineD3DDevice_SetTextureStageState(pDevice, j, SavedPixelStates_T[i], This->textureState[j][SavedPixelStates_T[i]]);
+            }
+        }
+
+
+    } else if (This->blockType == D3DSBT_VERTEXSTATE) {
+
+        for (i = 0; i < NUM_SAVEDVERTEXSTATES_R; i++) {
+            if ( This->set.renderState[SavedVertexStates_R[i]] && This->changed.renderState[SavedVertexStates_R[i]])
+                IWineD3DDevice_SetRenderState(pDevice, SavedVertexStates_R[i], This->renderState[SavedVertexStates_R[i]]);
+        }
+
+        for (j = 0; j < GL_LIMITS(textures); i++) {
+            for (i = 0; i < NUM_SAVEDVERTEXSTATES_T; i++) {
+                if ( This->set.textureState[j][SavedVertexStates_T[i]] &&
+                    This->changed.textureState[j][SavedVertexStates_T[i]])
+                    IWineD3DDevice_SetTextureStageState(pDevice, j, SavedVertexStates_T[i], This->textureState[j][SavedVertexStates_T[i]]);
+            }
+        }
+	
+
+
+    } else {
+        FIXME("Unrecognized state block type %d\n", This->blockType);
+    }
+    memcpy(&((IWineD3DDeviceImpl*)pDevice)->stateBlock->changed, &This->changed, sizeof(((IWineD3DDeviceImpl*)pDevice)->stateBlock->changed));
+    TRACE("(%p) : Applied state block %p ------------------^\n", This, pDevice);
+
+    return D3D_OK;
+    
+
+}
+
+
 /**********************************************************
  * IWineD3DStateBlock VTbl follows
  **********************************************************/
@@ -303,5 +702,9 @@
     IWineD3DStateBlockImpl_AddRef,
     IWineD3DStateBlockImpl_Release,
     IWineD3DStateBlockImpl_GetParent,
+    IWineD3DStateBlockImpl_GetDevice,
+    IWineD3DStateBlockImpl_Capture,
+    IWineD3DStateBlockImpl_Apply,    
     IWineD3DStateBlockImpl_InitStartupStateBlock
 };
+
diff -urN wine.20050419/dlls/wined3d/surface.c wine.20050419.dx9/dlls/wined3d/surface.c
--- wine.20050419/dlls/wined3d/surface.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/surface.c	2005-04-20 05:51:33.000000000 -0600
@@ -1,4 +1,4 @@
-/*
+ /*
  * IWineD3DSurface Implementation
  *
  * Copyright 2002-2005 Jason Edmeades
@@ -24,7 +24,17 @@
 #include "config.h"
 #include "wined3d_private.h"
 
+/*Experemental memory management that releases the allocated memory from 
+a surface when the texture is loaded until a lock is requested
+on the surface.
+*/
+#define MANAGED_D3D_MEMORY 
+
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3d_surface);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_ref);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_timings);
+
 #define GLINFO_LOCATION ((IWineD3DImpl *)(((IWineD3DDeviceImpl *)This->resource.wineD3DDevice)->wineD3D))->gl_info
 
 /* *******************************************
@@ -58,16 +68,30 @@
 ULONG WINAPI IWineD3DSurfaceImpl_Release(IWineD3DSurface *iface) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
     ULONG ref = InterlockedDecrement(&This->resource.ref);
-    TRACE("(%p) : Releasing from %ld\n", This, ref + 1);
+    TRACE_(d3d_ref)("(%p) : Releasing to %ld from %ld\n", This, ref, ref + 1);
     if (ref == 0) {
-        if (This->textureName != 0) { /* release the openGL texture.. */
+        int surfacecount = globalStoreReleaseSurface(iface);
+        if(This->resource.pool == D3DPOOL_DEFAULT){            
+            globalChangeGlRam(-This->resource.size);  
+        }
+        if(This->resource.usage & D3DUSAGE_RENDERTARGET){
+             TRACE("Relessing a render target\n");
+             #ifdef OPENGLCONTEXTMANAGER
+                 IContextManager_DestroyRenderTarget(This->contextManager, (IWineD3DSurface *)object);
+             #endif
+        }
+        if(This->textureName != 0){/*release the openGL texture..*/
             ENTER_GL();
             TRACE("Deleting texture %d\n", This->textureName);
             glDeleteTextures(1, &This->textureName);
-            LEAVE_GL();
+            LEAVE_GL();           
+        }
+        if(This->resource.allocatedMemory != NULL){
+            globalChangeSysRam(-This->resource.size);
+            HeapFree(GetProcessHeap(),0,This->resource.allocatedMemory);
         }
-        IWineD3DResourceImpl_CleanUp((IWineD3DResource *)iface);
-        HeapFree(GetProcessHeap(), 0, This);
+        TRACE("(%p) Released, surfaces left %d using %d bytes\n",This , surfacecount, wineD3DGlobalStatistics->totalsurfaceram);
+        HeapFree(GetProcessHeap(),0,This);
 
     }
     return ref;
@@ -124,6 +148,7 @@
           glGenTextures(1, &This->textureName);
           checkGLcall("glGenTextures");
           TRACE("Surface %p given name %d\n", This, This->textureName);
+          /* FIXME: should be using dimensions noe GL_TEXTURE_2D, since this may be a 1d or 3d surface! */
           glBindTexture(GL_TEXTURE_2D, This->textureName);
           checkGLcall("glBindTexture");
           IWineD3DSurface_LoadTexture((IWineD3DSurface *) This, GL_TEXTURE_2D, This->currentDesc.Level);
@@ -162,10 +187,12 @@
     return IWineD3DResourceImpl_GetParent((IWineD3DResource *)iface, pParent);
 }
 
+
 /* ******************************************************
    IWineD3DSurface IWineD3DSurface parts follow
    ****************************************************** */
-
+   
+   
 HRESULT WINAPI IWineD3DSurfaceImpl_GetContainer(IWineD3DSurface* iface, REFIID riid, void** ppContainer) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
     HRESULT hr;
@@ -178,12 +205,15 @@
      * If the surface is created using CreateImageSurface/CreateOffscreenPlainSurface, CreateRenderTarget,
      * or CreateDepthStencilSurface, the surface is considered stand alone. In this case,
      * GetContainer will return the Direct3D device used to create the surface.
-     */
+     */    
     hr = IUnknown_QueryInterface(This->container, riid, ppContainer);
     return hr;
 }
 
-HRESULT WINAPI IWineD3DSurfaceImpl_GetDesc(IWineD3DSurface *iface, WINED3DSURFACE_DESC *pDesc) {
+
+
+
+HRESULT WINAPI IWineD3DSurfaceImpl_GetDesc(IWineD3DSurface * iface, WINED3DSURFACE_DESC* pDesc) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
 
     TRACE("(%p) : copying into %p\n", This, pDesc);
@@ -196,27 +226,39 @@
     *(pDesc->MultiSampleQuality) = This->currentDesc.MultiSampleQuality;
     *(pDesc->Width)              = This->currentDesc.Width;
     *(pDesc->Height)             = This->currentDesc.Height;
+    
+    TRACE("(%p) returning \n",This);
     return D3D_OK;
 }
 
+
 HRESULT WINAPI IWineD3DSurfaceImpl_LockRect(IWineD3DSurface *iface, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
+    IWineD3DDeviceImpl  *myDevice = This->resource.wineD3DDevice;
+    IWineD3DSwapChainImpl *swapchain = NULL;
+    DWORD startTime = 0;
+    static int messages =0; /*flag to say which FIXME messages have already been dispalyed*/
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
 
+    TRACE("(%p) pLockedRect %p pRect %p Flags %ld \n",This,pLockedRect,pRect,Flags);
+    
     /* fixme: should we really lock as such? */
     if (This->inTexture && This->inPBuffer) {
         FIXME("Warning: Surface is in texture memory or pbuffer\n");
         This->inTexture = 0;
         This->inPBuffer = 0;
     }
-
+    
     if (FALSE == This->lockable) {
         /* Note: UpdateTextures calls CopyRects which calls this routine to populate the 
               texture regions, and since the destination is an unlockable region we need
-              to tolerate this                                                           */
-        TRACE("Warning: trying to lock unlockable surf@%p\n", This);  
-        /*return D3DERR_INVALIDCALL; */
+              to find someway tolerate this (or fix update textures!)                */
+        FIXME("Warning: trying to lock unlockable surf@%p\n", This);  
+       /* return D3DERR_INVALIDCALL;*/
     }
 
+#if 0
     if (iface == This->resource.wineD3DDevice->backBuffer || iface == This->resource.wineD3DDevice->renderTarget || 
 		    iface == This->resource.wineD3DDevice->frontBuffer || iface == This->resource.wineD3DDevice->depthStencilBuffer) {
         if (iface == This->resource.wineD3DDevice->backBuffer) {
@@ -228,13 +270,15 @@
         } else if (iface == This->resource.wineD3DDevice->depthStencilBuffer) {
             TRACE("(%p, stencilBuffer) : rect@%p flags(%08lx), output lockedRect@%p, memory@%p\n", This, pRect, Flags, pLockedRect, This->resource.allocatedMemory);
         }
+        IWineD3DSwapChain_Release((IWineD3DSwapChain *)swapchain);
     } else {
         TRACE("(%p) : rect@%p flags(%08lx), output lockedRect@%p, memory@%p\n", This, pRect, Flags, pLockedRect, This->resource.allocatedMemory);
     }
+#endif
 
     /* DXTn formats don't have exact pitches as they are to the new row of blocks,
          where each block is 4x4 pixels, 8 bytes (dxt1) and 16 bytes (dxt3/5)      
-          ie pitch = (width/4) * bytes per block                                  */
+          ie pitch = (width/4) * bytes per block                       */
     if (This->resource.format == WINED3DFMT_DXT1) /* DXT1 is 8 bytes per block */
         pLockedRect->Pitch = (This->currentDesc.Width >> 2) << 3;
     else if (This->resource.format == WINED3DFMT_DXT3 || This->resource.format == WINED3DFMT_DXT5) /* DXT3/5 is 16 bytes per block */
@@ -242,7 +286,7 @@
     else
         pLockedRect->Pitch = This->bytesPerPixel * This->currentDesc.Width;  /* Bytes / row */    
 
-    if (NULL == pRect) {
+    if (NULL == pRect) {    
         pLockedRect->pBits = This->resource.allocatedMemory;
         This->lockedRect.left   = 0;
         This->lockedRect.top    = 0;
@@ -264,22 +308,89 @@
     }
 
 
+        TRACE("Locking non-power 2 texture\n");
     if (0 == This->resource.usage) { /* classic surface */
-
-        /* Nothing to do ;) */
+        IWineD3DBaseTexture *baseTexture = NULL;
+        TRACE("locking an ordinarary surface\n");
+        /* Check to see if memory has already been allocated fro the sufrace*/
+        if(NULL == This->resource.allocatedMemory){
+            /*Surface has no memory currently allocate to it!*/
+            TRACE("(%p) Locking rect\n" , This);
+            This->resource.allocatedMemory = HeapAlloc(GetProcessHeap() ,0 , This->pow2Size);
+            
+            /*Now I have to copy thing bits back*/  
+            This->activeLock = TRUE; /*When this flag is set to true, laoding the surface again won't free THis->resource.allocatedMemory*/
+            ENTER_GL();
+            TRACE("(%p) glEnable \n" , This);
+            glEnable(GL_TEXTURE_2D);
+            vcheckGLcall("glEnable(GL_TEXTURE_2D)");
+            TRACE("(%p) bind texture %d \n" , This, This->textureName);            
+            /** TODO: replace this with a call to 'bindtexture' on the surface,
+             * to make sure that we have a valid textureName.
+              ************************************************/
+            /* This a problem if the container is a texture  */
+            IWineD3DSurface_GetContainer(iface, &IID_IWineD3DBaseTexture, (void **)&baseTexture);
+            if(baseTexture == NULL){
+                IWineD3DSurface_PreLoad(iface); /* Make sure there is a texture to bind! */
+                TRACE("Binding texture %d\n", This->textureName);
+                glBindTexture(GL_TEXTURE_2D, This->textureName);
+            }else{
+                TRACE("Bind a texture to the target, not a standalone surface\n");
+               /* Tell the texture to bind it's self*/
+                IWineD3DBaseTexture_BindTexture(baseTexture);
+                IWineD3DBaseTexture_Release(baseTexture);
+            }
+            vcheckGLcall("glBindTexture");
+            TRACE("(%p) glGetTexImage level(%d), fmt(%d), typ(%d), mem(%p) \n" , This, This->currentDesc.Level,  D3DFmt2GLFmt(myDevice, This->resource.format), D3DFmt2GLType(myDevice, This->resource.format), This->resource.allocatedMemory);
+            glGetTexImage(GL_TEXTURE_2D,
+                        This->currentDesc.Level,
+                        D3DFmt2GLFmt(myDevice, This->resource.format),
+                        D3DFmt2GLType(myDevice, This->resource.format),
+                        This->resource.allocatedMemory);
+            vcheckGLcall("glGetTexImage");
+            glDisable(GL_TEXTURE_2D);
+            vcheckGLcall("glDisable(GL_TEXTURE_2D)");
+            LEAVE_GL();
+        } else {
+            TRACE("Memory already allocted for texture\n");
+        }
+        
+        if(NULL == pRect){
+            pLockedRect->pBits = This->resource.allocatedMemory;
+        }  else{
+            if (This->resource.format == D3DFMT_DXT1) { /* DXT1 is half byte per pixel */
+                pLockedRect->pBits = This->resource.allocatedMemory + (pLockedRect->Pitch * pRect->top) + ((pRect->left * This->bytesPerPixel/2));
+            } else {
+                pLockedRect->pBits = This->resource.allocatedMemory + (pLockedRect->Pitch * pRect->top) + (pRect->left * This->bytesPerPixel);
+            }
+        }
 
     } else if (D3DUSAGE_RENDERTARGET & This->resource.usage && !(Flags&D3DLOCK_DISCARD)) { /* render surfaces */
+        GLint  prev_store;
 
-        if (iface == This->resource.wineD3DDevice->backBuffer || iface == This->resource.wineD3DDevice->renderTarget || iface == This->resource.wineD3DDevice->frontBuffer) {
-            GLint  prev_store;
+            /****************************
+            * TODO: Render targets are 'special' and 
+            * ?some? locking needs to be passed onto the context manager
+            * this would enable the use of auxilary buffers, pbuffers
+            * render-to-texture, shared, cached contexts etc...
+            * ****************************/
             GLenum prev_read;
+            BOOL notInContext = FALSE;
+            IWineD3DSwapChainImpl *mySwapChain     = NULL;
+            IWineD3DSwapChainImpl *targetSwapChain = NULL;
 
-            ENTER_GL();
-
+            ENTER_GL();            
+            
             /**
-             * for render->surface copy begin to begin of allocatedMemory
-             * unlock can be more easy
-             */
+            * for render->surface copy begin to begin of allocatedMemory
+            * unlock can be more easy
+            */
+   
+            TRACE("locking a render target\n");
+            /* Render targets are 'ALWAYS' in the default context, so shouldn't have any memory allocated to them by default */
+            if(This->resource.allocatedMemory == NULL)
+                 This->resource.allocatedMemory = HeapAlloc(GetProcessHeap() ,0 ,This->pow2Size);
+                 This->activeLock = TRUE; /*When this flag is set to true, loading the surface again won't free THis->resource.allocatedMemory*/
             pLockedRect->pBits = This->resource.allocatedMemory;
 
             glFlush();
@@ -289,43 +400,83 @@
             glGetIntegerv(GL_PACK_SWAP_BYTES, &prev_store);
             vcheckGLcall("glIntegerv");
 
-            if (iface == This->resource.wineD3DDevice->backBuffer) {
+/*            if (iface == This->resource.wineD3DDevice->backBuffer) {
                 glReadBuffer(GL_BACK);
             } else if (iface == This->resource.wineD3DDevice->frontBuffer || iface == This->resource.wineD3DDevice->renderTarget) {
                 glReadBuffer(GL_FRONT);
             } else if (iface == This->resource.wineD3DDevice->depthStencilBuffer) {
                 ERR("Stencil Buffer lock unsupported for now\n");
-            }
+            } */
             vcheckGLcall("glReadBuffer");
 
             {
                 long j;
                 GLenum format = D3DFmt2GLFmt(This->resource.wineD3DDevice, This->resource.format);
                 GLenum type   = D3DFmt2GLType(This->resource.wineD3DDevice, This->resource.format);
-                for (j = This->lockedRect.top; j < This->lockedRect.bottom - This->lockedRect.top; ++j) {
-                    glReadPixels(This->lockedRect.left, 
-                                 This->lockedRect.bottom - j - 1, 
-                                 This->lockedRect.right - This->lockedRect.left, 
-                                 1,
-                                 format, 
-                                 type, 
-                                 (char *)pLockedRect->pBits + (pLockedRect->Pitch * (j-This->lockedRect.top)));
-                    vcheckGLcall("glReadPixels");
+                #if 0                
+                /* Bizarly it's takes 120 millseconds to get an 800x600 region a line at a time, but only 10 to get the whole lot every time,
+                *  This is on an ATI9600, and may be format dependant, anyhow this hack makes this demo dx9_2d_demo_game
+                *  run ten times faster! 
+                * ************************************/
+                BOOL ati_performance_hack = FALSE;
+                ati_performance_hack = (This->lockedRect.bottom - This->lockedRect.top > 10) || (This->lockedRect.right - This->lockedRect.left > 10)? TRUE: FALSE;
+                #endif
+                if((This->lockedRect.left ==0 &&  This->lockedRect.top ==0 &&
+                    This->lockedRect.right == This->currentDesc.Width
+                    && This->lockedRect.bottom ==  This->currentDesc.Height)){
+                       glReadPixels(0, 0,
+                        This->currentDesc.Width,
+                        This->currentDesc.Height,
+                        format,
+                        type,
+                        (char *)pLockedRect->pBits);
+                }else if(This->lockedRect.left ==0 &&  This->lockedRect.right == This->currentDesc.Width){
+                        glReadPixels(0,
+                        This->lockedRect.top,
+                        This->currentDesc.Width,
+                        This->currentDesc.Height,
+                        format,
+                        type,
+                        (char *)pLockedRect->pBits);
+                } else{
+                    for (j = This->lockedRect.top; j < This->lockedRect.bottom - This->lockedRect.top; ++j) {
+                        glReadPixels(This->lockedRect.left, 
+                                    This->lockedRect.bottom - j - 1,
+                                    This->lockedRect.right - This->lockedRect.left, 
+                                    1,
+                                    format, 
+                                    type, 
+                                    (char *)pLockedRect->pBits + (pLockedRect->Pitch * (j-This->lockedRect.top)));
+
+                    }
                 }
+                vcheckGLcall("glReadPixels");
+                /*TODO: switch back to the precious context if necessasary */
+                TRACE("Resetting buffer\n");
+                glReadBuffer(prev_read);
+                vcheckGLcall("glReadBuffer");
             }
 
-            glReadBuffer(prev_read);
-            vcheckGLcall("glReadBuffer");
-
             LEAVE_GL();
-
-        } else {
+/*        } else {
             FIXME("unsupported locking to Rendering surface surf@%p usage(%lu)\n", This, This->resource.usage);
-        }
+        } */
 
     } else if (D3DUSAGE_DEPTHSTENCIL & This->resource.usage) { /* stencil surfaces */
-
-        FIXME("TODO stencil depth surface locking surf@%p usage(%lu)\n", This, This->resource.usage);
+        if(! messages & 1){
+            FIXME("TODO stencil depth surface locking surf%p usage(%lu)\n", This, This->resource.usage);
+            /*
+            
+            glReadPixels(This->lockedRect.left,
+            This->lockedRect.bottom - j - 1, 
+            This->lockedRect.right - This->lockedRect.left,
+            1,
+            GL_STENCIL_INDEX or GL_DEPTH_COMPONENT
+            
+            )
+            */
+            messages |=1;
+        }
 
     } else {
         FIXME("unsupported locking to surface surf@%p usage(%lu)\n", This, This->resource.usage);
@@ -334,13 +485,15 @@
     if (Flags & (D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_READONLY)) {
         /* Don't dirtify */
     } else {
-        IWineD3DBaseTexture *pBaseTexture;
+        IWineD3DBaseTexture *pBaseTexture = NULL;
+        HRESULT hr = D3D_OK;
+
+	TRACE("Dirty rec on lock\n");
         /**
-         * Dirtify on lock
-         * as seen in msdn docs
-         */
+        * Dirtify on lock
+        * as seen in msdn docs
+        */
         IWineD3DSurface_AddDirtyRect(iface, &This->lockedRect);
-
         /** Dirtify Container if needed */        
         if (D3D_OK == IWineD3DSurface_GetContainer(iface, &IID_IWineD3DBaseTexture, (void **)&pBaseTexture) && pBaseTexture != NULL) {
             TRACE("Making container dirty\n");
@@ -352,54 +505,75 @@
     }
 
     TRACE("returning memory@%p, pitch(%d) dirtyfied(%d)\n", pLockedRect->pBits, pLockedRect->Pitch, This->Dirty);
-
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
     This->locked = TRUE;
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DSurfaceImpl_UnlockRect(IWineD3DSurface *iface) {
+HRESULT WINAPI IWineD3DSurfaceImpl_UnlockRect(IWineD3DSurface* iface) {
+    IWineD3DSurfaceImpl *This     = (IWineD3DSurfaceImpl *)iface;
+    IWineD3DDeviceImpl  *myDevice = This->resource.wineD3DDevice;
     GLint skipBytes = 0;
-    IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
+    static int messages =0;
+    DWORD startTime = 0;
+    const char *buffername = "";
+    IWineD3DSwapChainImpl *swapchain = NULL;
+    
+    if (TRACE_ON(d3d_timings))
+        startTime = GetTickCount(); /* Use windows calls for this */
 
     if (FALSE == This->locked) {
         ERR("trying to Unlock an unlocked surf@%p\n", This);  
         return D3DERR_INVALIDCALL;
     }
 
+#if 0
     if (iface== This->resource.wineD3DDevice->backBuffer || iface == This->resource.wineD3DDevice->frontBuffer || 
 		    iface == This->resource.wineD3DDevice->depthStencilBuffer || iface == This->resource.wineD3DDevice->renderTarget) {
         if (iface == This->resource.wineD3DDevice->backBuffer) {
-            TRACE("(%p, backBuffer) : dirtyfied(%d)\n", This, This->Dirty);
+            buffername = "backBuffer";
         } else if (iface == This->resource.wineD3DDevice->frontBuffer) {
-            TRACE("(%p, frontBuffer) : dirtyfied(%d)\n", This, This->Dirty);
+            buffername = "frontBuffer";
         } else if (iface == This->resource.wineD3DDevice->depthStencilBuffer) {
-            TRACE("(%p, stencilBuffer) : dirtyfied(%d)\n", This, This->Dirty);
+            buffername = "depthStencilBuffer";
         } else if (iface == This->resource.wineD3DDevice->renderTarget) {
-            TRACE("(%p, renderTarget) : dirtyfied(%d)\n", This, This->Dirty);
-        }
-    } else {
-        TRACE("(%p) : dirtyfied(%d)\n", This, This->Dirty);
+            buffername = "renderTarget";
     }
+    if(swapchain != NULL){
+        IWineD3DSwapChain_Release((IWineD3DSwapChain *)swapchain);
+    }
+#endif
+    TRACE("(%p %s) : dirtyfied(%d)\n", This, buffername, This->Dirty);
 
-    if (FALSE == This->Dirty) {
+    if (FALSE == This->Dirty) { 
         TRACE("(%p) : Not Dirtified so nothing to do, return now\n", This);
         goto unlock_end;
     }
 
     if (0 == This->resource.usage) { /* classic surface */
         /**
-         * nothing to do
-         * waiting to reload the surface via IDirect3DDevice8::UpdateTexture
-         */
+        * nothing to do
+        * waiting to reload the surface via IDirect3DDevice8::UpdateTexture when the texture is preloaded
+        */
     } else if (D3DUSAGE_RENDERTARGET & This->resource.usage) { /* render surfaces */
-
-        if (iface == This->resource.wineD3DDevice->backBuffer || iface == This->resource.wineD3DDevice->frontBuffer || iface == This->resource.wineD3DDevice->renderTarget) {
+            
+            /****************************
+            * TODO: Render targets are 'special' and 
+            * ?some? locking needs to be passed onto the context manager
+            * this would enable the use of auxilary buffers, pbuffers
+            * render-to-texture, shared, cached contexts etc...          
+            * ****************************/
+
+        IWineD3DSwapChainImpl *implSwapChain;
+        IWineD3DDevice_GetSwapChain((IWineD3DDevice *)myDevice, 0, (IWineD3DSwapChain **)&implSwapChain);
+        if (iface ==  implSwapChain->backBuffer || iface ==  implSwapChain->frontBuffer || iface == myDevice->renderTarget) {
             GLint  prev_store;
             GLenum prev_draw;
             GLint  prev_rasterpos[4];
-
+    
             ENTER_GL();
-
+    
             glFlush();
             vcheckGLcall("glFlush");
             glGetIntegerv(GL_DRAW_BUFFER, &prev_draw);
@@ -410,67 +584,72 @@
             vcheckGLcall("glIntegerv");
             glPixelZoom(1.0, -1.0);
             vcheckGLcall("glPixelZoom");
-
+    
             /* glDrawPixels transforms the raster position as though it was a vertex -
-               we want to draw at screen position 0,0 - Set up ortho (rhw) mode as   
-               per drawprim (and leave set - it will sort itself out due to last_was_rhw */
-            if (!This->resource.wineD3DDevice->last_was_rhw) {
-
+            we want to draw at screen position 0,0 - Set up ortho (rhw) mode as   
+            per drawprim (and leave set - it will sort itself out due to last_was_rhw
+            TODO: this needs to be per-context! possibly migrate to the context manager?
+              it would keep all the code like this \/\/\/\/ in the same place too
+            */
+            if (!myDevice->last_was_rhw) {
+    
                 double X, Y, height, width, minZ, maxZ;
-                This->resource.wineD3DDevice->last_was_rhw = TRUE;
-
+                myDevice->last_was_rhw = TRUE;
+    
                 /* Transformed already into viewport coordinates, so we do not need transform
-                   matrices. Reset all matrices to identity and leave the default matrix in world 
-                   mode.                                                                         */
+                matrices. Reset all matrices to identity and leave the default matrix in world 
+                mode.                                                                         */
                 glMatrixMode(GL_MODELVIEW);
                 checkGLcall("glMatrixMode");
                 glLoadIdentity();
                 checkGLcall("glLoadIdentity");
-
+    
                 glMatrixMode(GL_PROJECTION);
                 checkGLcall("glMatrixMode");
                 glLoadIdentity();
                 checkGLcall("glLoadIdentity");
-
+    
                 /* Set up the viewport to be full viewport */
-                X      = This->resource.wineD3DDevice->stateBlock->viewport.X;
-                Y      = This->resource.wineD3DDevice->stateBlock->viewport.Y;
-                height = This->resource.wineD3DDevice->stateBlock->viewport.Height;
-                width  = This->resource.wineD3DDevice->stateBlock->viewport.Width;
-                minZ   = This->resource.wineD3DDevice->stateBlock->viewport.MinZ;
-                maxZ   = This->resource.wineD3DDevice->stateBlock->viewport.MaxZ;
+                X      = myDevice->stateBlock->viewport.X;
+                Y      = myDevice->stateBlock->viewport.Y;
+                height = myDevice->stateBlock->viewport.Height;
+                width  = myDevice->stateBlock->viewport.Width;
+                minZ   = myDevice->stateBlock->viewport.MinZ;
+                maxZ   = myDevice->stateBlock->viewport.MaxZ;
                 TRACE("Calling glOrtho with %f, %f, %f, %f\n", width, height, -minZ, -maxZ);
-                glOrtho(X, X + width, Y + height, Y, -minZ, -maxZ);
-                checkGLcall("glOrtho");
-
+                glOrtho(X, X + width, Y + height, Y, -minZ, -maxZ);	    
+                checkGLcall("glOrtho");	    
+    
                 /* Window Coord 0 is the middle of the first pixel, so translate by half
-                   a pixel (See comment above glTranslate below)                         */
+                a pixel (See comment above glTranslate below)                         */
                 glTranslatef(0.5, 0.5, 0);
                 checkGLcall("glTranslatef(0.5, 0.5, 0)");
             }
-
+    
+#if 0
             if (iface == This->resource.wineD3DDevice->backBuffer) {
                 glDrawBuffer(GL_BACK);
             } else if (iface == This->resource.wineD3DDevice->frontBuffer || iface == This->resource.wineD3DDevice->renderTarget) {
                 glDrawBuffer(GL_FRONT);
             }
-            vcheckGLcall("glDrawBuffer");
-
+            
+            vcheckGLcall("glDrawBuffer");    
+#endif
             /* If not fullscreen, we need to skip a number of bytes to find the next row of data */
             glGetIntegerv(GL_UNPACK_ROW_LENGTH, &skipBytes);
             glPixelStorei(GL_UNPACK_ROW_LENGTH, This->currentDesc.Width);
-
+    
             /* And back buffers are not blended */
             glDisable(GL_BLEND);
-
             glRasterPos3i(This->lockedRect.left, This->lockedRect.top, 1);
             vcheckGLcall("glRasterPos2f");
             switch (This->resource.format) {
+            
             case WINED3DFMT_R5G6B5:
                 {
-                    glDrawPixels(This->lockedRect.right - This->lockedRect.left, (This->lockedRect.bottom - This->lockedRect.top)-1,
+                glDrawPixels(This->lockedRect.right - This->lockedRect.left, (This->lockedRect.bottom - This->lockedRect.top)-1,
                                  GL_RGB, GL_UNSIGNED_SHORT_5_6_5, This->resource.allocatedMemory);
-                    vcheckGLcall("glDrawPixels");
+                vcheckGLcall("glDrawPixels");
                 }
                 break;
             case WINED3DFMT_R8G8B8:
@@ -481,7 +660,7 @@
                 }
                 break;
             case WINED3DFMT_X8R8G8B8: /* FIXME: there's no alpha change with D3DFMT_X8R8G8B8 but were using GL_BGRA */
-            case WINED3DFMT_A8R8G8B8:
+            case D3DFMT_A8R8G8B8:
                 {
                     glPixelStorei(GL_PACK_SWAP_BYTES, TRUE);
                     vcheckGLcall("glPixelStorei");
@@ -495,33 +674,39 @@
             default:
                 FIXME("Unsupported Format %u in locking func\n", This->resource.format);
             }
-
             glPixelZoom(1.0,1.0);
             vcheckGLcall("glPixelZoom");
             glDrawBuffer(prev_draw);
             vcheckGLcall("glDrawBuffer");
             glRasterPos3iv(&prev_rasterpos[0]);
             vcheckGLcall("glRasterPos3iv");
-
+    
             /* Reset to previous pack row length / blending state */
             glPixelStorei(GL_UNPACK_ROW_LENGTH, skipBytes);
-            if (This->resource.wineD3DDevice->stateBlock->renderState[D3DRS_ALPHABLENDENABLE]) glEnable(GL_BLEND);
-
-            LEAVE_GL();
-
-            /** restore clean dirty state */
-            IWineD3DSurface_CleanDirtyRect(iface);
+            if (myDevice->stateBlock->renderState[D3DRS_ALPHABLENDENABLE]) glEnable(GL_BLEND);
+    
+                LEAVE_GL();
+    
+                /** restore clean dirty stateD3DFMT_A8R8G8B8 */
+                IWineD3DSurface_CleanDirtyRect(iface);
 
-        } else {
+            } else {
             FIXME("unsupported unlocking to Rendering surface surf@%p usage(%lu)\n", This, This->resource.usage);
-        }
-
+            }
+            IWineD3DSwapChain_Release((IWineD3DSwapChain *)implSwapChain);
+    
     } else if (D3DUSAGE_DEPTHSTENCIL & This->resource.usage) { /* stencil surfaces */
-
-        if (iface == This->resource.wineD3DDevice->depthStencilBuffer) {
-            FIXME("TODO stencil depth surface unlocking surf@%p usage(%lu)\n", This, This->resource.usage);
+        
+            if (iface == myDevice->depthStencilBuffer) {
+                if(!messages &1){
+                    FIXME("TODO stencil depth surface unlocking surf@%p usage(%lu)\n", This, This->resource.usage);
+                    messages |=1;
+            }
         } else {
-            FIXME("unsupported unlocking to StencilDepth surface surf@%p usage(%lu)\n", This, This->resource.usage);
+            if(!(messages & 2)){
+                FIXME("unsupported unlocking to StencilDepth surface surf@%p usage(%lu)\n", This, This->resource.usage);
+                messages |=2;
+            }
         }
 
     } else {
@@ -531,29 +716,42 @@
     unlock_end:
     This->locked = FALSE;
     memset(&This->lockedRect, 0, sizeof(RECT));
+    if (TRACE_ON(d3d_timings))
+        TRACE_(d3d_timings)("(%p) starttime %ld, total time %ld\n", This, startTime ,  GetTickCount() -startTime);
+
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DSurfaceImpl_GetDC(IWineD3DSurface *iface, HDC *pHDC) {
+HRESULT WINAPI IWineD3DSurfaceImpl_GetDC(IWineD3DSurface * iface, HDC* phdc) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
-    FIXME("No support for GetDC yet for surface %p\n", This);
+    FIXME("(%p) : stub\n", This);
     return D3DERR_INVALIDCALL;
 }
 
-HRESULT WINAPI IWineD3DSurfaceImpl_ReleaseDC(IWineD3DSurface *iface, HDC hDC) {
+HRESULT WINAPI IWineD3DSurfaceImpl_ReleaseDC(IWineD3DSurface * iface, HDC hdc) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
-    FIXME("No support for ReleaseDC yet for surface %p\n", This);
+    FIXME("(%p) : stub\n", This);
     return D3DERR_INVALIDCALL;
 }
 
+HRESULT WINAPI IWineD3DSurfaceImpl_SaveSnapshot(IWineD3DSurface *iface, const char* filename);
 /* ******************************************************
    IWineD3DSurface Internal (No mapping to directx api) parts follow
    ****************************************************** */
 HRESULT WINAPI IWineD3DSurfaceImpl_LoadTexture(IWineD3DSurface *iface, GLenum gl_target, GLenum gl_level) {
-    IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
-
+    IWineD3DSurfaceImpl *This     = (IWineD3DSurfaceImpl *)iface;
+    IWineD3DDeviceImpl  *myDevice = This->resource.wineD3DDevice;
+    /*TODO: Obay the textures pool and move some textures over to video ram (if possible)*/
     if (This->inTexture)
         return D3D_OK;
+        /*
+        Resources are placed in system RAM and do not need to be recreated when a device is lost. These resources are not bound by device size or format restrictions. Because of this, these resources cannot be accessed by the Direct3D device nor set as textures or render targets. However, these resources can always be created, locked, and copied.
+        */
+    if (This->resource.pool == D3DPOOL_SCRATCH || This->resource.pool == D3DPOOL_SYSTEMMEM) /*never store scratch or system mem textures in the video ram*/
+    {   
+        FIXME("(%p) Opperation not supported for scratch or SYSTEMMEM textures\n",This);
+        return D3DERR_INVALIDCALL;
+    }
 
     if (This->inPBuffer) {
         ENTER_GL();
@@ -565,22 +763,45 @@
                  This->resource.format == WINED3DFMT_DXT5)
             FIXME("Format %d not supported\n", This->resource.format);
         else {
-            glCopyTexImage2D(gl_target,
+        /*It's possible that glPixelSoom is supported? */
+        #if 1
+            #if 0/* usefull for debugging, generate a colourdImage instead of glCopyTexImage2D */
+                unsigned char *whiteImage = NULL;
+                whiteImage = malloc(This->currentDesc.Width * This->currentDesc.Height*4);
+                memset(whiteImage, 200, This->currentDesc.Width*  This->currentDesc.Height*4);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+                This->currentDesc.Width, This->currentDesc.Height,
+                0, GL_RGBA, GL_UNSIGNED_BYTE, whiteImage);
+                free(whiteImage);
+            #else
+            /*
+
+            NOTE: The pixels in the rectangle are processed exactly as if glCopyPixels had been called. This means we need to set and restore pixelZoom &co.
+
+            */
+            glCopyTexImage2D(GL_TEXTURE_2D, //gl_target,
                              0,
-                             D3DFmt2GLIntFmt(This->resource.wineD3DDevice,
+                             D3DFmt2GLIntFmt(myDevice,
                                              This->resource.format),
                              0,
                              0,
                              This->currentDesc.Width,
                              This->currentDesc.Height,
                              0);
+            #endif
+            checkGLcall("glCopyTexImage2D");            
+            
+#endif                
+                             
             TRACE("Updating target %d\n", gl_target);
             This->inTexture = TRUE;
         }
         LEAVE_GL();
         return D3D_OK;
     }
-
+    
     if ((This->resource.format == WINED3DFMT_P8 || This->resource.format == WINED3DFMT_A8P8) &&
         !GL_SUPPORT(EXT_PALETTED_TEXTURE)) {
         /**
@@ -588,7 +809,7 @@
          * so software emulation code begin
          */
         UINT i;
-        PALETTEENTRY* pal = This->resource.wineD3DDevice->palettes[This->resource.wineD3DDevice->currentPalette];
+        PALETTEENTRY* pal = myDevice->palettes[myDevice->currentPalette];
         VOID* surface = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, This->currentDesc.Width * This->currentDesc.Height * sizeof(DWORD));
         BYTE* dst = (BYTE*) surface;
         BYTE* src = (BYTE*) This->resource.allocatedMemory;
@@ -609,27 +830,30 @@
         TRACE("Calling glTexImage2D %x i=%d, intfmt=%x, w=%d, h=%d,0=%d, glFmt=%x, glType=%x, Mem=%p\n",
               gl_target,
               gl_level, 
-              GL_RGBA,
+              GL_RGB,
               This->currentDesc.Width, 
               This->currentDesc.Height, 
               0, 
               GL_RGBA,
               GL_UNSIGNED_BYTE,
-              surface);
-        glTexImage2D(gl_target,
-                     gl_level, 
-                     GL_RGBA,
+              surface);	
+        glTexImage2D(gl_target, /*Should always be GL_TEXTURE_2D*/
+                     gl_level,
+                     GL_RGB, /*This was GL_RGBA but the alpha channel has caused problems elsewhere*/
                      This->currentDesc.Width,
                      This->currentDesc.Height,
-                     0,
+                     0/*border*/,
                      GL_RGBA,
                      GL_UNSIGNED_BYTE,
                      surface);
         checkGLcall("glTexImage2D");
-        HeapFree(GetProcessHeap(), 0, surface);
-
-        LEAVE_GL();
-
+        LEAVE_GL();                              
+        #ifdef     MANAGED_D3D_MEMORY        
+        #if 0 /*TODO: dynamic locking of palleted textures isn't supported at the moment, so don't release the system memory*/
+        HeapFree(GetProcessHeap(),0,This->resource.allocatedMemory);
+        This->resource.allocatedMemory = NULL;
+        #endif
+        #endif
         return D3D_OK;    
     }
 
@@ -648,7 +872,6 @@
                   This->resource.allocatedMemory);
 
             ENTER_GL();
-
             GL_EXTCALL(glCompressedTexImage2DARB)(gl_target, 
                                                   gl_level, 
                                                   D3DFmt2GLIntFmt(This->resource.wineD3DDevice, This->resource.format),
@@ -658,49 +881,115 @@
                                                   This->resource.size,
                                                   This->resource.allocatedMemory);
             checkGLcall("glCommpressedTexTexImage2D");
+            LEAVE_GL();            
+            #ifdef     MANAGED_D3D_MEMORY
+            if(This->activeLock == FALSE){
+                HeapFree(GetProcessHeap(),0,This->resource.allocatedMemory);
+                This->resource.allocatedMemory = NULL;                                
+                globalChangeSysRam(-This->resource.size);
+            }
+            #endif
+
+
 
-            LEAVE_GL();
         } else {
             FIXME("Using DXT1/3/5 without advertized support\n");
         }
     } else {
-
-        TRACE("Calling glTexImage2D %x i=%d, d3dfmt=%s, intfmt=%x, w=%d, h=%d,0=%d, glFmt=%x, glType=%x, Mem=%p\n",
-              gl_target, 
-              gl_level, 
+        
+        if(gl_target != GL_TEXTURE_2D){
+           FIXME("gl_target must be GL_TEXTURE_2D\n");
+        }
+        /* TODO: http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_non_power_of_two.txt if supported and opengl 2.0
+            and this too GL_NV_texture_rectangle (but the implementation I've done seems better than GL_NV_texture_rectangle (e.g. mipmaps are supported)
+            http://www.msi.unilim.fr/~porquet/glexts/GL_NV_texture_rectangle.txt.html
+
+        */
+        if(This->nonpow2 == TRUE){
+            TRACE("non power of two support\n");
+            ENTER_GL();
+            TRACE("(%p) Calling 2 glTexImage2D %x i=%d, d3dfmt=%s, intfmt=%x, w=%d, h=%d,0=%d, glFmt=%x, glType=%x, Mem=%p\n", This,
+                gl_target,
+                gl_level, 
               debug_d3dformat(This->resource.format),
               D3DFmt2GLIntFmt(This->resource.wineD3DDevice, This->resource.format), 
-              This->currentDesc.Width, 
-              This->currentDesc.Height, 
-              0, 
+                This->pow2Width, 
+                This->pow2Height, 
+                0, 
+                D3DFmt2GLFmt(myDevice, This->resource.format), 
+                D3DFmt2GLType(myDevice, This->resource.format),
+                NULL);
+
+            
+            glTexImage2D(gl_target,
+                         gl_level,
+                         D3DFmt2GLIntFmt(myDevice, This->resource.format),
+                         This->pow2Width,
+                         This->pow2Height,
+                         0/*border*/,
+                         D3DFmt2GLFmt(myDevice, This->resource.format),
+                         D3DFmt2GLType(myDevice, This->resource.format),
+                         NULL);
+
+                                     
+            checkGLcall("glTexImage2D");
+            if(This->resource.allocatedMemory != NULL){
+                TRACE("(%p) Calling glTexSubImage2D w(%d) h(%d) mem(%p)\n", This, This->currentDesc.Width, This->currentDesc.Height, This->resource.allocatedMemory);
+                /* And map the non-power two data into the top left corner */
+                glTexSubImage2D(
+                    gl_target,
+                    gl_level,
+                    0 /* xoffset */,
+                    0 /* ysoffset */ ,
+                    This->currentDesc.Width,
+                    This->currentDesc.Height,
+                    D3DFmt2GLFmt(myDevice, This->resource.format),
+                    D3DFmt2GLType(myDevice, This->resource.format),
+                    This->resource.allocatedMemory
+                );
+                checkGLcall("glTexSubImage2D");
+            }
+            
+            LEAVE_GL();
+
+            
+        }else{
+        
+            TRACE("Calling 2 glTexImage2D %x i=%d, d3dfmt=%s, intfmt=%x, w=%d, h=%d,0=%d, glFmt=%x, glType=%x, Mem=%p\n",
+                gl_target,
+                gl_level, 
+                debug_d3dformat(This->resource.format),
+                D3DFmt2GLIntFmt(myDevice, This->resource.format), 
+                This->currentDesc.Width, 
+                This->currentDesc.Height, 
+                0, 
               D3DFmt2GLFmt(This->resource.wineD3DDevice, This->resource.format), 
               D3DFmt2GLType(This->resource.wineD3DDevice, This->resource.format),
               This->resource.allocatedMemory);
-
-        ENTER_GL();
-
-        glTexImage2D(gl_target, 
-                     gl_level,
+    
+            ENTER_GL();        
+            glTexImage2D(gl_target,
+                        gl_level,
                      D3DFmt2GLIntFmt(This->resource.wineD3DDevice, This->resource.format),
-                     This->currentDesc.Width,
-                     This->currentDesc.Height,
-                     0,
+                        This->currentDesc.Width,
+                        This->currentDesc.Height,
+                        0/*border*/,
                      D3DFmt2GLFmt(This->resource.wineD3DDevice, This->resource.format),
                      D3DFmt2GLType(This->resource.wineD3DDevice, This->resource.format),
                      This->resource.allocatedMemory);
-        checkGLcall("glTexImage2D");
-
-        LEAVE_GL();
+            checkGLcall("glTexImage2D");
+            LEAVE_GL();
+        }
 
-#if 0
+#if 0 /* Take a snapshot!*/
         {
             static unsigned int gen = 0;
-            char buffer[4096];
-            ++gen;
-            if ((gen % 10) == 0) {
+            char buffer[4096];            
+            if ((gen % 10) == 0) {	    
                 snprintf(buffer, sizeof(buffer), "/tmp/surface%p_type%u_level%u_%u.ppm", This, gl_target, gl_level, gen);
-                IWineD3DSurfaceImpl_SaveSnapshot((LPDIRECT3DSURFACE8) This, buffer);
+                IWineD3DSurfaceImpl_SaveSnapshot((IWineD3DSurface*) This, (const char*) buffer);
             }
+            ++gen;
             /*
              * debugging crash code
             if (gen == 250) {
@@ -710,6 +999,14 @@
             */
         }
 #endif
+
+            #ifdef     MANAGED_D3D_MEMORY
+            if(This->activeLock == FALSE){
+                HeapFree(GetProcessHeap(),0,This->resource.allocatedMemory);
+                This->resource.allocatedMemory = NULL;
+                globalChangeSysRam(-This->resource.size);
+            }
+            #endif 
     }
 
     return D3D_OK;
@@ -717,10 +1014,19 @@
 
 #include <errno.h>
 #include <stdio.h>
+
 HRESULT WINAPI IWineD3DSurfaceImpl_SaveSnapshot(IWineD3DSurface *iface, const char* filename) {
     FILE* f = NULL;
     ULONG i;
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
+    /*FIXME:
+    Textures my not be stored in ->allocateMemory and a GlTexture
+    so we should lock the surface before saving a snapshot, or atleast check that
+    */
+    if(NULL == This->resource.allocatedMemory){
+        FIXME("(%p) This surface needs to be locked before a snapshot can be taken\n", This);
+        return D3D_OK;
+    }
 
     f = fopen(filename, "w+");
     if (NULL == f) {
@@ -796,24 +1102,24 @@
     return D3D_OK;
 }
 
-HRESULT WINAPI IWineD3DSurfaceImpl_CleanDirtyRect(IWineD3DSurface *iface) {
-    IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
-    This->Dirty = FALSE;
-    This->dirtyRect.left   = This->currentDesc.Width;
-    This->dirtyRect.top    = This->currentDesc.Height;
-    This->dirtyRect.right  = 0;
-    This->dirtyRect.bottom = 0;
-    TRACE("(%p) : Dirty?%d, Rect:(%ld,%ld,%ld,%ld)\n", This, This->Dirty, This->dirtyRect.left, 
-          This->dirtyRect.top, This->dirtyRect.right, This->dirtyRect.bottom);
-    return D3D_OK;
+ 
+HRESULT WINAPI IWineD3DSurfaceImpl_CleanDirtyRect(IWineD3DSurface* iface) {
+  IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
+  This->Dirty = FALSE;
+  This->dirtyRect.left   = This->currentDesc.Width;
+  This->dirtyRect.top    = This->currentDesc.Height;
+  This->dirtyRect.right  = 0;
+  This->dirtyRect.bottom = 0;
+  return D3D_OK;
 }
 
 /**
  *   Slightly inefficient way to handle multiple dirty rects but it works :)
  */
-extern HRESULT WINAPI IWineD3DSurfaceImpl_AddDirtyRect(IWineD3DSurface *iface, CONST RECT* pDirtyRect) {
+HRESULT WINAPI IWineD3DSurfaceImpl_AddDirtyRect(IWineD3DSurface* iface, CONST RECT* pDirtyRect) {
     IWineD3DSurfaceImpl *This = (IWineD3DSurfaceImpl *)iface;
     This->Dirty = TRUE;
+  /*FIXME: Possibly handle multiple clipping rects instead of growing the main dirty rect?*/
     if (NULL != pDirtyRect) {
         This->dirtyRect.left   = min(This->dirtyRect.left,   pDirtyRect->left);
         This->dirtyRect.top    = min(This->dirtyRect.top,    pDirtyRect->top);
@@ -822,7 +1128,7 @@
     } else {
         This->dirtyRect.left   = 0;
         This->dirtyRect.top    = 0;
-        This->dirtyRect.right  = This->currentDesc.Width;
+        This->dirtyRect.right  = This->currentDesc.Width;        
         This->dirtyRect.bottom = This->currentDesc.Height;
     }
     TRACE("(%p) : Dirty?%d, Rect:(%ld,%ld,%ld,%ld)\n", This, This->Dirty, This->dirtyRect.left, 
@@ -851,7 +1157,7 @@
     /* IUnknown */
     IWineD3DSurfaceImpl_QueryInterface,
     IWineD3DSurfaceImpl_AddRef,
-    IWineD3DSurfaceImpl_Release,
+    IWineD3DSurfaceImpl_Release,    
     /* IWineD3DResource */
     IWineD3DSurfaceImpl_GetParent,
     IWineD3DSurfaceImpl_GetDevice,
@@ -861,8 +1167,8 @@
     IWineD3DSurfaceImpl_SetPriority,
     IWineD3DSurfaceImpl_GetPriority,
     IWineD3DSurfaceImpl_PreLoad,
-    IWineD3DSurfaceImpl_GetType,
-    /* IWineD3DSurface */    
+    IWineD3DSurfaceImpl_GetType,           
+    /* IWineD3DSurface */
     IWineD3DSurfaceImpl_GetContainer,
     IWineD3DSurfaceImpl_GetDesc,
     IWineD3DSurfaceImpl_LockRect,
@@ -875,5 +1181,5 @@
     IWineD3DSurfaceImpl_LoadTexture,
     IWineD3DSurfaceImpl_SaveSnapshot,
     IWineD3DSurfaceImpl_SetContainer,
-    IWineD3DSurfaceImpl_SetPBufferState    
+    IWineD3DSurfaceImpl_SetPBufferState
 };
diff -urN wine.20050419/dlls/wined3d/swapchain.c wine.20050419.dx9/dlls/wined3d/swapchain.c
--- wine.20050419/dlls/wined3d/swapchain.c	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/swapchain.c	2005-04-20 05:52:05.000000000 -0600
@@ -0,0 +1,463 @@
+/*
+ *IDirect3DSwapChain9 implementation
+ *
+ *Copyright 2002-2003 Jason Edmeades
+ *                    Raphael Junqueira
+ *               2005 Oliver Stieber
+ *
+ *This library is free software; you can redistribute it and/or
+ *modify it under the terms of the GNU Lesser General Public
+ *License as published by the Free Software Foundation; either
+ *version 2.1 of the License, or (at your option) any later version.
+ *
+ *This library is distributed in the hope that it will be useful,
+ *but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *Lesser General Public License for more details.
+ *
+ *You should have received a copy of the GNU Lesser General Public
+ *License along with this library; if not, write to the Free Software
+ *Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "config.h"
+#include "wined3d_private.h"
+
+
+/* TODO: move to shared header (or context manager )*/
+/* x11drv GDI escapes */
+#define X11DRV_ESCAPE 6789
+enum x11drv_escape_codes
+{
+    X11DRV_GET_DISPLAY,   /* get X11 display for a DC */
+    X11DRV_GET_DRAWABLE,  /* get current drawable for a DC */
+    X11DRV_GET_FONT,      /* get current X font for a DC */
+};
+
+/* retrieve the X display to use on a given DC */
+inline static Display *get_display( HDC hdc )
+{
+    Display *display;
+    enum x11drv_escape_codes escape = X11DRV_GET_DISPLAY;
+
+    if (!ExtEscape( hdc, X11DRV_ESCAPE, sizeof(escape), (LPCSTR)&escape,
+                    sizeof(display), (LPSTR)&display )) display = NULL;
+    return display;
+}
+
+
+
+
+/*TODO: some of the additional parameters may be required to 
+    set the gamma ramp (for some weird reason microsoft have left swap gammaramp in device
+    but it operates on a swapchain, it may be a good idea to move it to IWineD3DSwapChain for IWineD3D)*/
+    
+    
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_fps);
+
+
+/* IDirect3DSwapChain IUnknown parts follow: */
+
+
+ULONG WINAPI IWineD3DSwapChainImpl_AddRef(IWineD3DSwapChain *iface) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    DWORD refCount = InterlockedIncrement(&This->ref);
+    TRACE("(%p) : AddRef increasing from %ld\n", This, refCount - 1);
+    return refCount;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_QueryInterface(IWineD3DSwapChain *iface, REFIID riid, LPVOID *ppobj)
+{
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    TRACE("(%p)->(%s,%p) \n",This,debugstr_guid(riid),ppobj);
+    if (IsEqualGUID(riid, &IID_IUnknown)
+        || IsEqualGUID(riid, &IID_IWineD3DSwapChain)){
+        IWineD3DSwapChainImpl_AddRef(iface);
+        if(ppobj == NULL){
+            ERR("Query interface called but now data allocated\n");
+            return E_NOINTERFACE;
+        }
+        *ppobj = This;
+        return D3D_OK;
+    }    
+    return E_NOINTERFACE;
+}
+
+
+ULONG WINAPI IWineD3DSwapChainImpl_Release(IWineD3DSwapChain *iface) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    DWORD refCount;    
+    refCount = InterlockedDecrement(&This->ref);
+    TRACE("(%p) : ReleaseRef to %ld\n", This, refCount);
+    if (refCount == 0) {
+        IUnknown* bufferParent;
+        IWineD3DSurface_GetParent(This->frontBuffer, &bufferParent);
+        IUnknown_Release(bufferParent); /* once for the get parent */
+        if(IUnknown_Release(bufferParent) > 0){
+            FIXME("(%p) Something's still holding the front buffer\n",This);
+        }
+
+        IWineD3DSurface_GetParent(This->backBuffer, &bufferParent);
+        IUnknown_Release(bufferParent); /* once for the get parent */
+        if(IUnknown_Release(bufferParent) > 0){
+            FIXME("(%p) Something's still holding the back buffer\n",This);
+        }
+        /* Clean up the context */
+        /* check that we are the current context first */
+        if(glXGetCurrentContext() == This->glCtx){
+            glXMakeCurrent(This->display, None, NULL);
+        }
+        glXDestroyContext(This->display, This->glCtx);
+        /* IUnknown_Release(This->parent); This should only apply to the primary swapchain,
+         all others are crated by the caller, so releasing the parent should cause
+         the child to be released, not the other way around!
+         */
+         /* TODO: notify the device that this swapchain doesn't exist any more */
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return refCount;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetParent(IWineD3DSwapChain *iface, IUnknown ** ppParent){
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    *ppParent = This->parent;
+    IUnknown_AddRef(*ppParent);
+    TRACE("(%p) returning %p\n", This , *ppParent);
+    return D3D_OK;
+}
+
+/*IWineD3DSwapChain parts follow: */
+HRESULT WINAPI IWineD3DSwapChainImpl_Present(IWineD3DSwapChain *iface, CONST RECT *pSourceRect, CONST RECT *pDestRect, HWND hDestWindowOverride, CONST RGNDATA *pDirtyRegion, DWORD dwFlags) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    
+    ENTER_GL();
+
+    if (pSourceRect || pDestRect) FIXME("Unhandled present options %p/%p\n", pSourceRect, pDestRect);
+    /* TODO: If only source rect or dest rect are supplied then clip the window to match */
+    TRACE("preseting display %p, drawable %ld\n", This->display, This->drawable);
+    
+    /* Don't call checkGLcall, as glGetError is not applicable here */
+    if (hDestWindowOverride && This->win_handle != hDestWindowOverride) {
+        /* Set this swapchain up to point to the new destination.. */
+            #ifdef USE_CONTEXT_MANAGER
+            /* TODO: use a context mamager */
+            #endif
+            
+            /* FIXME: Never access */
+            IWineD3DSwapChainImpl *swapChainImpl;
+            IWineD3DDevice_GetSwapChain((IWineD3DDevice *)This->wineD3DDevice, 0 , (IWineD3DSwapChain **)&swapChainImpl);
+            FIXME("Unable to render to a destination window %d\n", (int)hDestWindowOverride );
+            if(This == swapChainImpl){
+                /* FIXME: this will be fixed by moving to a context management system */
+                FIXME("Cannot change the target of the implicite swapchain\n");
+            }else{
+                HDC               hDc;
+                XVisualInfo       template;
+                int               num;
+                Display          *oldDisplay = This->display;
+                GLXContext        oldContext = This->glCtx;
+                IUnknown*         tmp;           
+                GLXContext        currentContext;
+                Drawable          currentDrawable;
+                hDc                          = GetDC(hDestWindowOverride);
+                This->win_handle             = hDestWindowOverride;            
+                This->win                    = (Window)GetPropA( hDestWindowOverride, "__wine_x11_whole_window" );
+
+                TRACE("Creating a new context for the window %p \n", hDestWindowOverride);
+                ENTER_GL();
+                TRACE("Desctroying context %p %p\n", This->display, This->render_ctx);
+
+
+
+                LEAVE_GL();
+                ENTER_GL();
+
+                This->display    = get_display(hDc);
+                TRACE("Got display%p  for  %p %p\n",  This->display, hDc, hDestWindowOverride);
+                ReleaseDC(hDestWindowOverride, hDc);
+                template.visualid = (VisualID)GetPropA(GetDesktopWindow(), "__wine_x11_visual_id");
+                This->visInfo   = XGetVisualInfo(This->display, VisualIDMask, &template, &num);
+                if (NULL == This->visInfo) {
+                    ERR("cannot really get XVisual\n"); 
+                    LEAVE_GL();
+                    return D3DERR_NOTAVAILABLE;
+                }
+                /* Now we have problems? well not really we just need to know what the implicite context is */
+                /* now destroy the old context and create a new one (we should really copy the buffers over, and do the whole make current thing! */
+                /* destroy the active context?*/
+                TRACE("Creating new context for %p %p %p\n",This->display, This->visInfo, swapChainImpl->glCtx);
+                This->glCtx = glXCreateContext(This->display, This->visInfo, swapChainImpl->glCtx, GL_TRUE);
+
+                if (NULL == This->glCtx) {
+                    ERR("cannot create glxContext\n"); 
+                }
+                This->drawable     = This->win;
+                This->render_ctx   = This->glCtx;
+                /* SEtup some default states TODO: apply the stateblock to the new context */
+                /** save current context and drawable **/
+                currentContext  =   glXGetCurrentContext();
+                currentDrawable =   glXGetCurrentDrawable();
+
+                if (glXMakeCurrent(This->display, This->win, This->glCtx) == False) {
+                    ERR("Error in setting current context (display %p context %p drawable %ld)!\n", This->display, This->glCtx, This->win);
+                }
+
+                checkGLcall("glXMakeCurrent");
+
+                /* Clear the screen */
+                glClearColor(0.0, 0.0, 0.0, 0.0);
+                checkGLcall("glClearColor");
+                glClearIndex(0);
+                glClearDepth(1);
+                glClearStencil(0);
+                
+                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+                checkGLcall("glClear");
+                
+                glColor3f(1.0, 1.0, 1.0);
+                checkGLcall("glColor3f");
+                
+                glEnable(GL_LIGHTING);
+                checkGLcall("glEnable");
+                
+                glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
+                checkGLcall("glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);");
+                
+                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);
+                checkGLcall("glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);");
+                
+                glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);
+                checkGLcall("glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);");
+                
+                /* If this swapchain is currently the active context then make this swapchain active */
+                if(IWineD3DSurface_GetContainer((IWineD3DSurface *)This->wineD3DDevice->renderTarget, &IID_IWineD3DSwapChain, (void **)&tmp) == D3D_OK){
+                    if(tmp != (IUnknown *)This){
+                        glXMakeCurrent(This->display, currentDrawable, currentContext);
+                        checkGLcall("glXMakeCurrent");
+                    }
+                    IUnknown_Release(tmp);
+                }else{
+                    /* reset the context */
+                    glXMakeCurrent(This->display, currentDrawable, currentContext);
+                    checkGLcall("glXMakeCurrent");                    
+                }
+                /* delete the old contxt*/
+                glXDestroyContext(oldDisplay, oldContext); /* Should this happen on an active context? seems a bad idea */
+                LEAVE_GL();
+            }
+            IWineD3DSwapChain_Release((IWineD3DSwapChain *)swapChainImpl);
+                
+        }
+            
+            
+        /* TODO: The slow way, save the data to memory, create a new context for the destination window, transfer the data cleanup, it may be a good idea to the move this swapchain over to the using the target winows context so that it runs faster in feature. */
+    
+    glXSwapBuffers(This->display, This->drawable); /* TODO: cycle through the swapchain buffers */
+    
+    TRACE("glXSwapBuffers called, Starting new frame\n");
+    /* FPS support */
+    if (TRACE_ON(d3d_fps))
+    {
+        static long prev_time, frames;
+
+        DWORD time = GetTickCount();
+        frames++;
+        /* every 1.5 seconds */
+        if (time - prev_time > 1500) {
+            TRACE_(d3d_fps)("@ approx %.2ffps\n", 1000.0*frames/(time - prev_time));
+            prev_time = time;
+            frames = 0;
+        }
+    }
+
+#if defined(FRAME_DEBUGGING)
+{
+    if (GetFileAttributesA("C:\\D3DTRACE") != INVALID_FILE_ATTRIBUTES) {
+        if (!isOn) {
+            isOn = TRUE;
+            FIXME("Enabling D3D Trace\n");
+            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 1);
+#if defined(SHOW_FRAME_MAKEUP)
+            FIXME("Singe Frame snapshots Starting\n");
+            isDumpingFrames = TRUE;
+            glClear(GL_COLOR_BUFFER_BIT);
+#endif
+
+#if defined(SINGLE_FRAME_DEBUGGING)
+        } else {
+#if defined(SHOW_FRAME_MAKEUP)
+            FIXME("Singe Frame snapshots Finishing\n");
+            isDumpingFrames = FALSE;
+#endif
+            FIXME("Singe Frame trace complete\n");
+            DeleteFileA("C:\\D3DTRACE");
+            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 0);
+#endif
+        }
+    } else {
+        if (isOn) {
+            isOn = FALSE;
+#if defined(SHOW_FRAME_MAKEUP)
+            FIXME("Single Frame snapshots Finishing\n");
+            isDumpingFrames = FALSE;
+#endif
+            FIXME("Disabling D3D Trace\n");
+            __WINE_SET_DEBUGGING(__WINE_DBCL_TRACE, __wine_dbch_d3d, 0);
+        }
+    }
+}
+#endif
+
+    LEAVE_GL();
+    /* Although this is not strictly required, a simple demo showed this does occur
+       on (at least non-debug) d3d                                                  */
+    if (This->presentParms.SwapEffect & D3DSWAPEFFECT_DISCARD) {
+    
+        TRACE("Clearing\n");     
+
+       IWineD3DDevice_Clear((IWineD3DDevice*)This->wineD3DDevice, 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_ZBUFFER|D3DCLEAR_TARGET, 0x00, 1.0, 0);
+
+    }
+        TRACE("returning\n");
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetFrontBufferData(IWineD3DSwapChain *iface, IWineD3DSurface *pDestSurface) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    IWineD3DSurfaceImpl *surface = (IWineD3DSurfaceImpl *)pDestSurface;
+    GLenum format;
+    GLenum type;
+    
+    TRACE("(%p) : iface(%p) pDestSurface(%p) \n", This, iface, pDestSurface);
+    ENTER_GL();
+
+    /* check to see if it's the backbuffer or the frontbuffer being requested (to make sureteh data is upto date) */
+    format = D3DFmt2GLFmt(This->wineD3DDevice, surface->resource.format);
+    type   = D3DFmt2GLType(This->wineD3DDevice, surface->resource.format);
+    glReadBuffer(GL_FRONT);
+    glReadPixels(0, 
+                0, 
+                surface->currentDesc.Width, 
+                surface->currentDesc.Height,
+                format, 
+                type, 
+                surface->resource.allocatedMemory);            
+    LEAVE_GL();
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetBackBuffer(IWineD3DSwapChain *iface, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IWineD3DSurface **ppBackBuffer) {
+
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;        
+    
+    *ppBackBuffer = (IWineD3DSurface *) This->backBuffer;
+    TRACE("(%p) : BackBuf %d Type %d  returning %p\n", This, iBackBuffer, Type, *ppBackBuffer);
+
+    if (iBackBuffer > This->presentParms.BackBufferCount - 1) {
+        FIXME("Only one backBuffer currently supported\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    /* Note inc ref on returned surface */
+    IWineD3DSurface_AddRef(*ppBackBuffer);    
+    return D3D_OK;
+    
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetRasterStatus(IWineD3DSwapChain *iface, D3DRASTER_STATUS*pRasterStatus) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;    
+    pRasterStatus->InVBlank = TRUE;
+    pRasterStatus->ScanLine = 0;
+    FIXME("(%p) : stub\n", This);
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetDisplayMode(IWineD3DSwapChain *iface, D3DDISPLAYMODE*pMode) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;        
+    HDC                 hdc;
+    int                 bpp = 0;
+
+    pMode->Width        = GetSystemMetrics(SM_CXSCREEN);
+    pMode->Height       = GetSystemMetrics(SM_CYSCREEN);
+    pMode->RefreshRate  = 85; /*FIXME: How to identify? */
+
+    hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
+    bpp = GetDeviceCaps(hdc, BITSPIXEL);
+    DeleteDC(hdc);
+
+    switch (bpp) {
+    case  8: pMode->Format       = D3DFMT_R8G8B8; break;
+    case 16: pMode->Format       = D3DFMT_R5G6B5; break;
+    case 24: /*pMode->Format       = D3DFMT_R8G8B8; break; */
+    case 32: pMode->Format       = D3DFMT_A8R8G8B8; break;
+    default: 
+       FIXME("Unrecognized display mode format\n");
+       pMode->Format       = D3DFMT_UNKNOWN;
+    }
+
+    TRACE("(%p) : returning w(%d) h(%d) rr(%d) fmt(%u,%s)\n", This, pMode->Width, pMode->Height, pMode->RefreshRate,
+    pMode->Format, debug_d3dformat(pMode->Format));
+    return D3D_OK;        
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetDevice(IWineD3DSwapChain *iface, IWineD3DDevice**ppDevice) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;  
+
+    *ppDevice = (IWineD3DDevice *) This->wineD3DDevice;
+
+    /* Note  Calling this method will increase the internal reference count 
+       on the IDirect3DDevice9 interface. */
+    IWineD3DDevice_AddRef(*ppDevice);
+    TRACE("(%p) : returning %p\n", This, *ppDevice);
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetPresentParameters(IWineD3DSwapChain *iface, D3DPRESENT_PARAMETERS *pPresentationParameters) {
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    FIXME("(%p) : copy\n", This); 
+    memcpy(pPresentationParameters, &This->presentParms, sizeof(D3DPRESENT_PARAMETERS));
+    return D3D_OK;
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_SetGammaRamp(IWineD3DSwapChain *iface, DWORD Flags, CONST D3DGAMMARAMP *pRamp){
+
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    HDC hDC;
+    TRACE("(%p) : pRamp@%p flags(%ld) \n", This, pRamp, Flags);
+    hDC = GetDC(This->win_handle);
+    SetDeviceGammaRamp(hDC, (LPVOID)pRamp);
+    ReleaseDC(This->win_handle, hDC);
+    return D3D_OK;
+    
+}
+
+HRESULT WINAPI IWineD3DSwapChainImpl_GetGammaRamp(IWineD3DSwapChain *iface, D3DGAMMARAMP *pRamp){
+
+    IWineD3DSwapChainImpl *This = (IWineD3DSwapChainImpl *)iface;
+    HDC hDC;
+    TRACE("(%p) : pRamp@%p\n", This, pRamp);
+    hDC = GetDC(This->win_handle);
+    GetDeviceGammaRamp(hDC, pRamp);
+    ReleaseDC(This->win_handle, hDC);
+    return D3D_OK;
+    
+}
+
+
+IWineD3DSwapChainVtbl IWineD3DSwapChain_Vtbl =
+{
+    IWineD3DSwapChainImpl_QueryInterface,
+    IWineD3DSwapChainImpl_AddRef,
+    IWineD3DSwapChainImpl_Release,
+    IWineD3DSwapChainImpl_GetParent,
+    IWineD3DSwapChainImpl_GetDevice,
+    IWineD3DSwapChainImpl_Present,
+    IWineD3DSwapChainImpl_GetFrontBufferData,
+    IWineD3DSwapChainImpl_GetBackBuffer,
+    IWineD3DSwapChainImpl_GetRasterStatus,
+    IWineD3DSwapChainImpl_GetDisplayMode,
+    IWineD3DSwapChainImpl_GetPresentParameters,
+    IWineD3DSwapChainImpl_SetGammaRamp,
+    IWineD3DSwapChainImpl_GetGammaRamp 
+};
diff -urN wine.20050419/dlls/wined3d/texture.c wine.20050419.dx9/dlls/wined3d/texture.c
--- wine.20050419/dlls/wined3d/texture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/texture.c	2005-04-20 04:42:58.000000000 -0600
@@ -23,7 +23,9 @@
 #include "config.h"
 #include "wined3d_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DEFAULT_DEBUG_CHANNEL(d3d_texture);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_ref);
+/*TODO: replace impl usage with iface usage */
 #define GLINFO_LOCATION ((IWineD3DImpl *)(((IWineD3DDeviceImpl *)This->resource.wineD3DDevice)->wineD3D))->gl_info
 
 /* *******************************************
@@ -46,9 +48,9 @@
 
 ULONG WINAPI IWineD3DTextureImpl_AddRef(IWineD3DTexture *iface) {
     IWineD3DTextureImpl *This = (IWineD3DTextureImpl *)iface;
-    TRACE("(%p) : AddRef increasing from %ld\n", This, This->resource.ref);
-    IUnknown_AddRef(This->resource.parent);
-    return InterlockedIncrement(&This->resource.ref);
+    ULONG ref = InterlockedIncrement(&This->resource.ref);
+    TRACE_(d3d_ref)( "(%p) : AddRef increasing from %ld to %ld\n", This, ref - 1, ref);
+    return ref;
 }
 
 ULONG WINAPI IWineD3DTextureImpl_Release(IWineD3DTexture *iface) {
@@ -57,6 +59,7 @@
     TRACE("(%p) : Releasing from %ld\n", This, This->resource.ref);
     ref = InterlockedDecrement(&This->resource.ref);
     if (ref == 0) {
+        int texturecount = globalStoreReleaseTexture((IWineD3DBaseTexture *)This);
         int i;
         for (i = 0; i < This->baseTexture.levels; i++) {
             if (This->surfaces[i] != NULL) {
@@ -108,7 +111,7 @@
     unsigned int i;
     IWineD3DTextureImpl *This = (IWineD3DTextureImpl *)iface;
     
-    TRACE("(%p) : About to load texture\n", This);
+    TRACE("(%p) : About to load texture %p\n", This, This->surfaces);
     IWineD3DTexture_BindTexture(iface);
     
     ENTER_GL();
@@ -163,7 +166,7 @@
 
 /* Internal function, No d3d mapping */
 BOOL WINAPI IWineD3DTextureImpl_SetDirty(IWineD3DTexture *iface, BOOL dirty) {
-    return IWineD3DBaseTextureImpl_SetDirty((IWineD3DBaseTexture *)iface, TRUE);
+    return IWineD3DBaseTextureImpl_SetDirty((IWineD3DBaseTexture *)iface,dirty);
 }
 
 BOOL WINAPI IWineD3DTextureImpl_GetDirty(IWineD3DTexture *iface) {
@@ -198,7 +201,7 @@
 
     if (Level < This->baseTexture.levels) {
         TRACE("(%p) Level (%d)\n", This, Level);
-        return IWineD3DSurface_GetDesc((IWineD3DSurface *) This->surfaces[Level], pDesc);
+        return IWineD3DSurface_GetDesc(This->surfaces[Level], pDesc);
     }
     FIXME("(%p) level(%d) overflow Levels(%d)\n", This, Level, This->baseTexture.levels);
     return D3DERR_INVALIDCALL;
@@ -206,11 +209,17 @@
 
 HRESULT WINAPI IWineD3DTextureImpl_GetSurfaceLevel(IWineD3DTexture *iface, UINT Level, IWineD3DSurface** ppSurfaceLevel) {
     IWineD3DTextureImpl *This = (IWineD3DTextureImpl *)iface;
-    *ppSurfaceLevel = (IWineD3DSurface *) This->surfaces[Level];
+
+    if (Level < This->baseTexture.levels) {
+        *ppSurfaceLevel = This->surfaces[Level];
     IWineD3DSurface_AddRef((IWineD3DSurface *) This->surfaces[Level]);
     TRACE("(%p) : returning %p for level %d\n", This, *ppSurfaceLevel, Level);
     return D3D_OK;
 }
+    FIXME("(%p) level(%d) overflow Levels(%d)\n", This, Level, This->baseTexture.levels);
+    *ppSurfaceLevel = NULL; /* Just to be on the safe side.. */
+    return D3DERR_INVALIDCALL;
+}
 
 HRESULT WINAPI IWineD3DTextureImpl_LockRect(IWineD3DTexture *iface, UINT Level, D3DLOCKED_RECT *pLockedRect, 
                                             CONST RECT *pRect, DWORD Flags) {
@@ -219,7 +228,7 @@
 
     if (Level < This->baseTexture.levels) {
 
-        hr = IWineD3DSurface_LockRect((IWineD3DSurface *) This->surfaces[Level], pLockedRect, pRect, Flags);
+        hr = IWineD3DSurface_LockRect(This->surfaces[Level], pLockedRect, pRect, Flags);
         TRACE("(%p) Level (%d) success(%lu)\n", This, Level, hr);
     } else {
         FIXME("(%p) level(%d) overflow Levels(%d)\n", This, Level, This->baseTexture.levels);
@@ -233,7 +242,7 @@
     IWineD3DTextureImpl *This = (IWineD3DTextureImpl *)iface;
 
     if (Level < This->baseTexture.levels) {
-        hr = IWineD3DSurface_UnlockRect((IWineD3DSurface *) This->surfaces[Level]);
+        hr = IWineD3DSurface_UnlockRect(This->surfaces[Level]);
         TRACE("(%p) Level (%d) success(%lu)\n", This, Level, hr);
     } else {
         FIXME("(%p) level(%d) overflow Levels(%d)\n", This, Level, This->baseTexture.levels);
@@ -246,7 +255,7 @@
     IWineD3DTextureImpl *This = (IWineD3DTextureImpl *)iface;
     This->baseTexture.dirty = TRUE;
     TRACE("(%p) : dirtyfication of surface Level (0)\n", This);    
-    return IWineD3DSurface_AddDirtyRect((IWineD3DSurface *)This->surfaces[0], pDirtyRect);
+    return IWineD3DSurface_AddDirtyRect(This->surfaces[0], pDirtyRect);
 }
 
 IWineD3DTextureVtbl IWineD3DTexture_Vtbl =
diff -urN wine.20050419/dlls/wined3d/utils.c wine.20050419.dx9/dlls/wined3d/utils.c
--- wine.20050419/dlls/wined3d/utils.c	2005-03-03 06:57:15.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/utils.c	2005-04-20 01:52:56.000000000 -0600
@@ -233,8 +233,8 @@
     D3DSTATE_TO_STR(WINED3DRS_COLORWRITEENABLE          );
     D3DSTATE_TO_STR(WINED3DRS_TWEENFACTOR               );
     D3DSTATE_TO_STR(WINED3DRS_BLENDOP                   );
-    D3DSTATE_TO_STR(WINED3DRS_POSITIONORDER             );
-    D3DSTATE_TO_STR(WINED3DRS_NORMALORDER               );
+    D3DSTATE_TO_STR(WINED3DRS_POSITIONDEGREE            );
+    D3DSTATE_TO_STR(WINED3DRS_NORMALDEGREE              );
 #undef D3DSTATE_TO_STR
   default:
     FIXME("Unrecognized %lu render state!\n", state);
@@ -256,6 +256,7 @@
     D3DSTATE_TO_STR(D3DTSS_BUMPENVMAT10          );
     D3DSTATE_TO_STR(D3DTSS_BUMPENVMAT11          );
     D3DSTATE_TO_STR(D3DTSS_TEXCOORDINDEX         );
+    #if 0 /*FIXME: d3d8*/
     D3DSTATE_TO_STR(D3DTSS_ADDRESSU              );
     D3DSTATE_TO_STR(D3DTSS_ADDRESSV              );
     D3DSTATE_TO_STR(D3DTSS_BORDERCOLOR           );
@@ -265,6 +266,7 @@
     D3DSTATE_TO_STR(D3DTSS_MIPMAPLODBIAS         );
     D3DSTATE_TO_STR(D3DTSS_MAXMIPLEVEL           );
     D3DSTATE_TO_STR(D3DTSS_MAXANISOTROPY         );
+    #endif
     D3DSTATE_TO_STR(D3DTSS_BUMPENVLSCALE         );
     D3DSTATE_TO_STR(D3DTSS_BUMPENVLOFFSET        );
     D3DSTATE_TO_STR(D3DTSS_TEXTURETRANSFORMFLAGS );
@@ -1564,8 +1566,8 @@
     if (retVal == 0) {
         switch (fmt) {
         /* Paletted */
-        case WINED3DFMT_P8:               retVal = GL_COLOR_INDEX8_EXT; break;
-        case WINED3DFMT_A8P8:             retVal = GL_COLOR_INDEX8_EXT; break;
+        case WINED3DFMT_P8:               retVal = GL_COLOR_INDEX; break;
+        case WINED3DFMT_A8P8:             retVal = GL_COLOR_INDEX; break;
             /* Luminance */
         case WINED3DFMT_L8:               retVal = GL_LUMINANCE8; break;
         case WINED3DFMT_A8L8:             retVal = GL_LUMINANCE8_ALPHA8; break;
@@ -1580,11 +1582,11 @@
         case WINED3DFMT_R5G6B5:           retVal = GL_RGB5; break; /* fixme: internal format 6 for g? */
         case WINED3DFMT_R8G8B8:           retVal = GL_RGB8; break;
         case WINED3DFMT_A1R5G5B5:         retVal = GL_RGB5_A1; break;
-        case WINED3DFMT_X1R5G5B5:         retVal = GL_RGB5_A1; break;
+        case WINED3DFMT_X1R5G5B5:         retVal = GL_RGB5; break;
         case WINED3DFMT_A4R4G4B4:         retVal = GL_RGBA4; break;
         case WINED3DFMT_X4R4G4B4:         retVal = GL_RGBA4; break;
         case WINED3DFMT_A8R8G8B8:         retVal = GL_RGBA8; break;
-        case WINED3DFMT_X8R8G8B8:         retVal = GL_RGBA8; break;
+        case WINED3DFMT_X8R8G8B8:         retVal = GL_RGB; break;
             /* to see */
         case WINED3DFMT_A8:               retVal = GL_ALPHA8; break;
         default:
@@ -1592,6 +1594,7 @@
             retVal = GL_RGB8;
         }
     }
+
     TRACE("fmt2glintFmt for fmt(%u,%s) = %x\n", fmt, debug_d3dformat(fmt), retVal);
     return retVal;
 }
@@ -1624,7 +1627,7 @@
         case WINED3DFMT_V16U16:           retVal = GL_COLOR_INDEX; break;
         case WINED3DFMT_L6V5U5:           retVal = GL_COLOR_INDEX; break;
         case WINED3DFMT_X8L8V8U8:         retVal = GL_COLOR_INDEX; break;
-            /* color buffer */
+            /* Color buffer */
         case WINED3DFMT_R3G3B2:           retVal = GL_BGR; break;
         case WINED3DFMT_R5G6B5:           retVal = GL_RGB; break;
         case WINED3DFMT_R8G8B8:           retVal = GL_RGB; break;
@@ -1666,8 +1669,8 @@
         case WINED3DFMT_P8:               retVal = GL_UNSIGNED_BYTE; break;
         case WINED3DFMT_A8P8:             retVal = GL_UNSIGNED_BYTE; break;
             /* Luminance */
-        case WINED3DFMT_L8:               retVal = GL_UNSIGNED_BYTE; break;
-        case WINED3DFMT_A8L8:             retVal = GL_UNSIGNED_BYTE; break;
+        case WINED3DFMT_L8:               retVal = GL_UNSIGNED_BYTE; break;/*Does openGL support luminance and UNSIGNED_BYTE? */
+        case WINED3DFMT_A8L8:             retVal = GL_UNSIGNED_BYTE; break;/*  I thought it had to be a float */
         case WINED3DFMT_A4L4:             retVal = GL_UNSIGNED_BYTE; break;
             /* Bump */
         case WINED3DFMT_V8U8:             retVal = GL_UNSIGNED_BYTE; break;
@@ -1687,6 +1690,7 @@
             /* to see */
         case WINED3DFMT_A8:               retVal = GL_ALPHA; break;
         default:
+           
             FIXME("Unhandled fmt(%u,%s)\n", fmt, debug_d3dformat(fmt));
             retVal = GL_UNSIGNED_BYTE;
         }
@@ -1700,7 +1704,7 @@
     SHORT retVal;
 
     switch (fmt) {
-    /* color buffer */
+        /* Color buffer */
     case WINED3DFMT_R3G3B2:           retVal = 1; break;
     case WINED3DFMT_R5G6B5:           retVal = 2; break;
     case WINED3DFMT_R8G8B8:           retVal = 3; break;
@@ -1713,7 +1717,7 @@
         /* Paletted */
     case WINED3DFMT_P8:               retVal = 1; break;
     case WINED3DFMT_A8P8:             retVal = 2; break;
-        /* depth/stencil buffer */
+        /* Depth/stencil buffer */
     case WINED3DFMT_D16_LOCKABLE:     retVal = 2; break;
     case WINED3DFMT_D16:              retVal = 2; break;
     case WINED3DFMT_D32:              retVal = 4; break;
@@ -1750,4 +1754,140 @@
     TRACE("bytes/Pxl for fmt(%u,%s) = %d\n", fmt, debug_d3dformat(fmt), retVal);
     return retVal;
 }
+/*Convertes a D3D format into a OPenGL configuration format*/
+int D3DFmtMakeGlCfg(D3DFORMAT BackBufferFormat, D3DFORMAT StencilBufferFormat, int *attribs, int* nAttribs, BOOL alternate){
+    #define PUSH1(att)        attribs[(*nAttribs)++] = (att); 
+    #define PUSH2(att,value)  attribs[(*nAttribs)++] = (att); attribs[(*nAttribs)++] = (value);
+    /*We need to do some Card specific stuff in here at some point, 
+    D3D now support floating point format buffers, and their are a number of different OpelGl ways on managing thease e.g.
+    GLX_ATI_pixel_format_float    
+    */
+    switch (BackBufferFormat) {
+        /* color buffer */
+    case WINED3DFMT_P8:
+        PUSH2(GLX_RENDER_TYPE,  GLX_COLOR_INDEX_BIT);
+        PUSH2(GLX_BUFFER_SIZE,  8);
+        PUSH2(GLX_DOUBLEBUFFER, TRUE);
+        break;
+        
+    case WINED3DFMT_R3G3B2:
+        PUSH2(GLX_RENDER_TYPE,  GLX_RGBA_BIT);
+        PUSH2(GLX_RED_SIZE,     3);
+        PUSH2(GLX_GREEN_SIZE,   3);
+        PUSH2(GLX_BLUE_SIZE,    2);
+        break;
+        
+    case WINED3DFMT_A1R5G5B5:
+        PUSH2(GLX_ALPHA_SIZE,   1);
+    case WINED3DFMT_X1R5G5B5:
+        PUSH2(GLX_RED_SIZE,     5);
+        PUSH2(GLX_GREEN_SIZE,   5);
+        PUSH2(GLX_BLUE_SIZE,    5);
+        break;
+        
+    case WINED3DFMT_R5G6B5:
+        PUSH2(GLX_RED_SIZE,     5);
+        PUSH2(GLX_GREEN_SIZE,   6);
+        PUSH2(GLX_BLUE_SIZE,    5);
+        break;
+        
+    case WINED3DFMT_A4R4G4B4:
+        PUSH2(GLX_ALPHA_SIZE,   4);
+    case WINED3DFMT_X4R4G4B4:
+        PUSH2(GLX_RED_SIZE,     4);
+        PUSH2(GLX_GREEN_SIZE,   4);
+        PUSH2(GLX_BLUE_SIZE,    4);
+        break;
+        
+    case WINED3DFMT_A8R8G8B8:
+        PUSH2(GLX_ALPHA_SIZE,   8);
+    case WINED3DFMT_R8G8B8:
+    case WINED3DFMT_X8R8G8B8:
+        PUSH2(GLX_RED_SIZE,     8);
+        PUSH2(GLX_GREEN_SIZE,   8);
+        PUSH2(GLX_BLUE_SIZE,    8);
+        break;
+        
+    default:
+        break;
+    }
+    if(!alternate){
+        switch (StencilBufferFormat) { 
+    case WINED3DFMT_D16_LOCKABLE:
+    case WINED3DFMT_D16:
+        PUSH2(GLX_DEPTH_SIZE,   16);
+        break;
+        
+    case WINED3DFMT_D15S1:
+        PUSH2(GLX_DEPTH_SIZE,   15);
+        PUSH2(GLX_STENCIL_SIZE, 1);
+        /*Does openGl support a 1bit stencil?, I've seen it used elsewhere 
+        e.g. http://www.ks.uiuc.edu/Research/vmd/doxygen/OpenGLDisplayDevice_8C-source.html*/
+        break;
+        
+    case WINED3DFMT_D24X8:
+        PUSH2(GLX_DEPTH_SIZE,   24);
+        break;
+        
+    case WINED3DFMT_D24X4S4:
+        PUSH2(GLX_DEPTH_SIZE,   24);
+        PUSH2(GLX_STENCIL_SIZE, 4);
+        break;
+        
+    case WINED3DFMT_D24S8:
+        PUSH2(GLX_DEPTH_SIZE,   24);
+        PUSH2(GLX_STENCIL_SIZE, 8);
+        break;
+        
+    case WINED3DFMT_D32:
+        PUSH2(GLX_DEPTH_SIZE,   32);
+        break;
+    
+    default:
+        break;
+    }
+
+    }else{ /* it the device doesn't support the 'exact' format, try something close */
+        switch (StencilBufferFormat) { 
+    case WINED3DFMT_D16_LOCKABLE:
+    case WINED3DFMT_D16:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        break;
+        
+    case WINED3DFMT_D15S1:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        PUSH2(GLX_STENCIL_SIZE, 1);
+        /*Does openGl support a 1bit stencil?, I've seen it used elsewhere 
+        e.g. http://www.ks.uiuc.edu/Research/vmd/doxygen/OpenGLDisplayDevice_8C-source.html*/
+        break;
+        
+    case WINED3DFMT_D24X8:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        break;
+        
+    case WINED3DFMT_D24X4S4:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        PUSH2(GLX_STENCIL_SIZE, 1);
+        break;
+        
+    case WINED3DFMT_D24S8:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        PUSH2(GLX_STENCIL_SIZE, 1);
+        break;
+        
+    case WINED3DFMT_D32:
+        PUSH2(GLX_DEPTH_SIZE,   1);
+        break;
+    
+    default:
+        break;
+    }
+
+    
+    }
+    
+    return *nAttribs;
+}
+
 #undef GLINFO_LOCATION
+
diff -urN wine.20050419/dlls/wined3d/vertexbuffer.c wine.20050419.dx9/dlls/wined3d/vertexbuffer.c
--- wine.20050419/dlls/wined3d/vertexbuffer.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/vertexbuffer.c	2005-04-20 04:05:16.000000000 -0600
@@ -4,6 +4,7 @@
  * Copyright 2002-2004 Jason Edmeades
  * Copyright 2003-2004 Raphael Junqueira
  * Copyright 2004 Christian Costa
+ * Copyright 2005 Oliver Stieber
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -24,6 +25,7 @@
 #include "wined3d_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_ref);
 #define GLINFO_LOCATION ((IWineD3DImpl *)(((IWineD3DDeviceImpl *)This->resource.wineD3DDevice)->wineD3D))->gl_info
 
 /* *******************************************
@@ -103,18 +105,44 @@
 /* ******************************************************
    IWineD3DVertexBuffer IWineD3DVertexBuffer parts follow
    ****************************************************** */
+/* We should be using ARB_Vertex_Buffer_Objects for vertex buffers
+see..
+http://steinsoft.net/index.php?site=Programming/Code%20Snippets/OpenGL/no11
+
+http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_buffer_object.txt
+
+http://oss.sgi.com/projects/ogl-sample/registry/EXT/compiled_vertex_array.txt
+(GL_EXT_compiled_vertex_array is very simila)
+
+
+http://jdobry.webpark.cz/opengl/opengl_maximum_performance.html
+*/
 HRESULT  WINAPI        IWineD3DVertexBufferImpl_Lock(IWineD3DVertexBuffer *iface, UINT OffsetToLock, UINT SizeToLock, BYTE** ppbData, DWORD Flags) {
     IWineD3DVertexBufferImpl *This = (IWineD3DVertexBufferImpl *)iface;
-    TRACE("(%p) : returning memory of %p (base:%p,offset:%u)\n", This, This->resource.allocatedMemory + OffsetToLock, This->resource.allocatedMemory, OffsetToLock);
+    TRACE("(%p) : returning memory of %p (base:%p,offset:%u, SizeToLock%u flags%ld)\n",
+    This, This->resource.allocatedMemory + OffsetToLock, This->resource.allocatedMemory, OffsetToLock, SizeToLock,  Flags);
     /* TODO: check Flags compatibility with This->currentDesc.Usage (see MSDN) */
+
+    #if 0   /* TODO: EXT_compiled_vertex_array  */
+    void UnlockArraysEXT (void)  
+    #endif
     *ppbData = This->resource.allocatedMemory + OffsetToLock;
+
     return D3D_OK;
 }
 HRESULT  WINAPI        IWineD3DVertexBufferImpl_Unlock(IWineD3DVertexBuffer *iface) {
     IWineD3DVertexBufferImpl *This = (IWineD3DVertexBufferImpl *)iface;
+
+      #if 0   /* TODO: EXT_compiled_vertex_array
+                   It looks like opengl lock may be differnt from D3D lock, inthat a lock prevents access instead of granting it
+               */
+          void LockArraysEXT (begining, all)
+       #endif
     TRACE("(%p) : stub\n", This);
     return D3D_OK;
 }
+
+
 HRESULT  WINAPI        IWineD3DVertexBufferImpl_GetDesc(IWineD3DVertexBuffer *iface, D3DVERTEXBUFFER_DESC *pDesc) {
     IWineD3DVertexBufferImpl *This = (IWineD3DVertexBufferImpl *)iface;
 
diff -urN wine.20050419/dlls/wined3d/vertexdeclaration.c wine.20050419.dx9/dlls/wined3d/vertexdeclaration.c
--- wine.20050419/dlls/wined3d/vertexdeclaration.c	2005-03-02 06:44:58.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/vertexdeclaration.c	2005-04-20 01:52:56.000000000 -0600
@@ -769,7 +769,7 @@
     TRACE("(%p) : Releasing from %ld\n", This, This->ref);
     ref = InterlockedDecrement(&This->ref);
     if (ref == 0) {
-      HeapFree(GetProcessHeap(), 0, This->pDeclaration8);
+      /*HeapFree(GetProcessHeap(), 0, This->pDeclaration8);*/
       HeapFree(GetProcessHeap(), 0, This->pDeclaration9);
       HeapFree(GetProcessHeap(), 0, This);
     }
@@ -780,6 +780,15 @@
    IWineD3DVertexDeclaration parts follow
    ******************************************* */
 
+HRESULT WINAPI IWineD3DVertexDeclarationImpl_GetParent(IWineD3DVertexDeclaration *iface, IUnknown** parent){
+    IWineD3DVertexDeclarationImpl *This = (IWineD3DVertexDeclarationImpl *)iface;
+    
+    *parent= (IUnknown*) parent;
+    IUnknown_AddRef(*parent);
+    TRACE("(%p) : returning %p\n", This, *parent);
+    return D3D_OK;
+}
+
 HRESULT WINAPI IWineD3DVertexDeclarationImpl_GetDevice(IWineD3DVertexDeclaration *iface, IWineD3DDevice** ppDevice) {
     IWineD3DVertexDeclarationImpl *This = (IWineD3DVertexDeclarationImpl *)iface;
     TRACE("(%p) : returning %p\n", This, This->wineD3DDevice);
@@ -832,6 +841,7 @@
     IWineD3DVertexDeclarationImpl_QueryInterface,
     IWineD3DVertexDeclarationImpl_AddRef,
     IWineD3DVertexDeclarationImpl_Release,
+    IWineD3DVertexDeclarationImpl_GetParent,
     IWineD3DVertexDeclarationImpl_GetDevice,
     IWineD3DVertexDeclarationImpl_GetDeclaration,
 };
diff -urN wine.20050419/dlls/wined3d/vertexshader.c wine.20050419.dx9/dlls/wined3d/vertexshader.c
--- wine.20050419/dlls/wined3d/vertexshader.c	2005-03-02 05:16:11.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/vertexshader.c	2005-04-20 01:52:56.000000000 -0600
@@ -847,6 +847,72 @@
     return D3D_OK;
 }
 
+inline static VOID IWineD3DVertexShaderImpl_ParseProgram(IWineD3DVertexShaderImpl* vshader, CONST DWORD* pFunction, int useHW) {
+  const DWORD* pToken = pFunction;
+  const SHADER_OPCODE* curOpcode = NULL;
+  DWORD len = 0;  
+  DWORD i;
+
+  if (NULL != pToken) {
+    while (D3DVS_END() != *pToken) {
+      if (vshader_is_version_token(*pToken)) { /** version */
+    TRACE("vs.%lu.%lu\n", (*pToken >> 8) & 0x0F, (*pToken & 0x0F));
+    ++pToken;
+    ++len;
+    continue;
+      } 
+      if (vshader_is_comment_token(*pToken)) { /** comment */
+    DWORD comment_len = (*pToken & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
+    ++pToken;
+    /*TRACE("comment[%ld] ;%s\n", comment_len, (char*)pToken);*/
+    pToken += comment_len;
+    len += comment_len + 1;
+    continue;
+      }
+      curOpcode = vshader_program_get_opcode(*pToken);
+      ++pToken;
+      ++len;
+      if (NULL == curOpcode) {
+    /* unkown current opcode ... */
+    while (*pToken & 0x80000000) {
+      TRACE("unrecognized opcode: %08lx\n", *pToken);
+      ++pToken;
+      ++len;
+    }
+      } else {
+    TRACE("%s ", curOpcode->name);
+    if (curOpcode->num_params > 0) {
+      vshader_program_dump_param(*pToken, 0);
+      ++pToken;
+      ++len;
+      for (i = 1; i < curOpcode->num_params; ++i) {
+        TRACE(", ");
+        vshader_program_dump_param(*pToken, 1);
+        ++pToken;
+        ++len;
+      }
+    }
+    TRACE("\n");
+      }
+    }
+    vshader->functionLength = (len + 1) * sizeof(DWORD);
+  } else {
+    vshader->functionLength = 1; /* no Function defined use fixed function vertex processing */
+  }
+
+  /* Generate HW shader in needed */
+  if (useHW && NULL != pFunction) {
+    IWineD3DVertexShaderImpl_GenerateProgramArbHW(vshader, pFunction);
+  }
+
+  /* copy the function ... because it will certainly be released by application */
+  if (NULL != pFunction) {
+    vshader->function = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, vshader->functionLength);
+    memcpy(vshader->function, pFunction, vshader->functionLength);
+  } else {
+    vshader->function = NULL;
+  }
+}
 #endif
 
 /* *******************************************
@@ -855,7 +921,13 @@
 HRESULT WINAPI IWineD3DVertexShaderImpl_QueryInterface(IWineD3DVertexShader *iface, REFIID riid, LPVOID *ppobj)
 {
     IWineD3DVertexShaderImpl *This = (IWineD3DVertexShaderImpl *)iface;
-    FIXME("(%p) :stub\n",This);
+    TRACE("(%p)->(%s,%p)\n",This,debugstr_guid(riid),ppobj);
+    if (IsEqualGUID(riid, &IID_IUnknown) 
+        || IsEqualGUID(riid, &IID_IWineD3DVertexShader)) {
+        IUnknown_AddRef(iface);
+        *ppobj = This;
+        return D3D_OK;
+    }
     return E_NOINTERFACE;
 }
 
diff -urN wine.20050419/dlls/wined3d/volumetexture.c wine.20050419.dx9/dlls/wined3d/volumetexture.c
--- wine.20050419/dlls/wined3d/volumetexture.c	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/volumetexture.c	2005-04-20 01:52:56.000000000 -0600
@@ -214,12 +214,14 @@
 HRESULT WINAPI IWineD3DVolumeTextureImpl_LockBox(IWineD3DVolumeTexture *iface, UINT Level, D3DLOCKED_BOX* pLockedVolume, CONST D3DBOX* pBox, DWORD Flags) {
     HRESULT hr;
     IWineD3DVolumeTextureImpl *This = (IWineD3DVolumeTextureImpl *)iface;
-
+    FIXME("hello\n");
     if (Level < This->baseTexture.levels) {
+      FIXME("hello volume lockbox\n");
       hr = IWineD3DVolume_LockBox((IWineD3DVolume *)This->volumes[Level], pLockedVolume, pBox, Flags);
       TRACE("(%p) Level (%d) success(%lu)\n", This, Level, hr);
 
     } else {
+    FIXME("hello not doing volume lockbox\n");
       FIXME("(%p) level(%d) overflow Levels(%d)\n", This, Level, This->baseTexture.levels);
       return D3DERR_INVALIDCALL;
     }
diff -urN wine.20050419/dlls/wined3d/wined3d_main.c wine.20050419.dx9/dlls/wined3d/wined3d_main.c
--- wine.20050419/dlls/wined3d/wined3d_main.c	2005-03-02 06:44:58.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/wined3d_main.c	2005-04-20 01:52:56.000000000 -0600
@@ -33,6 +33,177 @@
 int vs_mode = VS_HW;   /* Hardware by default */
 int ps_mode = PS_NONE; /* Disabled by default */
 
+WineD3DGlobalStatistics *wineD3DGlobalStatistics = NULL;
+
+
+CRITICAL_SECTION textureStoreCriticalSection;
+
+int globalStoreTexture(IWineD3DBaseTexture *texture){
+    TextureChain* textureChain;
+    int result = -1;
+    if(wineD3DGlobalStatistics== NULL){
+        WARN("Attempting to add a texture to the global store, but there is no global store\n");
+        return result;
+    }
+    EnterCriticalSection(&textureStoreCriticalSection);
+    /* add a new texture to the frot of the linked list */
+    textureChain = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TextureChain));
+    textureChain->texture = texture;
+
+    /* Get the old head */
+    textureChain->next = wineD3DGlobalStatistics->textures;
+    
+    wineD3DGlobalStatistics->textures = textureChain;
+    result = ++wineD3DGlobalStatistics->textureCount;
+    TRACE("Added texture (%d) %p with element %p pointing to %p\n", result, texture, textureChain, textureChain->next);
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+}
+
+long globalChangeGlRam(long glram){
+    /* FIXME: replace this function with object tracking */
+    int result;
+
+    EnterCriticalSection(&textureStoreCriticalSection); /* this is overkill really, but I suppose it should be thread safe */
+    wineD3DGlobalStatistics->glsurfaceram     += glram;
+    wineD3DGlobalStatistics->totalsurfaceram  += glram;
+    TRACE("Adjusted gl ram by %ld to %d\n", glram, wineD3DGlobalStatistics->glsurfaceram);
+    result = wineD3DGlobalStatistics->glsurfaceram;
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+    
+}
+
+long globalChangeSysRam(long sysram){
+    int result;
+    EnterCriticalSection(&textureStoreCriticalSection);
+
+    wineD3DGlobalStatistics->systemsurfaceram += sysram;
+    wineD3DGlobalStatistics->totalsurfaceram  += sysram;
+    result = wineD3DGlobalStatistics->glsurfaceram;
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+    
+}
+
+int globalStoreReleaseTexture(IWineD3DBaseTexture *texture){
+
+    int result;
+    int i;
+    TextureChain* textureChain = NULL;
+    TextureChain* previousTextureChain = NULL;
+
+    TRACE("Releasing texture %p\n", texture);    
+    if(wineD3DGlobalStatistics== NULL){
+        WARN("Attempting to add a texture to the global store, but there is no global store\n");
+        return -1;
+    }
+    
+    EnterCriticalSection(&textureStoreCriticalSection);
+    textureChain = wineD3DGlobalStatistics->textures;
+    /* I could keep a hash table to speed things up a bit (or keep the linked list sorted?) */
+    
+    for(i = 0 ; i<wineD3DGlobalStatistics->textureCount ; i++){
+        if(textureChain == NULL) break;
+        if(textureChain->texture == texture) break;
+        previousTextureChain = textureChain;        
+        textureChain = textureChain->next;
+    }
+    
+    if(textureChain == NULL){
+        FIXME("Attempted to remove texture %p that hasn't been stored\n", texture);
+        LeaveCriticalSection(&textureStoreCriticalSection);
+        result = wineD3DGlobalStatistics->textureCount;
+        return result;
+    }else{
+            TRACE("Found texture (%d) %p with element %p pointing to %p (previous %p)\n", i, textureChain->texture, textureChain, textureChain->next, previousTextureChain);
+    }
+    /* make sure we don't leave a hole in the list */
+    if(previousTextureChain != NULL){
+        previousTextureChain->next = textureChain->next;
+    }else{
+        wineD3DGlobalStatistics->textures = textureChain->next;
+    }
+
+    result = wineD3DGlobalStatistics->textureCount--;
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+}
+
+
+int globalStoreSurface(IWineD3DSurface *surface){
+    int result = -1;
+    SurfaceChain* surfaceChain;
+    
+    if(wineD3DGlobalStatistics== NULL){
+        WARN("Attempting to add a surface to the global store, but there is no global store\n");
+        return result;
+    }
+    EnterCriticalSection(&textureStoreCriticalSection);
+
+    /* add a new texture to the frot of the linked list */
+    surfaceChain = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SurfaceChain));
+    surfaceChain->surface = surface;
+
+    /* Get the old head */
+    surfaceChain->next = wineD3DGlobalStatistics->surfaces;
+    
+    wineD3DGlobalStatistics->surfaces = surfaceChain;
+    result = ++wineD3DGlobalStatistics->surfaceCount;
+    TRACE("Added surface (%d) %p with element %p pointing to %p\n", result, surface, surfaceChain, surfaceChain->next);
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+
+}
+
+int globalStoreReleaseSurface(IWineD3DSurface *surface){
+    
+    int result = -1;
+    int i;
+    SurfaceChain* surfaceChain = NULL;
+    SurfaceChain* previousSurfaceChain = NULL;
+
+    TRACE("Releasing surface %p\n", surface);
+    if(wineD3DGlobalStatistics== NULL){
+        WARN("Attempting to add a surface to the global store, but there is no global store\n");
+        return result;
+    }
+    
+    EnterCriticalSection(&textureStoreCriticalSection);
+    
+    surfaceChain = wineD3DGlobalStatistics->surfaces;
+    /* I could keep a hash table to speed things up a bit (or keep the linked list sorted?) */
+    
+    for(i = 0 ; i<wineD3DGlobalStatistics->surfaceCount ; i++){
+        if(surfaceChain == NULL) break;
+        if(surfaceChain->surface == surface) break;
+        previousSurfaceChain = surfaceChain;
+        surfaceChain = surfaceChain->next;
+    }
+    
+    if(surfaceChain == NULL){
+        FIXME("Attempted to remove surface %p that hasn't been stored\n", surface);
+        LeaveCriticalSection(&textureStoreCriticalSection);
+        result = wineD3DGlobalStatistics->surfaceCount;
+        return result;
+    }else{
+            TRACE("Found surface (%d) %p with element %p pointing to %p (previous %p)\n", i, surfaceChain->surface, surfaceChain, surfaceChain->next, previousSurfaceChain);
+    }
+
+    /* make sure we don't leave a hole in the list */
+    if(previousSurfaceChain != NULL){
+        previousSurfaceChain->next = surfaceChain->next;
+    }else{
+        wineD3DGlobalStatistics->surfaces = surfaceChain->next;
+    }
+    
+    result = wineD3DGlobalStatistics->surfaceCount--;
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    return result;
+}
+
+
+
 IWineD3D* WINAPI WineDirect3DCreate(UINT SDKVersion, UINT dxVersion, IUnknown *parent) {
     IWineD3DImpl* object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IWineD3DImpl));
     object->lpVtbl = &IWineD3D_Vtbl;
@@ -40,7 +211,20 @@
     object->ref = 1;
     object->parent = parent;
 
-    TRACE("Created WineD3D object @ %p for d3d%d support\n", object, dxVersion);
+
+    /* Create a critical section for a dll global data store */
+    InitializeCriticalSectionAndSpinCount(&object->wined3dCriticalSection, 0x80000400);
+
+    EnterCriticalSection(&textureStoreCriticalSection);
+    /*Create a structure for storing global data in*/
+    if(wineD3DGlobalStatistics == NULL){
+        FIXME("Createing global statistics store\n");
+        wineD3DGlobalStatistics = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wineD3DGlobalStatistics));
+        
+    }
+    LeaveCriticalSection(&textureStoreCriticalSection);
+    
+    TRACE("Created WineD3D object @ %p for d3d%d support, parent is %p\n", object, dxVersion, parent);
 
     return (IWineD3D *)object;
 }
@@ -56,6 +240,7 @@
        DWORD size = sizeof(buffer);
        HKEY hkey = 0;
 
+       
        DisableThreadLibraryCalls(hInstDLL);
 
        mod = GetModuleHandleA( "x11drv.dll" );
@@ -64,6 +249,8 @@
            wine_tsx11_lock_ptr   = (void *)GetProcAddress( mod, "wine_tsx11_lock" );
            wine_tsx11_unlock_ptr = (void *)GetProcAddress( mod, "wine_tsx11_unlock" );
        }
+       /* Create a critical section for a dll global data store */
+       InitializeCriticalSectionAndSpinCount(&textureStoreCriticalSection, 0x80000400);
        if ( !RegOpenKeyA( HKEY_LOCAL_MACHINE, "Software\\Wine\\Direct3D", &hkey) )
        {
            if ( !RegQueryValueExA( hkey, "VertexShaderMode", 0, NULL, buffer, &size) )
diff -urN wine.20050419/dlls/wined3d/wined3d_private.h wine.20050419.dx9/dlls/wined3d/wined3d_private.h
--- wine.20050419/dlls/wined3d/wined3d_private.h	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/dlls/wined3d/wined3d_private.h	2005-04-20 03:18:03.000000000 -0600
@@ -4,6 +4,7 @@
  * Copyright 2002-2003 The wine-d3d team
  * Copyright 2002-2003 Raphael Junqueira
  * Copyright 2004      Jason Edmeades   
+ * Copyright 2005      Oliver Stieber
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -41,6 +42,47 @@
 #include "wine/wined3d_interface.h"
 #include "wine/wined3d_gl.h"
 
+
+/* Device caps */
+#define MAX_PALETTES      256
+#define MAX_STREAMS       16
+#define MAX_ACTIVE_LIGHTS 8
+#define MAX_CLIPPLANES    D3DMAXUSERCLIPPLANES
+#define MAX_LEVELS        256
+
+
+
+/*Swap chains*/
+#define MAX_SWAPCHAINS 256  
+/*TODO: this is an arbitrary limit sice I don't think 
+that there is an intrinsic limit to the number 
+of swapchains though, it may be better to change tihs to 
+a linked list at some point but a linked list makes 
+things harder to debug so I'm leaving it as a flat array of 
+MAX_SWAPCHAINS for now.
+*/
+/*
+Switch on this define to switch over to useing swapchains instead of jsut the device
+
+*/
+#define USE_SWAP_CHAINS 1
+/* Used for CreateStateBlock */
+#define NUM_SAVEDPIXELSTATES_R     38
+#define NUM_SAVEDPIXELSTATES_T     27
+#define NUM_SAVEDPIXELSTATES_S     0
+#define NUM_SAVEDVERTEXSTATES_R    33
+#define NUM_SAVEDVERTEXSTATES_T    2
+#define NUM_SAVEDVERTEXSTATES_S    0
+
+extern DWORD SavedPixelStates_R[NUM_SAVEDPIXELSTATES_R];
+extern DWORD SavedPixelStates_T[NUM_SAVEDPIXELSTATES_T];
+extern DWORD SavedPixelStates_S[NUM_SAVEDPIXELSTATES_S];
+extern DWORD SavedVertexStates_R[NUM_SAVEDVERTEXSTATES_R];
+extern DWORD SavedVertexStates_T[NUM_SAVEDVERTEXSTATES_T];
+extern DWORD SavedVertexStates_S[NUM_SAVEDVERTEXSTATES_S];
+
+
+
 extern int vs_mode;
 #define VS_NONE 0
 #define VS_HW   1
@@ -50,6 +92,13 @@
 #define PS_NONE 0
 #define PS_HW   1
 
+/* Memory and object tracking */
+typedef struct WineD3DGlobalStatistics WineD3DGlobalStatistics;
+
+extern WineD3DGlobalStatistics* wineD3DGlobalStatistics;
+
+
+
 /* X11 locking */
 
 extern void (*wine_tsx11_lock_ptr)(void);
@@ -58,6 +107,9 @@
 /* As GLX relies on X, this is needed */
 extern int num_lock;
 
+
+
+
 #if 0
 #define ENTER_GL() ++num_lock; if (num_lock > 1) FIXME("Recursive use of GL lock to: %d\n", num_lock); wine_tsx11_lock_ptr()
 #define LEAVE_GL() if (num_lock != 1) FIXME("Recursive use of GL lock: %d\n", num_lock); --num_lock; wine_tsx11_unlock_ptr()
@@ -120,6 +172,39 @@
 #define GLTEXTURECUBEMAP GL_TEXTURE_CUBE_MAP_ARB
 #endif
 
+
+
+
+/* Debugging helpers */
+
+#define  dumpMatrixFIXME(lpmatrix) \
+FIXME("Matrix: %f %f %f %f \n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._11, \
+lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._12, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._13, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._14); \
+     FIXME("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._21, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._22,  lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._23, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._24); \
+     FIXME("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._31, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._32,  lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._33, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._34); \
+     FIXME("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._41, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._42,  lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._43, \
+     lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._44); \
+
+#define dumpMatrixTRACE(lpmatrix) \
+    TRACE("Transform: %f %f %f %f \n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._11, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._12, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._13, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._14); \
+    TRACE("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._21, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._22, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._23, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._24); \
+    TRACE("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._31, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._32, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._33, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._34); \
+    TRACE("           %f %f %f %f\n", lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._41, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._42, lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._43, \
+    lpmatrix->DUMMYUNIONNAME.DUMMYSTRUCTNAME._44); \
+
+    
 /* DirectX Device Limits */
 /* --------------------- */
 #define MAX_LEVELS  256  /* Maximum number of mipmap levels. Guessed at 256 */
@@ -183,8 +268,22 @@
 #define REAPPLY_ALL      0xFFFF
 
 /* Advance declaration of structures to satisfy compiler */
+typedef struct IWineD3DBaseTextureImpl IWineD3DBaseTextureImpl;
 typedef struct IWineD3DStateBlockImpl IWineD3DStateBlockImpl;
 typedef struct IWineD3DSurfaceImpl    IWineD3DSurfaceImpl;
+typedef struct IWineD3DSwapChainImpl  IWineD3DSwapChainImpl;
+
+
+
+
+/*Tracking*/
+
+int globalStoreTexture(IWineD3DBaseTexture* texture);
+int globalStoreReleaseTexture(IWineD3DBaseTexture* texture);
+int globalStoreSurface(IWineD3DSurface* surface);
+int globalStoreReleaseSurface(IWineD3DSurface* surface);
+long globalChangeGlRam(long glram);
+long globalChangeSysRam(long sysram);
 
 /* Global variables */
 extern const float identity[16];
@@ -241,6 +340,9 @@
 extern LONG primCounter;
 #endif
 
+
+
+
 /*****************************************************************************
  * Prototypes
  */
@@ -321,6 +423,9 @@
     /* GL Information */
     BOOL                    isGLInfoValid;
     WineD3D_GL_Info         gl_info;
+
+    /* a per instance critical section */
+    CRITICAL_SECTION        wined3dCriticalSection;
 } IWineD3DImpl;
 
 extern IWineD3DVtbl IWineD3D_Vtbl;
@@ -339,13 +444,16 @@
     IWineD3D               *wineD3D;
 
     /* X and GL Information */
+    #ifndef USE_SWAP_CHAINS /*TODO: move over to swapchains*/
     HWND                    win_handle;
     Window                  win;
-    Display                *display;
     GLXContext              glCtx;
     XVisualInfo            *visInfo;
     GLXContext              render_ctx;
+    Display                *display;
     Drawable                drawable;
+    #endif
+    
     GLint                   maxConcurrentLights;
 
     /* Optimization */
@@ -367,8 +475,14 @@
 
     /* State block related */
     BOOL                    isRecordingState;
+    /*TODO: replace with iface usage (maybe?) */
+    #if 0
+    IWineD3DStateBlock     *stateBlock;
+    IWineD3DStateBlock     *updateStateBlock;
+    #else
     IWineD3DStateBlockImpl *stateBlock;
     IWineD3DStateBlockImpl *updateStateBlock;
+    #endif
 
     /* Internal use fields  */
     D3DDEVICE_CREATION_PARAMETERS   createParms;
@@ -377,10 +491,30 @@
     D3DDEVTYPE                      devType;
 
     /* Render Target Support */
-    IWineD3DSurface        *frontBuffer;
-    IWineD3DSurface        *backBuffer;
-    IWineD3DSurface        *depthStencilBuffer;
+    #if 0     /* TODO: replace this with some stores, basicly move the code over from globalstoreadd...
+                 It may be a good idea to store all device instances too so that a debug application can examine whats going on */
+    ILinkedListStore        *swapchainStore;
+    ILinkedListStore        *surfaceStore;
+    ILinkedListStore        *textureStore;
+    #else
+    IWineD3DSwapChain      *swapchains[MAX_SWAPCHAINS]; /*no-one wil ever need more that MAX_SWAPCHAINS swapchains,
+                                                         I don't think that ther is an intrinsic limit 
+                                                         to the number of swapchains though so maybe
+                                                         a linked list would be better?*/
+    int                     numberOfSwapChains;
 
+    #endif
+    
+    /*
+    apparently this is bound to the device not the swapchain
+    multiple windows with depthSencilBuffers are going to be interesting.
+    */
+    IWineD3DSurface        *depthStencilBuffer;
+    
+    /* FIXME:  (MS DX9 Docs) The device can now support multiple render targets.
+    The number of render targets supported by a device is contained in the 
+    NumSimultaneousRTs member of D3DCAPS9. See Multiple Render Targets. */
+    
     IWineD3DSurface        *renderTarget;
     IWineD3DSurface        *stencilBufferTarget;
 
@@ -483,14 +617,14 @@
 
 } IWineD3DBaseTextureClass;
 
-typedef struct IWineD3DBaseTextureImpl
+struct IWineD3DBaseTextureImpl
 {
     /* IUnknown & WineD3DResource Information     */
     IWineD3DBaseTextureVtbl  *lpVtbl;
     IWineD3DResourceClass     resource;
     IWineD3DBaseTextureClass  baseTexture;
 
-} IWineD3DBaseTextureImpl;
+};
 
 extern IWineD3DBaseTextureVtbl IWineD3DBaseTexture_Vtbl;
 
@@ -588,11 +722,10 @@
 } WINED3DSURFACET_DESC;
 
 /*****************************************************************************
- * IWineD3DSurface implementation structure
+ * IWineD3DTSurface implementation structure (extends IWineD3DResourceImpl)
  */
 struct IWineD3DSurfaceImpl
 {
-    /* IUnknown & IWineD3DResource Information     */
     IWineD3DSurfaceVtbl      *lpVtbl;
     IWineD3DResourceClass     resource;
 
@@ -603,20 +736,37 @@
     UINT                      textureName;
     UINT                      bytesPerPixel;
     
+    /*Other things not in D3DSURFACE_DESC*/    
     BOOL                      lockable;
     BOOL                      discard;
     BOOL                      locked;
     
+    /*TODO: move this off into a management class(maybe!)*/
+    BOOL                      nonpow2;
+    
+    UINT                      pow2Width;
+    UINT                      pow2Height;
+    UINT                      pow2Size;
+
+    /* precalculated x and y scalings for texture coords */
+    float                     pow2scalingFactorX; /* =  (Width  / pow2Width ) */
+    float                     pow2scalingFactorY; /* =  (Height / pow2Height) */
+
     RECT                      lockedRect;
     RECT                      dirtyRect;
     BOOL                      Dirty;
-    
+    /*TODO: move this off into a context manager
+    IUnknown                  *contextManagerData;
+    */
+    BOOL                      activeLock;/*Performance. Is locking activly being used on this surface*/
     BOOL                      inTexture;
     BOOL                      inPBuffer;
+
 };
 
 extern IWineD3DSurfaceVtbl IWineD3DSurface_Vtbl;
 
+
 /*****************************************************************************
  * IWineD3DVertexDeclaration implementation structure
  */
@@ -626,8 +776,13 @@
   DWORD                   ref;     /* Note: Ref counting not required */
 
   IUnknown               *parent;
-  /** precomputed fvf if simple declaration */
+  /*TODO: replace with iface usage */
+  #if 0
+  IWineD3DDevice         *wineD3DDevice;
+  #else
   IWineD3DDeviceImpl     *wineD3DDevice;
+  #endif
+  /** precomputed fvf if simple declaration */
   DWORD   fvf[MAX_STREAMS];
   DWORD   allFVF;
 
@@ -653,13 +808,16 @@
         BOOL                      indices;
         BOOL                      material;
         BOOL                      fvf;
-        BOOL                      stream_source[MAX_STREAMS];
+
+        BOOL                      streamSource[MAX_STREAMS];
+        BOOL                      streamFreq[MAX_STREAMS];
         BOOL                      textures[8];
-        BOOL                      transform[HIGHEST_TRANSFORMSTATE];
+        BOOL                      transform[HIGHEST_TRANSFORMSTATE +1 ];
         BOOL                      viewport;
-        BOOL                      renderState[WINEHIGHEST_RENDER_STATE];
-        BOOL                      textureState[8][HIGHEST_TEXTURE_STATE];
+        BOOL                      renderState[WINEHIGHEST_RENDER_STATE + 1];
+        BOOL                      textureState[8][HIGHEST_TEXTURE_STATE +1];
         BOOL                      clipplane[MAX_CLIPPLANES];
+        BOOL                      samplerState[16/*MAX_SAMPLERS*/][HIGHEST_SAMPLER_STATE + 1];
         BOOL                      vertexDecl;
         BOOL                      pixelShader;
         BOOL                      vertexShader;        
@@ -673,7 +831,12 @@
     
     /* IWineD3DStateBlock information */
     IUnknown                 *parent;
+      /*TODO: replace with iface usage */
+    #if 0
+    IWineD3DDevice         *wineD3DDevice;
+    #else
     IWineD3DDeviceImpl       *wineD3DDevice;
+    #endif
     D3DSTATEBLOCKTYPE         blockType;
 
     /* Array indicating whether things have been set or changed */
@@ -689,16 +852,18 @@
 
     /* Stream Source */
     BOOL                      streamIsUP;
-    UINT                      stream_stride[MAX_STREAMS];
-    UINT                      stream_offset[MAX_STREAMS];
-    IWineD3DVertexBuffer     *stream_source[MAX_STREAMS];
+    UINT                      streamStride[MAX_STREAMS];
+    UINT                      streamOffset[MAX_STREAMS];
+    IWineD3DVertexBuffer     *streamSource[MAX_STREAMS];
+    UINT                      streamFreq[MAX_STREAMS];
+    UINT                      streamFlags[MAX_STREAMS];     /*0 | D3DSTREAMSOURCE_INSTANCEDATA | D3DSTREAMSOURCE_INDEXEDDATA  */
 
     /* Indices */
     IWineD3DIndexBuffer*      pIndexData;
     UINT                      baseVertexIndex; /* Note: only used for d3d8 */
 
     /* Transform */
-    D3DMATRIX                 transforms[HIGHEST_TRANSFORMSTATE];
+    D3DMATRIX                 transforms[HIGHEST_TRANSFORMSTATE + 1];
 
     /* Lights */
     PLIGHTINFOEL             *lights; /* NOTE: active GL lights must be front of the chain */
@@ -713,24 +878,30 @@
     /* Material */
     WINED3DMATERIAL           material;
 
+    /* Pixel Shader */
+    void                     *pixelShader; /* TODO: Replace void * with IWineD3DPixelShader * */
+  
     /* Indexed Vertex Blending */
     D3DVERTEXBLENDFLAGS       vertex_blend;
     FLOAT                     tween_factor;
 
     /* RenderState */
-    DWORD                     renderState[WINEHIGHEST_RENDER_STATE];
+    DWORD                     renderState[WINEHIGHEST_RENDER_STATE +1 ];
 
     /* Texture */
-    IWineD3DBaseTexture      *textures[8];
-    int                       textureDimensions[8];
+    IWineD3DBaseTexture      *textures[9];
+    int                       textureDimensions[17/*MAX_STREAMS*/];/*increased to accomodate samplerStates too*/
 
     /* Texture State Stage */
-    DWORD                     textureState[8][HIGHEST_TEXTURE_STATE];
+    DWORD                     textureState[9][HIGHEST_TEXTURE_STATE + 1];
+    /* Sampler States */
+    DWORD                     samplerState[17/*MAX_STREAMS*/][HIGHEST_SAMPLER_STATE + 1];/*I think this can be combined with textureState*/
 
 };
 
 extern IWineD3DStateBlockVtbl IWineD3DStateBlock_Vtbl;
 
+
 /*****************************************************************************
  * IWineD3DQueryImpl implementation structure (extends IUnknown)
  */
@@ -756,7 +927,82 @@
 
 extern IWineD3DQueryVtbl IWineD3DQuery_Vtbl;
 
+
 /*****************************************************************************
+ * IWineD3DSwapChainImpl implementation structure (extends IUnknown)
+ */
+ 
+
+struct IWineD3DSwapChainImpl
+{   
+    /*IUnknown part*/
+    IWineD3DSwapChainVtbl    *lpVtbl;
+    DWORD                     ref;     /* Note: Ref counting not required */
+    
+    IUnknown                 *parent;
+    /*TODO: replace with iface usage */
+#if 0
+    IWineD3DDevice         *wineD3DDevice;
+#else
+    IWineD3DDeviceImpl       *wineD3DDevice;
+#endif
+    /* IWineD3DSwapChain fields */
+    IWineD3DSurface          *backBuffer;
+    IWineD3DSurface          *frontBuffer;    
+    BOOL                      wantsDepthStencilBuffer;
+    D3DPRESENT_PARAMETERS     presentParms;
+        
+    /* TODO: move everything upto drawable off into a context manager
+      and store the 'data' in the contextManagerData interface.
+    IUnknown                  *contextManagerData;
+    */
+
+    HWND                    win_handle;
+    Window                  win; 
+    Display                *display;
+    
+    GLXContext              glCtx;
+    XVisualInfo            *visInfo;
+    GLXContext              render_ctx;    
+    /* This has been left in device for now, but needs moving off into a rendertarget mamangement class and seperated out from swapchains and devices. */
+    Drawable                drawable;
+};
+
+extern IWineD3DSwapChainVtbl IWineD3DSwapChain_Vtbl;
+
+
+/*Global object infomration*/
+typedef struct TextureChain {
+    IWineD3DBaseTexture      *texture;
+    struct TextureChain      *previous;
+    struct TextureChain      *next;
+} TextureChain;
+
+typedef struct SurfaceChain {
+    IWineD3DSurface          *surface;
+    struct SurfaceChain      *previous;
+    struct SurfaceChain      *next;
+} SurfaceChain;
+
+/*Structure for holding information on all direct3d objects 
+usefull for making sure tracking is ok and when release is called on a device!
+and probably quite handy for debuggin and dumping states out
+*/
+struct WineD3DGlobalStatistics {
+    int textureCount;
+    int surfaceCount;
+    int activeSurfaces;
+    int gltextures;
+    int systemsurfaceram; /*The about of heap memory allocated for textures*/
+    int totalsurfaceram;/*The amount of memory in total allocated for textrues*/
+    int glsurfaceram; /*The aproximate amount of glTexture memory allocated for textures*/
+    TextureChain *textures;/*global texture store*/
+    SurfaceChain *surfaces;/*global surface store*/    
+};
+
+ 
+/*****************************************************************************
+
  * Utility function prototypes 
  */
 
@@ -781,6 +1027,20 @@
 GLenum D3DFmt2GLType(IWineD3DDeviceImpl *This, D3DFORMAT fmt);
 GLint  D3DFmt2GLIntFmt(IWineD3DDeviceImpl* This, D3DFORMAT fmt);
 
+GLenum D3DFmt2GLDepthFmt(D3DFORMAT fmt);
+GLenum D3DFmt2GLDepthType(D3DFORMAT fmt);
+
+int D3DFmtMakeGlCfg(D3DFORMAT BackBufferFormat, D3DFORMAT StencilBufferFormat, int *attribs, int* nAttribs, BOOL alternate);
+
+int D3DPrimitiveListGetVertexSize(D3DPRIMITIVETYPE PrimitiveType, int iNumPrim);
+int D3DPrimitive2GLenum(D3DPRIMITIVETYPE PrimitiveType);
+int D3DFVFGetSize(D3DFORMAT fvf);
+
+int SOURCEx_RGB_EXT(DWORD arg);
+int OPERANDx_RGB_EXT(DWORD arg);
+int SOURCEx_ALPHA_EXT(DWORD arg);
+int OPERANDx_ALPHA_EXT(DWORD arg);
+
 /*****************************************************************************
  * To enable calling of inherited functions, requires prototypes 
  *
@@ -831,6 +1091,8 @@
     /*** class static members ***/
     void IWineD3DBaseTextureImpl_CleanUp(IWineD3DBaseTexture *iface);
 
+/* STUBS for pixel and vertex shader interfaces*/
+
 /*****************************************************************************
  * IDirect3DVertexShader implementation structure
  */
@@ -840,13 +1102,18 @@
     DWORD                       ref;     /* Note: Ref counting not required */
 
     IUnknown                    *parent;
+    /*TODO: replace with iface usage */
+    #if 0
+    IWineD3DDevice         *wineD3DDevice;
+    #else
     IWineD3DDeviceImpl          *wineD3DDevice;
+    #endif
 
     /* IWineD3DVertexShaderImpl*/
     CONST DWORD                 *function;
     UINT                         functionLength;
-
 #if 0 /* needs reworking */
+
     DWORD usage;
     DWORD version;
     /* run time datas */
@@ -866,13 +1133,16 @@
     DWORD                       ref;     /* Note: Ref counting not required */
     
     IUnknown                   *parent;
+    /*TODO: replace with iface usage */
+    #if 0
+    IWineD3DDevice         *wineD3DDevice;
+    #else
     IWineD3DDeviceImpl         *wineD3DDevice;
-
+    #endif
     
     /* IWineD3DPixelShaderImpl*/
     CONST DWORD                *function;
     UINT                        functionLength;
-
 #if 0 /* needs reworking */
     UINT functionLength;
     DWORD version;
@@ -884,4 +1154,23 @@
 } IWineD3DPixelShaderImpl;
 
 extern IWineD3DPixelShaderVtbl IWineD3DPixelShader_Vtbl;
+
+#if 0 /*TODO: private interfaces &co for this.. */
+typedef struct ILinkedListStoreImpl {
+    /* IUnknown parts*/   
+    IWineD3DPixelShaderVtbl    *lpVtbl;
+    DWORD                       ref;     /* Note: Ref counting not required */
+    
+    /* ILinkedListStore members */
+    BOOL                        threadSafe;
+
+    /* critical section, (can be supplied by the caller to keep the number of critical sections down?) */
+    CRITICAL_SECTION            *CriticalSection;        
+    ForwardOnlyLinkedList       *linkedList;/*global texture store*/
+    
+
+} ILinkedListStoreImpl;
+
+extern ILinkedListStoreVtbl ILinkedListStore_Vtbl;
+#endif
 #endif
diff -urN wine.20050419/include/d3d9.h wine.20050419.dx9/include/d3d9.h
--- wine.20050419/include/d3d9.h	2004-10-04 22:38:15.000000000 -0600
+++ wine.20050419.dx9/include/d3d9.h	2005-04-20 01:52:56.000000000 -0600
@@ -26,8 +26,12 @@
 
 #include <objbase.h>
 
+#define D3D_SDK_VERSION   (32 | 0x80000000)
+#define D3D9b_SDK_VERSION (31 | 0x80000000)
+
 #include <d3d9types.h>
 #include <d3d9caps.h>
+#include <gdi.h>
 
 /*****************************************************************************
  * Behavior Flags for IDirect3D8::CreateDevice
@@ -40,6 +44,7 @@
 #define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L
 #define D3DCREATE_DISABLE_DRIVER_MANAGEMENT     0x00000100L
 #define D3DCREATE_ADAPTERGROUP_DEVICE           0x00000200L
+#define D3DCREATE_MANAGED                       
 
 /*****************************************************************************
  * Flags for SetPrivateData
diff -urN wine.20050419/include/d3d9caps.h wine.20050419.dx9/include/d3d9caps.h
--- wine.20050419/include/d3d9caps.h	2003-06-20 15:28:34.000000000 -0600
+++ wine.20050419.dx9/include/d3d9caps.h	2005-04-20 01:52:56.000000000 -0600
@@ -25,8 +25,8 @@
  */
 #define D3DCAPS_READ_SCANLINE 0x20000
 
-#define D3DCURSORCAPS_COLOR   1
-#define D3DCURSORCAPS_LOWRES  2
+#define D3DCURSORCAPS_COLOR   0x00000001L
+#define D3DCURSORCAPS_LOWRES  0x00000002L
 
 
 #define D3DDEVCAPS2_STREAMOFFSET                        0x00000001L
@@ -179,14 +179,15 @@
 #define D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD        0x08000000
 #define D3DPTFILTERCAPS_MAGFGAUSSIANQUAD         0x10000000
 
-#define D3DSTENCILCAPS_KEEP                      0x01
-#define D3DSTENCILCAPS_ZERO                      0x02
-#define D3DSTENCILCAPS_REPLACE                   0x04
-#define D3DSTENCILCAPS_INCRSAT                   0x08
-#define D3DSTENCILCAPS_DECRSAT                   0x10
-#define D3DSTENCILCAPS_INVERT                    0x20
-#define D3DSTENCILCAPS_INCR                      0x40
-#define D3DSTENCILCAPS_DECR                      0x80
+#define D3DSTENCILCAPS_KEEP                      0x00000001L
+#define D3DSTENCILCAPS_ZERO                      0x00000002L
+#define D3DSTENCILCAPS_REPLACE                   0x00000004L
+#define D3DSTENCILCAPS_INCRSAT                   0x00000008L
+#define D3DSTENCILCAPS_DECRSAT                   0x00000010L
+#define D3DSTENCILCAPS_INVERT                    0x00000020L
+#define D3DSTENCILCAPS_INCR                      0x00000040L
+#define D3DSTENCILCAPS_DECR                      0x00000080L
+#define D3DSTENCILCAPS_TWOSIDED                  0x00000100L
 
 #define D3DTEXOPCAPS_DISABLE                     0x0000001
 #define D3DTEXOPCAPS_SELECTARG1                  0x0000002
@@ -326,7 +327,8 @@
   
   DWORD               LineCaps;
   
-  DWORD               MaxTextureWidth, MaxTextureHeight;
+  DWORD               MaxTextureWidth;
+  DWORD               MaxTextureHeight;
   DWORD               MaxVolumeExtent;
   
   DWORD               MaxTextureRepeat;
@@ -364,13 +366,13 @@
   DWORD               MaxVertexShaderConst;
   
   DWORD               PixelShaderVersion;
-  float               MaxPixelShaderValue;
+  float               PixelShader1xMaxValue;
 
   /* DX 9 */
   DWORD               DevCaps2;
 
   float               MaxNpatchTessellationLevel;
-  DWORD               Reserved5;
+  DWORD               Reserved5; /*undocumented*/
 
   UINT                MasterAdapterOrdinal;   
   UINT                AdapterOrdinalInGroup;  
@@ -385,6 +387,8 @@
   DWORD               MaxPShaderInstructionsExecuted;
   DWORD               MaxVertexShader30InstructionSlots; 
   DWORD               MaxPixelShader30InstructionSlots;
+  DWORD               Reserved2;/*Not in the microsoft headers but documented*/
+  DWORD               Reserved3;
 
 } D3DCAPS9;
 
diff -urN wine.20050419/include/d3d9types.h wine.20050419.dx9/include/d3d9types.h
--- wine.20050419/include/d3d9types.h	2005-03-03 06:57:15.000000000 -0700
+++ wine.20050419.dx9/include/d3d9types.h	2005-04-20 01:52:56.000000000 -0600
@@ -209,6 +209,23 @@
 
 
 
+    
+/*Constants used by D3DPRESENT_PARAMETERS. when creating a device or swapchain*/
+
+#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER  0x00000001 /*Create a lockable backbuffer*/
+#define D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL 0x00000002 /*Discard Z buffer */
+#define D3DPRESENTFLAG_DEVICECLIP           0x00000004 /*Clip the window blited into the client area 2k + xp only*/
+#define D3DPRESENTFLAG_VIDEO                0x00000010 /*backbuffer 'may' contain video data*/
+
+
+
+#define D3DPRESENT_BACK_BUFFERS_MAX         3L
+#define D3DPRESENT_RATE_DEFAULT             0x00000000
+
+    
+
+    
+    
 /**************************** 
  * Vertex Shaders Declaration
  */
@@ -228,6 +245,7 @@
   D3DDECLUSAGE_FOG          = 11,        
   D3DDECLUSAGE_DEPTH        = 12,      
   D3DDECLUSAGE_SAMPLE       = 13     
+  
 } D3DDECLUSAGE;
 
 /* MSDN is quite confussing at this point...
@@ -811,6 +829,7 @@
     D3DFMT_D16_LOCKABLE         =  70,
     D3DFMT_D32                  =  71,
     D3DFMT_D15S1                =  73,
+    D3DFMT_D24S8                =  75,
     D3DFMT_D24X8                =  77,
     D3DFMT_D24X4S4              =  79,
     D3DFMT_D16                  =  80,
@@ -875,16 +894,6 @@
     D3DMULTISAMPLE_FORCE_DWORD     = 0xffffffff
 } D3DMULTISAMPLE_TYPE;
 
-#if 0
-typedef enum _D3DORDERTYPE {
-   D3DORDER_LINEAR      = 1,
-   D3DORDER_QUADRATIC   = 2,
-   D3DORDER_CUBIC       = 3,
-   D3DORDER_QUINTIC     = 5,
-
-   D3DORDER_FORCE_DWORD = 0x7fffffff
-} D3DORDERTYPE;
-#endif
 typedef enum _D3DPATCHEDGESTYLE {
    D3DPATCHEDGE_DISCRETE    = 0,
    D3DPATCHEDGE_CONTINUOUS  = 1,
@@ -1135,17 +1144,6 @@
     D3DTSS_BUMPENVMAT10          =  9,
     D3DTSS_BUMPENVMAT11          = 10,
     D3DTSS_TEXCOORDINDEX         = 11,
-#if 1 /* TODO: remove once samplerstates are implemented.  */
-    D3DTSS_ADDRESSU              = 13,
-    D3DTSS_ADDRESSV              = 14,
-    D3DTSS_BORDERCOLOR           = 15,
-    D3DTSS_MAGFILTER             = 16,
-    D3DTSS_MINFILTER             = 17,
-    D3DTSS_MIPFILTER             = 18,
-    D3DTSS_MIPMAPLODBIAS         = 19,
-    D3DTSS_MAXMIPLEVEL           = 20,
-    D3DTSS_MAXANISOTROPY         = 21,
-#endif
     D3DTSS_BUMPENVLSCALE         = 22,
     D3DTSS_BUMPENVLOFFSET        = 23,
     D3DTSS_TEXTURETRANSFORMFLAGS = 24,
@@ -1241,7 +1239,7 @@
 
     GUID            DeviceIdentifier;
 
-    DWORD           WHQLLevel;
+    DWORD           WHQLLevel;/*d3d9.h D3DENUM_WHQL_LEVEL*/
 } D3DADAPTER_IDENTIFIER9;
 
 typedef struct _D3DBOX {
diff -urN wine.20050419/include/d3dx9.h wine.20050419.dx9/include/d3dx9.h
--- wine.20050419/include/d3dx9.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/include/d3dx9.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef __WINE_D3DX9_H
+#define __WINE_D3DX9_H
+
+
+
+
+
+
+
+/*** Defines  ***/
+#define D3DX_DEFAULT            ((UINT) -1)
+#define D3DX_DEFAULT_NONPOW2    ((UINT) -2)
+#define D3DX_DEFAULT_FLOAT      FLT_MAX
+#define D3DFMT_FROM_FILE
+#define D3DX_FROM_FILE
+
+#if 0
+#ifndef D3DXINLINE
+#ifdef _MSC_VER
+  #if (_MSC_VER >= 1200)
+  #define D3DXINLINE __forceinline
+  #else
+  #define D3DXINLINE __inline
+  #endif
+#else
+  #ifdef __cplusplus
+  #define D3DXINLINE inline
+  #else
+  #define D3DXINLINE
+  #endif
+#endif
+#endif
+#endif
+
+
+/***  Includes ***/
+#include <d3d9.h>
+#include <d3dx9math.h>
+#include <d3dx9core.h>
+#if 0
+#include <d3dx9mesh.h>
+#include <d3dx9tex.h>
+#include <d3dx9shader.h>
+#include <d3dx9effect.h>
+#include <d3dx9shape.h>
+#include <d3dx9anim.h>
+#endif
+/*** Errors ***/
+/*I don't know where this lives yet*/
+
+#define _FACDD  0x876
+#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )
+
+
+
+typedef enum _D3DXERR {
+    D3DXERR_CANNOTMODIFYINDEXBUFFER     = 1, // (1 << 31)|(0x876 << 16)|2900 ,
+    D3DXERR_INVALIDMESH                 = MAKE_DDHRESULT(2901) ,
+    D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902) ,
+    D3DXERR_SKINNINGNOTSUPPORTED        = MAKE_DDHRESULT(2903) ,
+    D3DXERR_TOOMANYINFLUENCES           = MAKE_DDHRESULT(2904) , 
+    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905) ,
+    D3DXERR_LOADEDMESHASNODATA          = MAKE_DDHRESULT(2906) ,
+    D3DXERR_DUPLICATENAMEDFRAGMENT      = MAKE_DDHRESULT(2907) ,
+}D3DXERR;
+
+#endif /* __WINE_D3DX9_H */
diff -urN wine.20050419/include/d3dx9core.h wine.20050419.dx9/include/d3dx9core.h
--- wine.20050419/include/d3dx9core.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/include/d3dx9core.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,607 @@
+
+/*
+ * Copyright (C) 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __WINE_D3DX9CORE_H
+#define __WINE_D3DX9CORE_H
+
+#include <objbase.h>
+
+#include <d3dx9.h>
+/*** Version info ***/
+
+
+/*FIXME: move to d3d9mesh.h ?*/
+#define D3DX_VERSION     0x0902
+#define D3DX_SDK_VERSION 22
+
+
+
+#if 0
+#ifdef __cplusplus
+extern "C" {
+#endif 
+BOOL WINAPI    D3DXCheckVersion(UINT D3DSdkVersion, UINT D3DXSdkVersion);
+UINT WINAPI    D3DXGetDriverLevel(LPDIRECT3DDEVICE9 pDevice);
+#ifdef __cplusplus
+}
+#endif 
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+HRESULT WINAPI D3DXCreateTextureFromFile(LPDIRECT3DDEVICE9 pDevice, LPSTR pSrcFile,  LPDIRECT3DTEXTURE9 *ppTexture);
+
+#ifdef __cplusplus
+}
+#endif 
+
+
+
+
+
+
+/*****************************************************************************
+ * GUIDs
+ */
+
+/* {932E6A7E-C68E-45dd-A7BF-53D19C86DB1F} */
+DEFINE_GUID(IID_ID3DXBuffer, 0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);
+
+
+/* {4AAE6B4D-D15F-4909-B09F-8D6AA34AC06B} */
+DEFINE_GUID( IID_ID3DXFont, 0x4aae6b4d, 0xd15f, 0x4909, 0xb0, 0x9f, 0x8d, 0x6a, 0xa3, 0x4a, 0xc0, 0x6b);
+
+/* {B07EC84A-8D35-4e86-A9A0-8DFF21D71075} */
+DEFINE_GUID( IID_ID3DXSprite, 0xb07ec84a, 0x8d35, 0x4e86, 0xa9, 0xa0, 0x8d, 0xff, 0x21, 0xd7, 0x10, 0x75);
+
+/*****************************************************************************
+ * typedefs
+ */
+typedef struct ID3DXBuffer  ID3DXBuffer, *LPD3DXBUFFER;
+typedef struct ID3DXFont    ID3DXFont,   *LPD3DXFONT;
+typedef struct ID3DXSprite  ID3DXSprite, *LPD3DXSPRITE;
+
+
+
+
+
+
+/*****************************************************************************
+ * #defines and error codes
+ */
+#define D3DXASM_DEBUG           1
+#define D3DXASM_SKIPVALIDATION  2
+
+#define _FACD3D  0x876
+#define MAKE_D3DXHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
+
+/*
+ * Direct3D Errors
+ */
+ #if 0
+#define D3DXERR_CANNOTATTRSORT                  MAKE_D3DXHRESULT(2158)
+#define D3DXERR_CANNOTMODIFYINDEXBUFFER         MAKE_D3DXHRESULT(2159)
+#define D3DXERR_INVALIDMESH                     MAKE_D3DXHRESULT(2160)
+#define D3DXERR_SKINNINGNOTSUPPORTED            MAKE_D3DXHRESULT(2161)
+#define D3DXERR_TOOMANYINFLUENCES               MAKE_D3DXHRESULT(2162)
+#define D3DXERR_INVALIDDATA                     MAKE_D3DXHRESULT(2163)
+#endif
+#define D3DXSPRITE_DONOTSAVESTATE
+#define D3DXSPRITE_DONOTMODIFY_RENDERSTATE
+#define D3DXSPRITE_OBJECTSPACE
+#define D3DXSPRITE_BILLBOARD
+#define D3DXSPRITE_ALPHABLEND
+#define D3DXSPRITE_SORT_TEXTURE
+#define D3DXSPRITE_SORT_DEPTH_FRONTTOBACK
+#define D3DXSPRITE_SORT_DEPTH_BACKTOFRONT
+
+
+
+
+
+
+/*
+ * Macros
+ */
+#define D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
+#if 0
+#define D3DSINCOSCONST2 -0.020833334f   , -0.12500000f    ,  1.0f         , 0.50000000f 
+#endif
+/*FIXME: move over to d3dx9math.h*/
+
+
+#if 0
+/*** 16-Bit Floating Point Numbers ***/
+#define D3DX_16F_DIG         3
+#define D3DX_16F_EPSILON     4.8875809e-4f
+#define D3DX_16F_MANT_DIG   11
+#define D3DX_16F_MAX         6.5519996e+4f
+#define D3DX_16F_MAX_10_EXP  4
+#define D3DX_16F_MAX_EXP    15
+#define D3DX_16F_MIN         6.1035156e-5f
+#define D3DX_16F_MIN_10_EXP  (-4)
+#define D3DX_16F_MIN_EXP     (-12)
+#define D3DX_16F_RADIX       2
+#define D3DX_16F_ROUNDS      1
+#define D3DX_1BYPI           ((FLOAT) 0.318309886f)
+#define D3DX_PI              ((FLOAT) 3.141592654f)
+
+/*** PRT Constants ***/
+#define D3DXSH_MINORDER      2
+#define D3DXSH_MAXORDER      6
+
+#endif
+
+
+/*FIXME: move over to d3dx9shader.h */
+#define D3DXTX_VERSION(_Major,_Minor) (('T' << 24) | ('X' << 16) | ((_Major) << 8) | (_Minor))
+
+#define D3DXSHADER_AVOID_FLOW_CONTROL
+#define D3DXSHADER_DEBUG
+#define D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT
+#define D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT
+#define D3DXSHADER_NO_PRESHADER
+#define D3DXSHADER_PACKMATRIX_COLUMNMAJOR
+#define D3DXSHADER_PACKMATRIX_ROWMAJOR
+#define D3DXSHADER_PARTIALPRECISION
+#define D3DXSHADER_PREFER_FLOW_CONTROL
+#define D3DXSHADER_SKIPOPTIMIZATION
+#define D3DXSHADER_SKIPVALIDATION
+/******/
+#define D3DXSHADER_DEBUG
+#define D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT
+#define D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT
+#define D3DXSHADER_SKIPVALIDATION
+
+/*FIXME: move to d3dx9tex.h*/
+#define D3DX_CHANNEL_RED
+#define D3DX_CHANNEL_BLUE
+#define D3DX_CHANNEL_GREEN
+#define D3DX_CHANNEL_ALPHA
+#define D3DX_CHANNEL_LUMINANCE
+
+
+#define D3DX_FILTER_NONE
+#define D3DX_FILTER_POINT
+#define D3DX_FILTER_LINEAR
+#define D3DX_FILTER_TRIANGLE
+#define D3DX_FILTER_BOX
+#define D3DX_FILTER_MIRROR_U
+#define D3DX_FILTER_MIRROR_V
+#define D3DX_FILTER_MIRROR_W
+#define D3DX_FILTER_MIRROR
+#define D3DX_FILTER_DITHER
+#define D3DX_FILTER_SRGB_IN
+#define D3DX_FILTER_SRGB_OUT
+#define D3DX_FILTER_SRGB
+
+#define D3DX_NORMALMAP_MIRROR_U
+#define D3DX_NORMALMAP_MIRROR_V
+#define D3DX_NORMALMAP_MIRROR
+#define D3DX_NORMALMAP_INVERTSIGN
+#define D3DX_NORMALMAP_COMPUTE_OCCLUSION
+
+
+
+#if 0
+typedef struct D3DXMESHDATA {
+
+    D3DXMESHDATATYPE Type;
+        
+    union
+    {
+    LPD3DXMESH pMesh;
+    LPD3DXMESH pPMesh;
+    LPD3DXPATCHMESH pPatchMesh;
+    }
+        
+} D3DXMESHDATA, *LPD3DXMESHDATA;
+#endif
+typedef enum _D3DXMESH {
+    D3DXMESH_32BIT        = 0x001,
+    D3DXMESH_DONOTCLIP    = 0x002,
+    D3DXMESH_POINTS       = 0x004,
+    D3DXMESH_RTPATCHES    = 0x008,
+    D3DXMESH_NPATCHES     = 0x4000,
+    D3DXMESH_VB_SYSTEMMEM = 0x010,
+    D3DXMESH_VB_MANAGED   = 0x020,
+    D3DXMESH_VB_WRITEONLY = 0x040,
+    D3DXMESH_VB_DYNAMIC   = 0x080,
+    D3DXMESH_VB_SOFTWAREPROCESSING = 0x8000,
+    D3DXMESH_IB_SYSTEMMEM = 0x100,
+    D3DXMESH_IB_MANAGED   = 0x200,
+    D3DXMESH_IB_WRITEONLY = 0x400,
+    D3DXMESH_IB_DYNAMIC   = 0x800,
+    D3DXMESH_IB_SOFTWAREPROCESSING = 0x10000,
+    D3DXMESH_VB_SHARE     = 0x1000,
+    D3DXMESH_USEHWONLY    = 0x2000,
+    D3DXMESH_SYSTEMMEM    = 0x110,
+    D3DXMESH_MANAGED      = 0x220,
+    D3DXMESH_WRITEONLY    = 0x440,
+    D3DXMESH_DYNAMIC      = 0x880,
+    D3DXMESH_SOFTWAREPROCESSING = 0x18000
+} D3DXMESH;
+#if 0
+HRESULT D3DXLoadMeshFromX(      
+    LPCTSTR pFilename,
+    DWORD Options,
+    LPDIRECT3DDEVICE9 pDevice,
+    LPD3DXBUFFER* ppAdjacency,
+    LPD3DXBUFFER* ppMaterials,
+    LPD3DXBUFFER* ppEffectInstances,
+    DWORD* pNumMaterials,
+    LPD3DXMESH* ppMesh
+);
+#endif
+
+
+/*FIXME: move to d3dx9anim.h */
+
+typedef enum _D3DXCALLBACK_SEARCH_FLAGS {
+    D3DXCALLBACK_SEARCH_EXCLUDING_INITIAL_POSITION = 1,
+    D3DXCALLBACK_SEARCH_BEHIND_INITIAL_POSITION = 2,
+    
+    D3DXCALLBACK_FORCE_DWORD = 0x7fffffff
+} D3DXCALLBACK_SEARCH_FLAGS;
+
+typedef enum _D3DXCOMPRESSION_FLAGS {
+    D3DXCOMPRESS_DEFAULT = 0,
+    D3DXCOMPRESS_FORCE_DWORD = 0x7fffffff
+} D3DXCOMPRESSION_FLAGS;
+
+typedef enum _D3DXEVENT_TYPE {
+    D3DXEVENT_TRACKSPEED = 0,
+    D3DXEVENT_TRACKWEIGHT = 1,
+    D3DXEVENT_TRACKPOSITION = 2,
+    D3DXEVENT_TRACKENABLE = 3,
+    D3DXEVENT_PRIORITYBLEND = 4,
+    
+    D3DXEVENT_FORCE_DWORD = 0x7fffffff
+} D3DXEVENT_TYPE;
+
+
+/*FIXME: move to d3dx9mesh.h*/
+
+typedef enum _D3DXCLEANTYPE {
+    D3DXCLEAN_BACKFACING = 1,
+    D3DXCLEAN_BOWTIES = 2,
+    D3DXCLEAN_SKINNING = D3DXCLEAN_BACKFACING,
+    D3DXCLEAN_OPTIMIZATION = D3DXCLEAN_BACKFACING,
+    D3DXCLEAN_SIMPLIFICATION = D3DXCLEAN_BACKFACING | D3DXCLEAN_BOWTIES
+} D3DXCLEANTYPE;
+
+typedef enum _D3DXEFFECTDEFAULTTYPE {
+    D3DXEDT_STRING = 1,
+    D3DXEDT_FLOATS = 2,
+    D3DXEDT_DWORD = 3,
+    
+    D3DXEDT_FORCE_DWORD = 0x7fffffff
+} D3DXEFFECTDEFAULTTYPE;
+
+
+
+/*****************************************************************************
+ * ID3DXBuffer interface
+ */
+#define INTERFACE ID3DXBuffer
+DECLARE_INTERFACE_(ID3DXBuffer,IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+    /*** ID3DXBuffer methods ***/
+    STDMETHOD_(LPVOID,GetBufferPointer)(THIS) PURE;
+    STDMETHOD_(DWORD,GetBufferSize)(THIS) PURE;
+};
+#undef INTERFACE
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define ID3DXBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define ID3DXBuffer_AddRef(p)             (p)->lpVtbl->AddRef(p)
+#define ID3DXBuffer_Release(p)            (p)->lpVtbl->Release(p)
+/*** ID3DXBuffer methods ***/
+#define ID3DXBuffer_GetBufferPointer(p)   (p)->lpVtbl->GetBufferPointer(p)
+#define ID3DXBuffer_GetBufferSize(p)      (p)->lpVtbl->GetBufferSize(p)
+#endif
+#if 1
+/*****************************************************************************
+ * ID3DXFont interface
+ */
+#define INTERFACE ID3DXFont
+DECLARE_INTERFACE_(ID3DXFont,IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+    /*** ID3DXFont methods ***/
+    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
+    STDMETHOD(GetLogFont)(THIS_ PLOGFONTA pLogFont) PURE;
+    STDMETHOD(Begin)(THIS) PURE;
+    STDMETHOD_(INT, DrawTextA)(THIS_ LPCSTR pString, INT Count, LPRECT pRect, DWORD Format,  D3DCOLOR Color) PURE;
+    STDMETHOD_(INT, DrawTextW)(THIS_ LPCWSTR pString, INT Count, LPRECT pRect, DWORD Format,  D3DCOLOR Color) PURE;
+    STDMETHOD(End)(THIS) PURE;
+    STDMETHOD(OnLostDevice)(THIS) PURE;
+    STDMETHOD(OnResetDevice)(THIS) PURE;    
+};
+#undef INTERFACE
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define ID3DXFont_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define ID3DXFont_AddRef(p)             (p)->lpVtbl->AddRef(p)
+#define ID3DXFont_Release(p)            (p)->lpVtbl->Release(p)
+/*** ID3DXFont methods ***/
+#define ID3DXFont_GetDevice(p,a)        (p)->lpVtbl->GetDevice(p,a)
+#define ID3DXFont_GetLogFont(p,a)       (p)->lpVtbl->GetLogFont(p,a)
+#define ID3DXFont_Begin(p)              (p)->lpVtbl->Begin(p)
+#define ID3DXFont_DrawTextA(p,a,b,c,d,e)(p)->lpVtbl->DrawText(p,a,b,c,d,e)
+#define ID3DXFont_DrawTextW(p,a,b,c,d,e)(p)->lpVtbl->DrawText(p,a,b,c,d,e)
+#define ID3DXFont_End(p)                (p)->lpVtbl->End(p)
+
+#define ID3DXFont_OnLostDevice(p)       (p)->lpVtbl->OnLostDevice(p)
+#define ID3DXFont_OnResetDevice(p)      (p)->lpVtbl->OnResetDevice(p)
+#endif
+
+
+
+#ifndef DrawText
+#ifdef UNICODE
+#define DrawText DrawTextW
+#else
+#define DrawText DrawTextA
+#endif
+#endif
+#endif
+
+#define INTERFACE ID3DXSprite
+DECLARE_INTERFACE_(ID3DXSprite, IUnknown)
+{
+    /** IUnknown **/
+    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
+    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG, Release)(THIS) PURE;
+
+    /** ID3DXSprite **/
+    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
+    STDMETHOD(Begin)(THIS) PURE;
+    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE9  pSrcTexture,  CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling,  CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation, CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color) PURE;
+    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE9 pSrcTexture, CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform,        D3DCOLOR Color) PURE;
+    STDMETHOD(End)(THIS) PURE;
+    STDMETHOD(OnLostDevice)(THIS) PURE;
+    STDMETHOD(OnResetDevice)(THIS) PURE;
+};
+#undef INTERFACE
+
+
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define ID3DXSprite_QueryInterface(p,a,b)         (p)->lpVtbl->QueryInterface(p,a,b)
+#define ID3DXSprite_AddRef(p)                     (p)->lpVtbl->AddRef(p)
+#define ID3DXSprite_Release(p)                    (p)->lpVtbl->Release(p)
+/*** ID3DXSprite methods ***/
+#define ID3DXSprite_GetDevice(p,a)                (p)->lpVtbl->GetDevice(p,a)
+#define ID3DXSprite_Begin(p)                      (p)->lpVtbl->Begin(p)
+#define ID3DXSprite_DrawTransform(p,a,b,c,d)      (p)->lpVtbl->DrawText(p,a,b,c,d)
+#define ID3DXSprite_End(p)                        (p)->lpVtbl->End(p)
+#define ID3DXSprite_OnLostDevice(p)               (p)->lpVtbl->OnLostDevice(p)
+#define ID3DXSprite_OnResetDevice(p)              (p)->lpVtbl->OnResetDevice(p)
+#endif
+
+
+
+
+
+typedef struct D3DXFONT_DESCA {
+    INT Height;
+    UINT Width;
+    UINT Weight;
+    UINT MipLevels;
+    BOOL Italic;
+    BYTE CharSet;
+    BYTE OutputPrecision;
+    BYTE Quality;
+    BYTE PitchAndFamily;
+    LPCSTR FaceName[LF_FACESIZE];
+} D3DXFONT_DESCA;
+
+typedef struct D3DXFONT_DESCW {
+    INT Height;
+    UINT Width;
+    UINT Weight;
+    UINT MipLevels;
+    BOOL Italic;
+    BYTE CharSet;
+    BYTE OutputPrecision;
+    BYTE Quality;
+    BYTE PitchAndFamily;
+    LPCWSTR FaceName[LF_FACESIZE];
+} D3DXFONT_DESCW;
+
+
+
+
+#ifdef UNICODE
+typedef D3DXFONT_DESCW D3DXFONT_DESC;
+typedef D3DXFONT_DESC* LPD3DXFONT_DESC;
+#else
+typedef D3DXFONT_DESCA D3DXFONT_DESC;
+typedef D3DXFONT_DESC* LPD3DXFONT_DESC;
+#endif
+
+
+
+
+
+// {0B8D1536-9EEC-49b0-A5AD-93CF63AFB7C6}
+DEFINE_GUID( IID_ID3DXFont, 
+0xb8d1536, 0x9eec, 0x49b0, 0xa5, 0xad, 0x93, 0xcf, 0x63, 0xaf, 0xb7, 0xc6);
+
+
+#undef INTERFACE
+#if 0
+#define INTERFACE ID3DXFont
+
+DECLARE_INTERFACE_(ID3DXFont, IUnknown)
+{
+    // IUnknown
+    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
+    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG, Release)(THIS) PURE;
+
+    // ID3DXFont
+    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9 *ppDevice) PURE;
+    STDMETHOD(GetDescA)(THIS_ D3DXFONT_DESCA *pDesc) PURE;
+    STDMETHOD(GetDescW)(THIS_ D3DXFONT_DESCW *pDesc) PURE;
+
+    STDMETHOD_(HDC, GetDC)(THIS) PURE;
+    STDMETHOD(GetGlyphData)(THIS_ UINT Glyph, LPDIRECT3DTEXTURE9 *ppTexture, RECT *pBlackBox, POINT *pCellInc) PURE;
+
+    STDMETHOD(PreloadCharacters)(THIS_ UINT First, UINT Last) PURE;
+    STDMETHOD(PreloadGlyphs)(THIS_ UINT First, UINT Last) PURE;
+    STDMETHOD(PreloadTextA)(THIS_ LPCSTR pString, INT Count) PURE;
+    STDMETHOD(PreloadTextW)(THIS_ LPCWSTR pString, INT Count) PURE;
+
+    STDMETHOD_(INT, DrawTextA)(THIS_ LPD3DXSPRITE pSprite, LPCSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) PURE;
+    STDMETHOD_(INT, DrawTextW)(THIS_ LPD3DXSPRITE pSprite, LPCWSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) PURE;
+
+    STDMETHOD(OnLostDevice)(THIS) PURE;
+    STDMETHOD(OnResetDevice)(THIS) PURE;
+
+#ifdef __cplusplus
+#ifdef UNICODE
+    HRESULT GetDesc(D3DXFONT_DESCW *pDesc) { return GetDescW(pDesc); }
+    HRESULT PreloadText(LPCWSTR pString, INT Count) { return PreloadTextW(pString, Count); }
+#else
+    HRESULT GetDesc(D3DXFONT_DESCA *pDesc) { return GetDescA(pDesc); }
+    HRESULT PreloadText(LPCSTR pString, INT Count) { return PreloadTextA(pString, Count); }
+#endif
+#endif //__cplusplus
+};
+#endif
+
+#ifndef DrawText
+#ifdef UNICODE
+#define DrawText DrawTextW
+#else
+#define DrawText DrawTextA
+#endif
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+
+HRESULT WINAPI 
+    D3DXCreateFontA(
+        LPDIRECT3DDEVICE9       pDevice,  
+        UINT                    Height,
+        UINT                    Width,
+        UINT                    Weight,
+        UINT                    MipLevels,
+        BOOL                    Italic,
+        DWORD                   CharSet,
+        DWORD                   OutputPrecision,
+        DWORD                   Quality,
+        DWORD                   PitchAndFamily,
+        LPCSTR                  pFaceName,
+        LPD3DXFONT*             ppFont);
+
+HRESULT WINAPI 
+    D3DXCreateFontW(
+        LPDIRECT3DDEVICE9       pDevice,  
+        UINT                    Height,
+        UINT                    Width,
+        UINT                    Weight,
+        UINT                    MipLevels,
+        BOOL                    Italic,
+        DWORD                   CharSet,
+        DWORD                   OutputPrecision,
+        DWORD                   Quality,
+        DWORD                   PitchAndFamily,
+        LPCWSTR                 pFaceName,
+        LPD3DXFONT*             ppFont);
+
+#ifdef UNICODE
+#define D3DXCreateFont D3DXCreateFontW
+#else
+#define D3DXCreateFont D3DXCreateFontA
+#endif
+
+
+HRESULT WINAPI 
+    D3DXCreateFontIndirectA( 
+        LPDIRECT3DDEVICE9       pDevice, 
+        CONST D3DXFONT_DESCA*   pDesc, 
+        LPD3DXFONT*             ppFont);
+
+HRESULT WINAPI 
+    D3DXCreateFontIndirectW( 
+        LPDIRECT3DDEVICE9       pDevice, 
+        CONST D3DXFONT_DESCW*   pDesc, 
+        LPD3DXFONT*             ppFont);
+
+#ifdef UNICODE
+#define D3DXCreateFontIndirect D3DXCreateFontIndirectW
+#else
+#define D3DXCreateFontIndirect D3DXCreateFontIndirectA
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+
+
+
+/*************************************************************************************
+ * Define entrypoints 
+ */
+HRESULT WINAPI D3DXCreateBuffer(DWORD NumBytes, LPD3DXBUFFER* ppBuffer);
+#if 0
+HRESULT WINAPI D3DXCreateFont(LPDIRECT3DDEVICE9 pDevice  , HFONT hFont, LPD3DXFONT* ppFont);
+#endif
+HRESULT WINAPI D3DXCreateSprite(LPDIRECT3DDEVICE9 pDevice, HFONT hFont, LPD3DXSPRITE* ppSprite);
+
+
+UINT WINAPI D3DXGetFVFVertexSize(DWORD FVF);
+HRESULT WINAPI D3DXAssembleShader(LPCVOID pSrcData, UINT SrcDataLen, DWORD Flags, 
+			   LPD3DXBUFFER* ppConstants, 
+			   LPD3DXBUFFER* ppCompiledShader,
+			   LPD3DXBUFFER* ppCompilationErrors);
+HRESULT WINAPI D3DXAssembleShaderFromFileA(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors);
+HRESULT WINAPI D3DXAssembleShaderFromFileW(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors);
+
+#endif /* __WINE_D3DX9CORE_H */
+
+
diff -urN wine.20050419/include/d3dx9math.h wine.20050419.dx9/include/d3dx9math.h
--- wine.20050419/include/d3dx9math.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/include/d3dx9math.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,1219 @@
+
+/*
+ * Copyright (C) 2005 Oliver Stieber
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+ 
+#ifndef __WINE_D3DX9MATH_H
+#define __WINE_D3DX9MATH_H
+
+#define D3DX_PI    ((FLOAT)  3.141592654f)
+#define D3DX_1BYPI ((FLOAT)  0.318309886f)
+
+#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
+#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))
+
+
+/* *************************************
+*
+* 16 bit floating point numbers
+*
+************************************** */
+
+#define D3DX_16F_DIG          3
+#define D3DX_16F_EPSILON      4.8875809e-4f
+#define D3DX_16F_MANT_DIG     11
+#define D3DX_16F_MAX          6.550400e+004
+#define D3DX_16F_MAX_10_EXP   4
+#define D3DX_16F_MAX_EXP      15
+#define D3DX_16F_MIN          6.1035156e-5f
+#define D3DX_16F_MIN_10_EXP   (-4)
+#define D3DX_16F_MIN_EXP      (-12)
+#define D3DX_16F_RADIX        2
+#define D3DX_16F_ROUNDS       1
+
+
+
+/*** PRT Constants ***/
+#define D3DXSH_MINORDER      2
+#define D3DXSH_MAXORDER      6
+
+
+
+typedef struct D3DXFLOAT16
+{
+#ifdef __cplusplus
+public:
+    D3DXFLOAT16() {};
+    D3DXFLOAT16( FLOAT );
+    D3DXFLOAT16( CONST D3DXFLOAT16& );
+    
+    operator FLOAT ();
+    
+    BOOL operator == ( CONST D3DXFLOAT16& ) const;
+    BOOL operator != ( CONST D3DXFLOAT16& ) const;
+
+protected:
+#endif //__cplusplus
+    WORD value;
+} D3DXFLOAT16, *LPD3DXFLOAT16;
+
+
+
+/* *************************************
+*
+* Vectors
+*
+************************************** */
+
+typedef struct D3DXVECTOR2
+{
+#ifdef __cplusplus
+public:
+    D3DXVECTOR2() {};
+    D3DXVECTOR2( CONST FLOAT * );
+    D3DXVECTOR2( CONST D3DXFLOAT16 * );
+    D3DXVECTOR2( FLOAT x, FLOAT y );
+
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
+    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
+    D3DXVECTOR2& operator *= ( FLOAT );
+    D3DXVECTOR2& operator /= ( FLOAT );
+
+    D3DXVECTOR2 operator + () const;
+    D3DXVECTOR2 operator - () const;
+
+    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
+    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
+    D3DXVECTOR2 operator * ( FLOAT ) const;
+    D3DXVECTOR2 operator / ( FLOAT ) const;
+
+    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );
+
+    BOOL operator == ( CONST D3DXVECTOR2& ) const;
+    BOOL operator != ( CONST D3DXVECTOR2& ) const;
+
+
+public:
+#endif /* __cplusplus */
+    FLOAT x, y;
+} D3DXVECTOR2, *LPD3DXVECTOR2;
+
+
+typedef struct D3DXVECTOR2_16F
+{
+#ifdef __cplusplus
+public:
+    D3DXVECTOR2_16F() {};
+    D3DXVECTOR2_16F( CONST FLOAT * );
+    D3DXVECTOR2_16F( CONST D3DXFLOAT16 * );
+    D3DXVECTOR2_16F( CONST D3DXFLOAT16 &x, CONST D3DXFLOAT16 &y );
+    
+    operator D3DXFLOAT16* ();
+    operator CONST D3DXFLOAT16* () const;
+    
+    BOOL operator == ( CONST D3DXVECTOR2_16F& ) const;
+    BOOL operator != ( CONST D3DXVECTOR2_16F& ) const;
+
+public:
+#endif /* __cplusplus */ 
+    D3DXFLOAT16 x, y;
+
+} D3DXVECTOR2_16F, *LPD3DXVECTOR2_16F;
+
+
+#ifdef __cplusplus
+typedef struct D3DXVECTOR3 : public D3DVECTOR
+{
+public:
+    D3DXVECTOR3() {};
+    D3DXVECTOR3( CONST FLOAT * );
+    D3DXVECTOR3( CONST D3DVECTOR& );
+    D3DXVECTOR3( CONST D3DXFLOAT16 * );
+    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );
+
+    // casting
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
+    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
+    D3DXVECTOR3& operator *= ( FLOAT );
+    D3DXVECTOR3& operator /= ( FLOAT );
+
+    D3DXVECTOR3 operator  + () const;
+    D3DXVECTOR3 operator  - () const;
+    
+    D3DXVECTOR3 operator  + ( CONST D3DXVECTOR3& ) const;
+    D3DXVECTOR3 operator  - ( CONST D3DXVECTOR3& ) const;
+    D3DXVECTOR3 operator  * ( FLOAT ) const;
+    D3DXVECTOR3 operator  / ( FLOAT ) const;
+
+    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );
+
+    BOOL operator == ( CONST D3DXVECTOR3& ) const;
+    BOOL operator != ( CONST D3DXVECTOR3& ) const;
+
+} D3DXVECTOR3, *LPD3DXVECTOR3;
+
+#else
+typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
+#endif /* __cplusplus */ 
+
+
+typedef struct D3DXVECTOR3_16F
+{
+#ifdef __cplusplus
+public:
+    D3DXVECTOR3_16F() {};
+    D3DXVECTOR3_16F( CONST FLOAT * );
+    D3DXVECTOR3_16F( CONST D3DVECTOR& );
+    D3DXVECTOR3_16F( CONST D3DXFLOAT16 * );
+    D3DXVECTOR3_16F( CONST D3DXFLOAT16 &x, CONST D3DXFLOAT16 &y, CONST D3DXFLOAT16 &z );
+    
+    operator D3DXFLOAT16* ();
+    operator CONST D3DXFLOAT16* () const;
+    
+    BOOL operator == ( CONST D3DXVECTOR3_16F& ) const;
+    BOOL operator != ( CONST D3DXVECTOR3_16F& ) const;
+
+public:
+#endif /* __cplusplus */ 
+    D3DXFLOAT16 x, y, z;
+
+} D3DXVECTOR3_16F, *LPD3DXVECTOR3_16F;
+
+typedef struct D3DXVECTOR4
+{
+#ifdef __cplusplus
+public:
+    D3DXVECTOR4() {};
+    D3DXVECTOR4( CONST FLOAT* );
+    D3DXVECTOR4( CONST D3DXFLOAT16 * );
+    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
+
+    // casting
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    // assignment operators
+    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
+    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
+    D3DXVECTOR4& operator *= ( FLOAT );
+    D3DXVECTOR4& operator /= ( FLOAT );
+
+    // unary operators
+    D3DXVECTOR4 operator + () const;
+    D3DXVECTOR4 operator - () const;
+
+    // binary operators
+    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
+    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
+    D3DXVECTOR4 operator * ( FLOAT ) const;
+    D3DXVECTOR4 operator / ( FLOAT ) const;
+
+    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );
+
+    BOOL operator == ( CONST D3DXVECTOR4& ) const;
+    BOOL operator != ( CONST D3DXVECTOR4& ) const;
+
+public:
+#endif //__cplusplus
+    FLOAT x, y, z, w;
+} D3DXVECTOR4, *LPD3DXVECTOR4;
+
+
+typedef struct D3DXVECTOR4_16F
+{
+#ifdef __cplusplus
+public:
+    D3DXVECTOR4_16F() {};
+    D3DXVECTOR4_16F( CONST FLOAT * );
+    D3DXVECTOR4_16F( CONST D3DXFLOAT16 * );
+    D3DXVECTOR4_16F( CONST D3DXFLOAT16& x, CONST D3DXFLOAT16& y, CONST D3DXFLOAT16& z, CONST D3DXFLOAT16& w );
+
+    // casting
+    operator D3DXFLOAT16* ();
+    operator CONST D3DXFLOAT16* () const;
+
+    // binary operators
+    BOOL operator == ( CONST D3DXVECTOR4_16F& ) const;
+    BOOL operator != ( CONST D3DXVECTOR4_16F& ) const;
+
+public:
+#endif //__cplusplus
+    D3DXFLOAT16 x, y, z, w;
+
+} D3DXVECTOR4_16F, *LPD3DXVECTOR4_16F;
+
+
+
+/* *************************************
+*
+* Martix
+*
+************************************** */
+
+#ifdef __cplusplus
+typedef struct D3DXMATRIX : public D3DMATRIX
+{
+public:
+    D3DXMATRIX() {};
+    D3DXMATRIX( CONST FLOAT * );
+    D3DXMATRIX( CONST D3DMATRIX& );
+    D3DXMATRIX( CONST D3DXFLOAT16 * );
+    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
+                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
+                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
+                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
+
+
+    // access grants
+    FLOAT& operator () ( UINT Row, UINT Col );
+    FLOAT  operator () ( UINT Row, UINT Col ) const;
+
+    // casting operators
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    // assignment operators
+    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
+    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
+    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
+    D3DXMATRIX& operator *= ( FLOAT );
+    D3DXMATRIX& operator /= ( FLOAT );
+
+    // unary operators
+    D3DXMATRIX operator + () const;
+    D3DXMATRIX operator - () const;
+
+    // binary operators
+    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
+    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
+    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
+    D3DXMATRIX operator * ( FLOAT ) const;
+    D3DXMATRIX operator / ( FLOAT ) const;
+
+    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );
+
+    BOOL operator == ( CONST D3DXMATRIX& ) const;
+    BOOL operator != ( CONST D3DXMATRIX& ) const;
+
+} D3DXMATRIX, *LPD3DXMATRIX;
+
+#else //!__cplusplus
+typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
+#endif //!__cplusplus
+
+#ifdef __cplusplus
+typedef struct _D3DXMATRIXA16 : public D3DXMATRIX
+{
+    _D3DXMATRIXA16() {}
+    _D3DXMATRIXA16( CONST FLOAT * );
+    _D3DXMATRIXA16( CONST D3DMATRIX& );
+    _D3DXMATRIXA16( CONST D3DXFLOAT16 * );
+    _D3DXMATRIXA16( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
+                    FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
+                    FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
+                    FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
+
+    // new operators
+    void* operator new   ( size_t );
+    void* operator new[] ( size_t );
+
+    // delete operators
+    void operator delete   ( void* );   // These are NOT virtual; Do not 
+    void operator delete[] ( void* );   // cast to D3DXMATRIX and delete.
+    
+    // assignment operators
+    _D3DXMATRIXA16& operator = ( CONST D3DXMATRIX& );
+
+} _D3DXMATRIXA16;
+
+#else //!__cplusplus
+typedef D3DXMATRIX  _D3DXMATRIXA16;
+#endif //!__cplusplus
+
+#if _MSC_VER >= 1300  // VC7
+#define D3DX_ALIGN16 __declspec(align(16))
+#else
+#define D3DX_ALIGN16  // Earlier compiler may not understand this, do nothing.
+#endif
+
+typedef D3DX_ALIGN16 _D3DXMATRIXA16 D3DXMATRIXA16, *LPD3DXMATRIXA16;
+
+
+
+
+typedef struct D3DXQUATERNION
+{
+#ifdef __cplusplus
+public:
+    D3DXQUATERNION() {}
+    D3DXQUATERNION( CONST FLOAT * );
+    D3DXQUATERNION( CONST D3DXFLOAT16 * );
+    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
+
+    // casting
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    // assignment operators
+    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
+    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
+    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
+    D3DXQUATERNION& operator *= ( FLOAT );
+    D3DXQUATERNION& operator /= ( FLOAT );
+
+    // unary operators
+    D3DXQUATERNION  operator + () const;
+    D3DXQUATERNION  operator - () const;
+
+    // binary operators
+    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
+    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
+    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
+    D3DXQUATERNION operator * ( FLOAT ) const;
+    D3DXQUATERNION operator / ( FLOAT ) const;
+
+    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );
+
+    BOOL operator == ( CONST D3DXQUATERNION& ) const;
+    BOOL operator != ( CONST D3DXQUATERNION& ) const;
+
+#endif //__cplusplus
+    FLOAT x, y, z, w;
+} D3DXQUATERNION, *LPD3DXQUATERNION;
+
+
+typedef struct D3DXPLANE
+{
+#ifdef __cplusplus
+public:
+    D3DXPLANE() {}
+    D3DXPLANE( CONST FLOAT* );
+    D3DXPLANE( CONST D3DXFLOAT16* );
+    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );
+
+    // casting
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    // unary operators
+    D3DXPLANE operator + () const;
+    D3DXPLANE operator - () const;
+
+    // binary operators
+    BOOL operator == ( CONST D3DXPLANE& ) const;
+    BOOL operator != ( CONST D3DXPLANE& ) const;
+
+#endif //__cplusplus
+    FLOAT a, b, c, d;
+} D3DXPLANE, *LPD3DXPLANE;
+
+
+typedef struct D3DXCOLOR
+{
+#ifdef __cplusplus
+public:
+    D3DXCOLOR() {}
+    D3DXCOLOR( DWORD argb );
+    D3DXCOLOR( CONST FLOAT * );
+    D3DXCOLOR( CONST D3DXFLOAT16 * );
+    D3DXCOLOR( CONST D3DCOLORVALUE& );
+    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );
+
+    // casting
+    operator DWORD () const;
+
+    operator FLOAT* ();
+    operator CONST FLOAT* () const;
+
+    operator D3DCOLORVALUE* ();
+    operator CONST D3DCOLORVALUE* () const;
+
+    operator D3DCOLORVALUE& ();
+    operator CONST D3DCOLORVALUE& () const;
+
+    // assignment operators
+    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
+    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
+    D3DXCOLOR& operator *= ( FLOAT );
+    D3DXCOLOR& operator /= ( FLOAT );
+
+    // unary operators
+    D3DXCOLOR operator + () const;
+    D3DXCOLOR operator - () const;
+
+    // binary operators
+    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
+    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
+    D3DXCOLOR operator * ( FLOAT ) const;
+    D3DXCOLOR operator / ( FLOAT ) const;
+
+    friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR& );
+
+    BOOL operator == ( CONST D3DXCOLOR& ) const;
+    BOOL operator != ( CONST D3DXCOLOR& ) const;
+
+#endif //__cplusplus
+    FLOAT r, g, b, a;
+} D3DXCOLOR, *LPD3DXCOLOR;
+
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Converts an array 32-bit floats to 16-bit floats
+D3DXFLOAT16* WINAPI D3DXFloat32To16Array
+    ( D3DXFLOAT16 *pOut, CONST FLOAT *pIn, UINT n );
+
+// Converts an array 16-bit floats to 32-bit floats
+FLOAT* WINAPI D3DXFloat16To32Array
+    ( FLOAT *pOut, CONST D3DXFLOAT16 *pIn, UINT n );
+
+#ifdef __cplusplus
+}
+#endif
+
+FLOAT D3DXVec2Length
+    ( CONST D3DXVECTOR2 *pV );
+
+FLOAT D3DXVec2LengthSq
+    ( CONST D3DXVECTOR2 *pV );
+
+FLOAT D3DXVec2Dot
+    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+// Z component of ((x1,y1,0) cross (x2,y2,0))
+FLOAT D3DXVec2CCW
+    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+D3DXVECTOR2* D3DXVec2Add
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+D3DXVECTOR2* D3DXVec2Subtract
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
+D3DXVECTOR2* D3DXVec2Minimize
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
+D3DXVECTOR2* D3DXVec2Maximize
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
+
+D3DXVECTOR2* D3DXVec2Scale
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );
+
+// Linear interpolation. V1 + s(V2-V1)
+D3DXVECTOR2* D3DXVec2Lerp
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
+      FLOAT s );
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+D3DXVECTOR2* WINAPI D3DXVec2Normalize
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );
+
+// Hermite interpolation between position V1, tangent T1 (when s == 0)
+// and position V2, tangent T2 (when s == 1).
+D3DXVECTOR2* WINAPI D3DXVec2Hermite
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
+      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );
+
+// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
+D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
+      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );
+
+// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
+D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
+      CONST D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);
+
+// Transform (x, y, 0, 1) by matrix.
+D3DXVECTOR4* WINAPI D3DXVec2Transform
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
+
+// Transform (x, y, 0, 1) by matrix, project result back into w=1.
+D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
+
+// Transform (x, y, 0, 0) by matrix.
+D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
+    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
+     
+// Transform Array (x, y, 0, 1) by matrix.
+D3DXVECTOR4* WINAPI D3DXVec2TransformArray
+    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n);
+
+// Transform Array (x, y, 0, 1) by matrix, project result back into w=1.
+D3DXVECTOR2* WINAPI D3DXVec2TransformCoordArray
+    ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+
+// Transform Array (x, y, 0, 0) by matrix.
+D3DXVECTOR2* WINAPI D3DXVec2TransformNormalArray
+    ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+    
+    
+
+#ifdef __cplusplus
+}
+#endif
+
+
+//--------------------------
+// 3D Vector
+//--------------------------
+
+// inline
+
+FLOAT D3DXVec3Length
+    ( CONST D3DXVECTOR3 *pV );
+
+FLOAT D3DXVec3LengthSq
+    ( CONST D3DXVECTOR3 *pV );
+
+FLOAT D3DXVec3Dot
+    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+D3DXVECTOR3* D3DXVec3Cross
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+D3DXVECTOR3* D3DXVec3Add
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+D3DXVECTOR3* D3DXVec3Subtract
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
+D3DXVECTOR3* D3DXVec3Minimize
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
+D3DXVECTOR3* D3DXVec3Maximize
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
+
+D3DXVECTOR3* D3DXVec3Scale
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);
+
+// Linear interpolation. V1 + s(V2-V1)
+D3DXVECTOR3* D3DXVec3Lerp
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
+      FLOAT s );
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+D3DXVECTOR3* WINAPI D3DXVec3Normalize
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );
+
+// Hermite interpolation between position V1, tangent T1 (when s == 0)
+// and position V2, tangent T2 (when s == 1).
+D3DXVECTOR3* WINAPI D3DXVec3Hermite
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
+      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );
+
+// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
+D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
+      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );
+
+// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
+D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
+      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);
+
+// Transform (x, y, z, 1) by matrix.
+D3DXVECTOR4* WINAPI D3DXVec3Transform
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
+
+// Transform (x, y, z, 1) by matrix, project result back into w=1.
+D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
+
+// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a 
+// non-affine matrix, the matrix you pass to this function should be the 
+// transpose of the inverse of the matrix you would use to transform a coord.
+D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
+    
+    
+// Transform Array (x, y, z, 1) by matrix. 
+D3DXVECTOR4* WINAPI D3DXVec3TransformArray
+    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+
+// Transform Array (x, y, z, 1) by matrix, project result back into w=1.
+D3DXVECTOR3* WINAPI D3DXVec3TransformCoordArray
+    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+
+// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a 
+// non-affine matrix, the matrix you pass to this function should be the 
+// transpose of the inverse of the matrix you would use to transform a coord.
+D3DXVECTOR3* WINAPI D3DXVec3TransformNormalArray
+    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+
+// Project vector from object space into screen space
+D3DXVECTOR3* WINAPI D3DXVec3Project
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
+      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
+
+// Project vector from screen space into object space
+D3DXVECTOR3* WINAPI D3DXVec3Unproject
+    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
+      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
+      
+// Project vector Array from object space into screen space
+D3DXVECTOR3* WINAPI D3DXVec3ProjectArray
+    ( D3DXVECTOR3 *pOut, UINT OutStride,CONST D3DXVECTOR3 *pV, UINT VStride,CONST D3DVIEWPORT9 *pViewport,
+      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
+
+// Project vector Array from screen space into object space
+D3DXVECTOR3* WINAPI D3DXVec3UnprojectArray
+    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DVIEWPORT9 *pViewport,
+      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+//--------------------------
+// 4D Vector
+//--------------------------
+
+// inline
+
+FLOAT D3DXVec4Length
+    ( CONST D3DXVECTOR4 *pV );
+
+FLOAT D3DXVec4LengthSq
+    ( CONST D3DXVECTOR4 *pV );
+
+FLOAT D3DXVec4Dot
+    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );
+
+D3DXVECTOR4* D3DXVec4Add
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
+
+D3DXVECTOR4* D3DXVec4Subtract
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
+
+// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
+D3DXVECTOR4* D3DXVec4Minimize
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
+
+// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
+D3DXVECTOR4* D3DXVec4Maximize
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
+
+D3DXVECTOR4* D3DXVec4Scale
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);
+
+// Linear interpolation. V1 + s(V2-V1)
+D3DXVECTOR4* D3DXVec4Lerp
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
+      FLOAT s );
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Cross-product in 4 dimensions.
+D3DXVECTOR4* WINAPI D3DXVec4Cross
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
+      CONST D3DXVECTOR4 *pV3);
+
+D3DXVECTOR4* WINAPI D3DXVec4Normalize
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );
+
+// Hermite interpolation between position V1, tangent T1 (when s == 0)
+// and position V2, tangent T2 (when s == 1).
+D3DXVECTOR4* WINAPI D3DXVec4Hermite
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
+      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );
+
+// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
+D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
+      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );
+
+// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
+D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
+      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);
+
+// Transform vector by matrix.
+D3DXVECTOR4* WINAPI D3DXVec4Transform
+    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );
+    
+// Transform vector array by matrix.
+D3DXVECTOR4* WINAPI D3DXVec4TransformArray
+    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR4 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
+
+#ifdef __cplusplus
+}
+#endif
+
+
+//--------------------------
+// 4D Matrix
+//--------------------------
+
+// inline
+
+
+            
+inline static D3DXMATRIX* D3DXMatrixIdentity   ( D3DXMATRIX *pOut ){
+
+   pOut->_11 = 1;
+   pOut->_12 = 0;
+   pOut->_13 = 0;
+   pOut->_14 = 0;
+
+   pOut->_21 = 0;
+   pOut->_22 = 1;
+   pOut->_23 = 0;
+   pOut->_24 = 0;
+
+   pOut->_31 = 0;
+   pOut->_32 = 1;
+   pOut->_33 = 0;
+   pOut->_34 = 0;
+
+   pOut->_41 = 0;
+   pOut->_42 = 0;
+   pOut->_43 = 0;
+   pOut->_44 = 1;
+
+   return pOut; 
+
+}
+
+inline static BOOL D3DXMatrixIsIdentity(      
+    CONST D3DXMATRIX *pM
+){
+return (pM->_11 == 1 &&
+       pM->_12 == 0 &&
+       pM->_13 == 0 &&
+       pM->_14 == 0 &&
+       pM->_21 == 0 &&
+       pM->_22 == 1 &&
+       pM->_23 == 0 &&
+       pM->_24 == 0 &&
+       pM->_31 == 0 &&
+       pM->_32 == 0 &&
+       pM->_33 == 1 &&
+       pM->_34 == 0 &&
+       pM->_41 == 0 &&
+       pM->_42 == 0 &&
+       pM->_43 == 0 &&
+       pM->_44 == 1) ? TRUE:FALSE;       
+       
+}
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+FLOAT WINAPI D3DXMatrixDeterminant
+    ( CONST D3DXMATRIX *pM );
+
+D3DXMATRIX* WINAPI D3DXMatrixTranspose
+    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );
+
+// Matrix multiplication.  The result represents the transformation M2
+// followed by the transformation M1.  (Out = M1 * M2)
+D3DXMATRIX* WINAPI D3DXMatrixMultiply
+    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
+
+// Matrix multiplication, followed by a transpose. (Out = T(M1 * M2))
+D3DXMATRIX* WINAPI D3DXMatrixMultiplyTranspose
+    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
+
+// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
+// be returned.  The determinant of pM is also returned it pfDeterminant
+// is non-NULL.
+D3DXMATRIX* WINAPI D3DXMatrixInverse
+    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );
+
+// Build a matrix which scales by (sx, sy, sz)
+D3DXMATRIX* WINAPI D3DXMatrixScaling
+    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );
+
+// Build a matrix which translates by (x, y, z)
+D3DXMATRIX* WINAPI D3DXMatrixTranslation
+    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );
+
+// Build a matrix which rotates around the X axis
+D3DXMATRIX* WINAPI D3DXMatrixRotationX
+    ( D3DXMATRIX *pOut, FLOAT Angle );
+
+// Build a matrix which rotates around the Y axis
+D3DXMATRIX* WINAPI D3DXMatrixRotationY
+    ( D3DXMATRIX *pOut, FLOAT Angle );
+
+// Build a matrix which rotates around the Z axis
+D3DXMATRIX* WINAPI D3DXMatrixRotationZ
+    ( D3DXMATRIX *pOut, FLOAT Angle );
+
+// Build a matrix which rotates around an arbitrary axis
+D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
+    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
+
+// Build a matrix from a quaternion
+D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
+    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);
+
+// Yaw around the Y axis, a pitch around the X axis,
+// and a roll around the Z axis.
+D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
+    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
+
+
+// Build transformation matrix.  NULL arguments are treated as identity.
+// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
+D3DXMATRIX* WINAPI D3DXMatrixTransformation
+    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
+      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
+      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
+      CONST D3DXVECTOR3 *pTranslation);
+
+// Build affine transformation matrix.  NULL arguments are treated as identity.
+// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
+D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
+    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
+      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);
+
+// Build a lookat matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
+    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
+      CONST D3DXVECTOR3 *pUp );
+
+// Build a lookat matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
+    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
+      CONST D3DXVECTOR3 *pUp );
+
+// Build a perspective projection matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
+    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
+
+// Build a perspective projection matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
+    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
+
+// Build a perspective projection matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
+    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
+
+// Build a perspective projection matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
+    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
+
+// Build a perspective projection matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
+    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
+      FLOAT zf );
+
+// Build a perspective projection matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
+    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
+      FLOAT zf );
+
+// Build an ortho projection matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
+    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
+
+// Build an ortho projection matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
+    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
+
+// Build an ortho projection matrix. (right-handed)
+D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
+    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
+      FLOAT zf );
+
+// Build an ortho projection matrix. (left-handed)
+D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
+    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
+      FLOAT zf );
+
+// Build a matrix which flattens geometry into a plane, as if casting
+// a shadow from a light.
+D3DXMATRIX* WINAPI D3DXMatrixShadow
+    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
+      CONST D3DXPLANE *pPlane );
+
+// Build a matrix which reflects the coordinate system about a plane
+D3DXMATRIX* WINAPI D3DXMatrixReflect
+    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );
+
+#ifdef __cplusplus
+}
+#endif
+
+
+//--------------------------
+// Quaternion
+//--------------------------
+
+// inline
+
+FLOAT D3DXQuaternionLength
+    ( CONST D3DXQUATERNION *pQ );
+
+// Length squared, or "norm"
+FLOAT D3DXQuaternionLengthSq
+    ( CONST D3DXQUATERNION *pQ );
+
+FLOAT D3DXQuaternionDot
+    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );
+
+// (0, 0, 0, 1)
+D3DXQUATERNION* D3DXQuaternionIdentity
+    ( D3DXQUATERNION *pOut );
+
+BOOL D3DXQuaternionIsIdentity
+    ( CONST D3DXQUATERNION *pQ );
+
+// (-x, -y, -z, w)
+D3DXQUATERNION* D3DXQuaternionConjugate
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
+
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
+void WINAPI D3DXQuaternionToAxisAngle
+    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );
+
+// Build a quaternion from a rotation matrix.
+D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
+    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);
+
+// Rotation about arbitrary axis.
+D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
+    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
+
+// Yaw around the Y axis, a pitch around the X axis,
+// and a roll around the Z axis.
+D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
+    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
+
+// Quaternion multiplication.  The result represents the rotation Q2
+// followed by the rotation Q1.  (Out = Q2 * Q1)
+D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
+      CONST D3DXQUATERNION *pQ2 );
+
+D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
+
+// Conjugate and re-norm
+D3DXQUATERNION* WINAPI D3DXQuaternionInverse
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
+
+// Expects unit quaternions.
+// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
+D3DXQUATERNION* WINAPI D3DXQuaternionLn
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
+
+// Expects pure quaternions. (w == 0)  w is ignored in calculation.
+// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
+D3DXQUATERNION* WINAPI D3DXQuaternionExp
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
+      
+// Spherical linear interpolation between Q1 (t == 0) and Q2 (t == 1).
+// Expects unit quaternions.
+D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
+      CONST D3DXQUATERNION *pQ2, FLOAT t );
+
+// Spherical quadrangle interpolation.
+// Slerp(Slerp(Q1, C, t), Slerp(A, B, t), 2t(1-t))
+D3DXQUATERNION* WINAPI D3DXQuaternionSquad
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
+      CONST D3DXQUATERNION *pA, CONST D3DXQUATERNION *pB,
+      CONST D3DXQUATERNION *pC, FLOAT t );
+
+// Setup control points for spherical quadrangle interpolation
+// from Q1 to Q2.  The control points are chosen in such a way 
+// to ensure the continuity of tangents with adjacent segments.
+void WINAPI D3DXQuaternionSquadSetup
+    ( D3DXQUATERNION *pAOut, D3DXQUATERNION *pBOut, D3DXQUATERNION *pCOut,
+      CONST D3DXQUATERNION *pQ0, CONST D3DXQUATERNION *pQ1, 
+      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3 );
+
+// Barycentric interpolation.
+// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
+D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
+    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
+      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
+      FLOAT f, FLOAT g );
+
+#ifdef __cplusplus
+}
+#endif
+
+
+//--------------------------
+// Plane
+//--------------------------
+
+// inline
+
+// ax + by + cz + dw
+FLOAT D3DXPlaneDot
+    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);
+
+// ax + by + cz + d
+FLOAT D3DXPlaneDotCoord
+    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
+
+// ax + by + cz
+FLOAT D3DXPlaneDotNormal
+    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Normalize plane (so that |a,b,c| == 1)
+D3DXPLANE* WINAPI D3DXPlaneNormalize
+    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);
+
+// Find the intersection between a plane and a line.  If the line is
+// parallel to the plane, NULL is returned.
+D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
+    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
+      CONST D3DXVECTOR3 *pV2);
+
+// Construct a plane from a point and a normal
+D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
+    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);
+
+// Construct a plane from 3 points
+D3DXPLANE* WINAPI D3DXPlaneFromPoints
+    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
+      CONST D3DXVECTOR3 *pV3);
+
+// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
+// M should be the inverse transpose of the transformation desired.
+D3DXPLANE* WINAPI D3DXPlaneTransform
+    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );
+    
+// Transform an array of planes by a matrix.  The vectors (a,b,c) must be normal.
+// M should be the inverse transpose of the transformation desired.
+D3DXPLANE* WINAPI D3DXPlaneTransformArray
+    ( D3DXPLANE *pOut, UINT OutStride, CONST D3DXPLANE *pP, UINT PStride, CONST D3DXMATRIX *pM, UINT n );
+
+#ifdef __cplusplus
+}
+#endif
+
+
+//--------------------------
+// Color
+//--------------------------
+
+// inline
+
+// (1-r, 1-g, 1-b, a)
+D3DXCOLOR* D3DXColorNegative
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);
+
+D3DXCOLOR* D3DXColorAdd
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
+
+D3DXCOLOR* D3DXColorSubtract
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
+
+D3DXCOLOR* D3DXColorScale
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
+
+// (r1*r2, g1*g2, b1*b2, a1*a2)
+D3DXCOLOR* D3DXColorModulate
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
+
+// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
+D3DXCOLOR* D3DXColorLerp
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);
+
+// non-inline
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Interpolate r,g,b between desaturated color and color.
+// DesaturatedColor + s(Color - DesaturatedColor)
+D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
+
+// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
+D3DXCOLOR* WINAPI D3DXColorAdjustContrast
+    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+//--------------------------
+// Misc
+//--------------------------
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Calculate Fresnel term given the cosine of theta (likely obtained by
+// taking the dot of two normals), and the refraction index of the material.
+FLOAT WINAPI D3DXFresnelTerm
+    (FLOAT CosTheta, FLOAT RefractionIndex);     
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+#endif /*__WINE_D3DX9MATH_H*/
diff -urN wine.20050419/include/d3dx9types.h wine.20050419.dx9/include/d3dx9types.h
--- wine.20050419/include/d3dx9types.h	1969-12-31 17:00:00.000000000 -0700
+++ wine.20050419.dx9/include/d3dx9types.h	2005-04-20 01:52:56.000000000 -0600
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2002 Raphael Junqueira
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __WINE_D3DX9TYPES_H
+#define __WINE_D3DX9TYPES_H
+
+#include <objbase.h>
+
+
+#include <d3d9types.h>
+
+
+/*****************************************************************************
+ * #defines and error codes
+ */
+
+/*
+ * Macros
+ */
+ #if 0
+#define D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
+#define D3DSINCOSCONST2 -0.020833334f   , -0.12500000f    ,  1.0f         , 0.50000000f 
+/*FIXME: move over to d3dx9math.h*/
+#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))
+#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
+
+/*** 16-Bit Floating Point Numbers ***/
+#define D3DX_16F_DIG         3
+#define D3DX_16F_EPSILON     4.8875809e-4f
+#define D3DX_16F_MANT_DIG   11
+#define D3DX_16F_MAX         6.5519996e+4f
+#define D3DX_16F_MAX_10_EXP  4
+#define D3DX_16F_MAX_EXP    15
+#define D3DX_16F_MIN         6.1035156e-5f
+#define D3DX_16F_MIN_10_EXP  (-4)
+#define D3DX_16F_MIN_EXP     (-12)
+#define D3DX_16F_RADIX       2
+#define D3DX_16F_ROUNDS      1
+#define D3DX_1BYPI           ((FLOAT) 0.318309886f)
+#define D3DX_PI              ((FLOAT) 3.141592654f)
+
+/*** PRT Constants ***/
+#define D3DXSH_MINORDER      2
+#define D3DXSH_MAXORDER      6
+
+
+
+
+/*FIXME: move over to d3dx9shader.h */
+#define D3DXTX_VERSION(_Major,_Minor) (('T' << 24) | ('X' << 16) | ((_Major) << 8) | (_Minor))
+
+#define D3DXSHADER_AVOID_FLOW_CONTROL
+#define D3DXSHADER_DEBUG
+#define D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT
+#define D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT
+#define D3DXSHADER_NO_PRESHADER
+#define D3DXSHADER_PACKMATRIX_COLUMNMAJOR
+#define D3DXSHADER_PACKMATRIX_ROWMAJOR
+#define D3DXSHADER_PARTIALPRECISION
+#define D3DXSHADER_PREFER_FLOW_CONTROL
+#define D3DXSHADER_SKIPOPTIMIZATION
+#define D3DXSHADER_SKIPVALIDATION
+/******/
+#define D3DXSHADER_DEBUG
+#define D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT
+#define D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT
+#define D3DXSHADER_SKIPVALIDATION
+
+/*FIXME: move to d3dx9tex.h*/
+#define D3DX_CHANNEL_RED
+#define D3DX_CHANNEL_BLUE
+#define D3DX_CHANNEL_GREEN
+#define D3DX_CHANNEL_ALPHA
+#define D3DX_CHANNEL_LUMINANCE
+
+
+#define D3DX_FILTER_NONE
+#define D3DX_FILTER_POINT
+#define D3DX_FILTER_LINEAR
+#define D3DX_FILTER_TRIANGLE
+#define D3DX_FILTER_BOX
+#define D3DX_FILTER_MIRROR_U
+#define D3DX_FILTER_MIRROR_V
+#define D3DX_FILTER_MIRROR_W
+#define D3DX_FILTER_MIRROR
+#define D3DX_FILTER_DITHER
+#define D3DX_FILTER_SRGB_IN
+#define D3DX_FILTER_SRGB_OUT
+#define D3DX_FILTER_SRGB
+
+#define D3DX_NORMALMAP_MIRROR_U
+#define D3DX_NORMALMAP_MIRROR_V
+#define D3DX_NORMALMAP_MIRROR
+#define D3DX_NORMALMAP_INVERTSIGN
+#define D3DX_NORMALMAP_COMPUTE_OCCLUSION
+
+
+/*FIXME: move to d3dx9.h*/
+#define D3DFMT_FROM_FILE
+#define D3DX_DEFAULT
+#define D3DX_DEFAULT_NONPOW2
+#define D3DX_FROM_FILE
+
+#define  D3DX_DEFAULT_FLOAT FLT_MAX
+
+/*FIXME: move to d3d9mesh.h*/
+#defnie D3DX_VERSION     0x0902
+#defnie D3DX_SDK_VERSION 22
+
+/*****************************************************************************
+ * Predeclare the interfaces
+ */
+DEFINE_GUID(IID_ID3DXBuffer,             0x1,0x1,0x4,0xB0,0xCF,0x98,0xFE,0xFD,0xFF,0x95,0x12);/* FIXME */
+typedef struct ID3DXBuffer              ID3DXBuffer, *LPD3DXBUFFER;
+DEFINE_GUID(IID_ID3DXFont,               0x1,0x1,0x4,0xB0,0xCF,0x98,0xFE,0xFD,0xFF,0x95,0x13);/* FIXME */
+typedef struct ID3DXFont                ID3DXFont, *LPD3DXFONT;
+
+/*****************************************************************************
+ * ID3DXBuffer interface
+ */
+#define INTERFACE ID3DXBuffer
+DECLARE_INTERFACE_(ID3DXBuffer,IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+    /*** ID3DXBuffer methods ***/
+    STDMETHOD_(LPVOID,GetBufferPointer)(THIS) PURE;
+    STDMETHOD_(DWORD,GetBufferSize)(THIS) PURE;
+};
+#undef INTERFACE
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define ID3DXBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define ID3DXBuffer_AddRef(p)             (p)->lpVtbl->AddRef(p)
+#define ID3DXBuffer_Release(p)            (p)->lpVtbl->Release(p)
+/*** ID3DXBuffer methods ***/
+#define ID3DXBuffer_GetBufferPointer(p)   (p)->lpVtbl->GetBufferPointer(p)
+#define ID3DXBuffer_GetBufferSize(p)      (p)->lpVtbl->GetBufferSize(p)
+#endif
+
+/*****************************************************************************
+ * ID3DXFont interface
+ */
+#define INTERFACE ID3DXFont
+DECLARE_INTERFACE_(ID3DXFont,IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+    /*** ID3DXFont methods ***/
+    STDMETHOD(Begin)(THIS) PURE;
+    STDMETHOD(DrawTextA)(THIS) PURE;
+    STDMETHOD(End)(THIS) PURE;
+};
+#undef INTERFACE
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define ID3DXFont_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define ID3DXFont_AddRef(p)             (p)->lpVtbl->AddRef(p)
+#define ID3DXFont_Release(p)            (p)->lpVtbl->Release(p)
+/*** ID3DXFont methods ***/
+#define ID3DXFont_Begin(p)              (p)->lpVtbl->Begin(p)
+#define ID3DXFont_DrawTextA(p,a,b,c,d,e)(p)->lpVtbl->DrawText(p,a,b,c,d,e)
+#define ID3DXFont_End(p)                (p)->lpVtbl->End(p)
+#endif
+
+/*************************************************************************************
+ * Define entrypoints 
+ */
+HRESULT WINAPI D3DXCreateBuffer(DWORD NumBytes, LPD3DXBUFFER* ppBuffer);
+HRESULT WINAPI D3DXCreateFont(LPDIRECT3DDEVICE8 pDevice, HFONT hFont, LPD3DXFONT* ppFont);
+UINT WINAPI D3DXGetFVFVertexSize(DWORD FVF);
+HRESULT WINAPI D3DXAssembleShader(LPCVOID pSrcData, UINT SrcDataLen, DWORD Flags, 
+			   LPD3DXBUFFER* ppConstants, 
+			   LPD3DXBUFFER* ppCompiledShader,
+			   LPD3DXBUFFER* ppCompilationErrors);
+HRESULT WINAPI D3DXAssembleShaderFromFileA(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors);
+HRESULT WINAPI D3DXAssembleShaderFromFileW(LPSTR pSrcFile, DWORD Flags,
+				    LPD3DXBUFFER* ppConstants,
+				    LPD3DXBUFFER* ppCompiledShader,
+				    LPD3DXBUFFER* ppCompilationErrors);
+
+				    #endif
+#endif /* __WINE_D3DX9TYPES_H */
diff -urN wine.20050419/include/wine/wined3d_gl.h wine.20050419.dx9/include/wine/wined3d_gl.h
--- wine.20050419/include/wine/wined3d_gl.h	2005-02-08 09:52:04.000000000 -0700
+++ wine.20050419.dx9/include/wine/wined3d_gl.h	2005-04-20 01:52:56.000000000 -0600
@@ -659,6 +659,11 @@
 /* #define ZERO */
 #endif
 
+/*Point sprites*/
+#define GL_POINT_SPRITE_ARB   0x8861
+/*Centre the texture on the vertex*/
+#define GL_COORD_REPLACE_ARB   0x8862
+
 /****************************************************
  * OpenGL Official Version 
  *  defines 
diff -urN wine.20050419/include/wine/wined3d_interface.h wine.20050419.dx9/include/wine/wined3d_interface.h
--- wine.20050419/include/wine/wined3d_interface.h	2005-03-29 12:01:00.000000000 -0700
+++ wine.20050419.dx9/include/wine/wined3d_interface.h	2005-04-20 01:58:28.000000000 -0600
@@ -125,18 +125,12 @@
 # define WINED3DCLIPSTATUS      D3DCLIPSTATUS8
 # define WINED3DMATERIAL        D3DMATERIAL8
 # define WINED3DVIEWPORT        D3DVIEWPORT8
-
- /* Subset: */
-# define WINED3DCAPS            D3DCAPS8
 #else
  /* Identical: */ 
 # define WINED3DLIGHT           D3DLIGHT9
 # define WINED3DCLIPSTATUS      D3DCLIPSTATUS9
 # define WINED3DMATERIAL        D3DMATERIAL9
 # define WINED3DVIEWPORT        D3DVIEWPORT9
-
- /* Subsets: */
-# define WINED3DCAPS            D3DCAPS9
 #endif
 
 typedef struct IWineD3D               IWineD3D;
@@ -155,6 +149,7 @@
 typedef struct IWineD3DVertexShader   IWineD3DVertexShader;
 typedef struct IWineD3DPixelShader    IWineD3DPixelShader;
 typedef struct IWineD3DQuery          IWineD3DQuery;
+typedef struct IWineD3DSwapChain      IWineD3DSwapChain;
 
 /*****************************************************************************
  * Callback functions required for predefining surfaces / stencils
@@ -179,6 +174,17 @@
                                                IWineD3DSurface **ppSurface, 
                                                HANDLE    *pSharedHandle);
 
+
+typedef HRESULT WINAPI (*D3DCB_CREATESURFACETFN) (IUnknown  *pDevice,
+                                               UINT       Width, 
+                                               UINT       Height,
+                                               D3DFORMAT Format,
+                                               DWORD      Usage,
+                                               D3DPOOL    Pool,              
+                                               UINT       Level,
+                                               IWineD3DSurface **ppSurface, 
+                                               HANDLE   * pSharedHandle);       
+
 typedef HRESULT WINAPI (*D3DCB_CREATEDEPTHSTENCILSURFACEFN) (IUnknown *pDevice,
                                                UINT       Width, 
                                                UINT       Height, 
@@ -202,9 +208,11 @@
                                                
 typedef HRESULT WINAPI (*D3DCB_CREATEADDITIONALSWAPCHAIN) (IUnknown *pDevice,
                                                WINED3DPRESENT_PARAMETERS *pPresentationParameters,
-                                               void **pSwapChain
+                                                            IWineD3DSwapChain** pSwapChain
                                                );   
 
+
+
 /*****************************************************************************
  * IWineD3D interface 
  */
@@ -231,7 +239,7 @@
     STDMETHOD(CheckDeviceFormat)(THIS_ UINT  Adapter, D3DDEVTYPE  DeviceType, WINED3DFORMAT  AdapterFormat, DWORD  Usage, D3DRESOURCETYPE  RType, WINED3DFORMAT  CheckFormat) PURE;
     STDMETHOD(CheckDeviceFormatConversion)(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, WINED3DFORMAT SourceFormat, WINED3DFORMAT TargetFormat) PURE;
     STDMETHOD(GetDeviceCaps)(THIS_ UINT  Adapter, D3DDEVTYPE  DeviceType, WINED3DCAPS *pCaps) PURE;
-    STDMETHOD(CreateDevice)(THIS_ UINT  Adapter, D3DDEVTYPE  DeviceType,HWND  hFocusWindow, DWORD  BehaviorFlags, WINED3DPRESENT_PARAMETERS * pPresentationParameters, IWineD3DDevice ** ppReturnedDeviceInterface, IUnknown *parent, D3DCB_CREATERENDERTARGETFN pFn) PURE;
+    STDMETHOD(CreateDevice)(THIS_ UINT  Adapter, D3DDEVTYPE  DeviceType,HWND  hFocusWindow, DWORD  BehaviorFlags, WINED3DPRESENT_PARAMETERS * pPresentationParameters, IWineD3DDevice ** ppReturnedDeviceInterface, IUnknown *parent, D3DCB_CREATERENDERTARGETFN pFn, D3DCB_CREATEDEPTHSTENCILSURFACEFN pFn2, D3DCB_CREATEADDITIONALSWAPCHAIN pFn3) PURE;
 };
 #undef INTERFACE
 
@@ -255,12 +263,13 @@
 #define IWineD3D_CheckDeviceFormat(p,a,b,c,d,e,f)         (p)->lpVtbl->CheckDeviceFormat(p,a,b,c,d,e,f)
 #define IWineD3D_CheckDeviceFormatConversion(p,a,b,c,d)   (p)->lpVtbl->CheckDeviceFormatConversion(p,a,b,c,d)
 #define IWineD3D_GetDeviceCaps(p,a,b,c)                   (p)->lpVtbl->GetDeviceCaps(p,a,b,c)
-#define IWineD3D_CreateDevice(p,a,b,c,d,e,f,g,h)          (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f,g,h)
+#define IWineD3D_CreateDevice(p,a,b,c,d,e,f,g,h,j,k)       (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f,g,h,j,k)
 #endif
 
 /* Define the main WineD3D entrypoint */
 IWineD3D* WINAPI WineDirect3DCreate(UINT SDKVersion, UINT dxVersion, IUnknown *parent);
 
+
 /*****************************************************************************
  * IWineD3DDevice interface 
  */
@@ -277,12 +286,12 @@
     STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DIndexBuffer** ppIndexBuffer, HANDLE* pSharedHandle, IUnknown *parent) PURE;
     STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type, IWineD3DStateBlock **ppStateBlock, IUnknown *parent) PURE;
     STDMETHOD(CreateSurface)(THIS_ UINT Width, UINT Height, WINED3DFORMAT Format,  BOOL Lockable, BOOL Discard, UINT Level,  IWineD3DSurface** ppSurface, D3DRESOURCETYPE Type, DWORD Usage, D3DPOOL Pool, D3DMULTISAMPLE_TYPE MultiSample ,DWORD MultisampleQuality,  HANDLE* pSharedHandle, IUnknown *parent) PURE;    
-    STDMETHOD(CreateTexture)(THIS_ UINT Width, UINT Height, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DTexture** ppTexture, HANDLE* pSharedHandle, IUnknown *parent, D3DCB_CREATESURFACEFN pFn) PURE;
-    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DVolumeTexture** ppVolumeTexture, HANDLE* pSharedHandle, IUnknown *parent, D3DCB_CREATEVOLUMEFN pFn) PURE;
+    STDMETHOD(CreateTexture)(THIS_ UINT Width, UINT Height, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DTexture** ppTexture, HANDLE* pSharedHandle, IUnknown *pParent, D3DCB_CREATESURFACEFN pFn) PURE;
+    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DVolumeTexture** ppVolumeTexture, HANDLE* pSharedHandle, IUnknown *pParent, D3DCB_CREATEVOLUMEFN pFn) PURE;
     STDMETHOD(CreateVolume)(THIS_ UINT Width, UINT Height, UINT Depth, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DVolume** ppVolumeTexture, HANDLE* pSharedHandle, IUnknown *parent) PURE;
-    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DCubeTexture** ppCubeTexture, HANDLE* pSharedHandle, IUnknown *parent, D3DCB_CREATESURFACEFN pFn) PURE;
+    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength, UINT Levels, DWORD Usage, WINED3DFORMAT Format, D3DPOOL Pool, IWineD3DCubeTexture** ppTexture, HANDLE* pSharedHandle, IUnknown *parent, D3DCB_CREATESURFACEFN pFn) PURE;
     STDMETHOD(CreateQuery)(THIS_ WINED3DQUERYTYPE Type, IWineD3DQuery **ppQuery, IUnknown *pParent);
-    STDMETHOD(CreateAdditionalSwapChain)(THIS_ WINED3DPRESENT_PARAMETERS* pPresentationParameters, void** pSwapChain, IUnknown* pParent, D3DCB_CREATERENDERTARGETFN pFn, D3DCB_CREATEDEPTHSTENCILSURFACEFN pFn2);
+    STDMETHOD(CreateAdditionalSwapChain)(THIS_ WINED3DPRESENT_PARAMETERS* pPresentationParameters, IWineD3DSwapChain** pSwapChain, IUnknown* pParent, D3DCB_CREATERENDERTARGETFN pFn, D3DCB_CREATEDEPTHSTENCILSURFACEFN pFn2);
     STDMETHOD(CreateVertexDeclaration)(THIS_ CONST VOID* pDeclaration, IWineD3DVertexDeclaration** ppDecl, IUnknown* pParent) PURE;
     STDMETHOD(CreateVertexShader)(THIS_ CONST DWORD* pFunction, IWineD3DVertexShader** ppShader, IUnknown *pParent) PURE;
     STDMETHOD(CreatePixelShader)(THIS_ CONST DWORD* pFunction, IWineD3DPixelShader** ppShader, IUnknown *pParent) PURE;
@@ -295,7 +304,7 @@
     STDMETHOD(GetDisplayMode)(THIS_ UINT iSwapChain, D3DDISPLAYMODE* pMode) PURE;
     STDMETHOD_(UINT, GetNumberOfSwapChains)(THIS) PURE;
     STDMETHOD(GetRasterStatus)(THIS_ UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus) PURE;
-    STDMETHOD(GetSwapChain)(THIS_ UINT iSwapChain, void** pSwapChain) PURE;
+    STDMETHOD(GetSwapChain)(THIS_ UINT iSwapChain, IWineD3DSwapChain** pSwapChain) PURE;
     STDMETHOD(Reset)(THIS_ WINED3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
     STDMETHOD(SetDialogBoxMode)(THIS_ BOOL bEnableDialogs) PURE;
     STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot, UINT YHotSpot, IWineD3DSurface* pCursorBitmap) PURE;
@@ -388,9 +397,14 @@
     STDMETHOD(StretchRect)(THIS_ IWineD3DSurface* pSourceSurface, CONST RECT* pSourceRect, IWineD3DSurface* pDestinationSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) PURE;
     STDMETHOD(GetRenderTargetData)(THIS_ IWineD3DSurface* pRenderTarget, IWineD3DSurface* pSurface) PURE;
     STDMETHOD(GetFrontBufferData)(THIS_ UINT iSwapChain,IWineD3DSurface* pSurface) PURE;    
-    /*** Internal use IWineD3Device methods ***/
+    /*** Internal use IWineD3DDevice methods ***/
     STDMETHOD_(void, SetupTextureStates)(THIS_ DWORD Stage, DWORD Flags);
+    #if 0 /* TODO: part of the interface cleanup work */
+    STDMETHOD_(void, ResourceReleased)(THIS_ IWineD3DResource *resource);
+    STDMETHOD_(void, SwapChainReleased)(THIS_ IWineD3DSwapChain *swapChain);    
+    #endif    
 };
+
 #undef INTERFACE
 
 #if !defined(__cplusplus) || defined(CINTERFACE)
@@ -516,6 +530,10 @@
 #define IWineD3DDevice_GetRenderTargetData(p,a,b)               (p)->lpVtbl->GetRenderTargetData(p,a,b)
 #define IWineD3DDevice_GetFrontBufferData(p,a,b)                (p)->lpVtbl->GetFrontBufferData(p,a,b)
 #define IWineD3DDevice_SetupTextureStates(p,a,b)                (p)->lpVtbl->SetupTextureStates(p,a,b)
+#if 0 /* TODO: part of the interface cleanup work */
+#define IWineD3DDevice_ResourceReleased(p,a)                    (p)->lpVtbl->ResourceReleased(p,a)
+#define IWineD3DDevice_SwapChainReleased(p,a)                   (p)->lpVtbl->SwapChainReleased(p,a)
+#endif
 #endif
 
 /*****************************************************************************
@@ -742,7 +760,7 @@
     STDMETHOD_(DWORD,GetPriority)(THIS) PURE;
     STDMETHOD_(void,PreLoad)(THIS) PURE;
     STDMETHOD_(D3DRESOURCETYPE,GetType)(THIS) PURE;
-    /*** IWineD3DBaseTexture methods ***/
+    /*** IWineD3DTexture methods ***/
     STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
     STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
     STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
@@ -778,7 +796,7 @@
 #define IWineD3DTexture_GetPriority(p)             (p)->lpVtbl->GetPriority(p)
 #define IWineD3DTexture_PreLoad(p)                 (p)->lpVtbl->PreLoad(p)
 #define IWineD3DTexture_GetType(p)                 (p)->lpVtbl->GetType(p)
-/*** IWineD3DTexture methods: IWineD3DBaseTexture ***/
+/*** IWineD3DTexture methods: IWineD3DTexture ***/
 #define IWineD3DTexture_SetLOD(p,a)                (p)->lpVtbl->SetLOD(p,a)
 #define IWineD3DTexture_GetLOD(p)                  (p)->lpVtbl->GetLOD(p)
 #define IWineD3DTexture_GetLevelCount(p)           (p)->lpVtbl->GetLevelCount(p)
@@ -798,11 +816,12 @@
 #define IWineD3DTexture_AddDirtyRect(p,a)          (p)->lpVtbl->AddDirtyRect(p,a)
 #endif
 
+
 /*****************************************************************************
  * IWineD3DCubeTexture interface
  */
 #define INTERFACE IWineD3DCubeTexture
-DECLARE_INTERFACE_(IWineD3DCubeTexture,IWineD3DBaseTexture)
+DECLARE_INTERFACE_(IWineD3DCubeTexture,IWineD3DTexture)
 {
     /*** IUnknown methods ***/
     STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
@@ -818,7 +837,7 @@
     STDMETHOD_(DWORD,GetPriority)(THIS) PURE;
     STDMETHOD_(void,PreLoad)(THIS) PURE;
     STDMETHOD_(D3DRESOURCETYPE,GetType)(THIS) PURE;
-    /*** IWineD3DBaseTexture methods ***/
+    /*** IWineD3DTexture methods ***/
     STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
     STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
     STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
@@ -854,7 +873,7 @@
 #define IWineD3DCubeTexture_GetPriority(p)             (p)->lpVtbl->GetPriority(p)
 #define IWineD3DCubeTexture_PreLoad(p)                 (p)->lpVtbl->PreLoad(p)
 #define IWineD3DCubeTexture_GetType(p)                 (p)->lpVtbl->GetType(p)
-/*** IWineD3DCubeTexture methods: IWineD3DBaseTexture ***/
+/*** IWineD3DCubeTexture methods: IWineD3DTexture ***/
 #define IWineD3DCubeTexture_SetLOD(p,a)                (p)->lpVtbl->SetLOD(p,a)
 #define IWineD3DCubeTexture_GetLOD(p)                  (p)->lpVtbl->GetLOD(p)
 #define IWineD3DCubeTexture_GetLevelCount(p)           (p)->lpVtbl->GetLevelCount(p)
@@ -879,7 +898,7 @@
  * IWineD3DVolumeTexture interface
  */
 #define INTERFACE IWineD3DVolumeTexture
-DECLARE_INTERFACE_(IWineD3DVolumeTexture,IWineD3DBaseTexture)
+DECLARE_INTERFACE_(IWineD3DVolumeTexture,IWineD3DTexture)
 {
     /*** IUnknown methods ***/
     STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
@@ -895,7 +914,7 @@
     STDMETHOD_(DWORD,GetPriority)(THIS) PURE;
     STDMETHOD_(void,PreLoad)(THIS) PURE;
     STDMETHOD_(D3DRESOURCETYPE,GetType)(THIS) PURE;
-    /*** IWineD3DBaseTexture methods ***/
+    /*** IWineD3DTexture methods ***/
     STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
     STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
     STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
@@ -921,7 +940,7 @@
 #define IWineD3DVolumeTexture_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
 #define IWineD3DVolumeTexture_AddRef(p)                  (p)->lpVtbl->AddRef(p)
 #define IWineD3DVolumeTexture_Release(p)                 (p)->lpVtbl->Release(p)
-/*** IWineD3DVolumeTexture methods: IWineD3DResource ***/
+/*** IWineD3DVolumeTexture methods: IDirect3DResource9 ***/
 #define IWineD3DVolumeTexture_GetParent(p,a)             (p)->lpVtbl->GetParent(p,a)
 #define IWineD3DVolumeTexture_GetDevice(p,a)             (p)->lpVtbl->GetDevice(p,a)
 #define IWineD3DVolumeTexture_SetPrivateData(p,a,b,c,d)  (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
@@ -931,7 +950,7 @@
 #define IWineD3DVolumeTexture_GetPriority(p)             (p)->lpVtbl->GetPriority(p)
 #define IWineD3DVolumeTexture_PreLoad(p)                 (p)->lpVtbl->PreLoad(p)
 #define IWineD3DVolumeTexture_GetType(p)                 (p)->lpVtbl->GetType(p)
-/*** IWineD3DVolumeTexture methods: IWineD3DBaseTexture ***/
+/*** IWineD3DVolumeTexture methods: IWineD3DTexture ***/
 #define IWineD3DVolumeTexture_SetLOD(p,a)                (p)->lpVtbl->SetLOD(p,a)
 #define IWineD3DVolumeTexture_GetLOD(p)                  (p)->lpVtbl->GetLOD(p)
 #define IWineD3DVolumeTexture_GetLevelCount(p)           (p)->lpVtbl->GetLevelCount(p)
@@ -951,6 +970,8 @@
 #define IWineD3DVolumeTexture_AddDirtyBox(p,a)           (p)->lpVtbl->AddDirtyBox(p,a)
 #endif
 
+
+
 /*****************************************************************************
  * IWineD3DSurface interface
  */
@@ -1089,6 +1110,7 @@
     STDMETHOD_(ULONG,AddRef)(THIS) PURE;
     STDMETHOD_(ULONG,Release)(THIS) PURE;
     /*** IWineD3DVertexDeclaration methods ***/
+    STDMETHOD(GetParent)(THIS_ IUnknown **pParent) PURE;
     STDMETHOD(GetDevice)(THIS_ IWineD3DDevice ** ppDevice) PURE;
     STDMETHOD(GetDeclaration)(THIS_ UINT iDeclVersion, VOID*, DWORD* pSize) PURE;
 };
@@ -1100,6 +1122,7 @@
 #define IWineD3DVertexDeclaration_AddRef(p)                  (p)->lpVtbl->AddRef(p)
 #define IWineD3DVertexDeclaration_Release(p)                 (p)->lpVtbl->Release(p)
 /*** IWineD3DVertexDeclaration methods ***/
+#define IWineD3DVertexDeclaration_GetParent(p,a)             (p)->lpVtbl->GetParent(p,a)
 #define IWineD3DVertexDeclaration_GetDevice(p,a)             (p)->lpVtbl->GetDevice(p,a)
 #define IWineD3DVertexDeclaration_GetDeclaration(p,a,b,c)    (p)->lpVtbl->GetDeclaration(p,a,b,c)
 #endif
@@ -1116,6 +1139,9 @@
     STDMETHOD_(ULONG,Release)(THIS) PURE;
     /*** IWineD3DStateBlock methods ***/
     STDMETHOD(GetParent)(THIS_ IUnknown **pParent) PURE;
+    STDMETHOD(GetDevice)(THIS_ IWineD3DDevice **pDevice) PURE;
+    STDMETHOD(Capture)(THIS) PURE;
+    STDMETHOD(Apply)(THIS) PURE;
     STDMETHOD(InitStartupStateBlock)(THIS) PURE;
 };
 #undef INTERFACE
@@ -1127,6 +1153,9 @@
 #define IWineD3DStateBlock_Release(p)                           (p)->lpVtbl->Release(p)
 /*** IWineD3DStateBlock methods ***/
 #define IWineD3DStateBlock_GetParent(p,a)                       (p)->lpVtbl->GetParent(p,a)
+#define IWineD3DStateBlock_GetDevice(p,a)                       (p)->lpVtbl->GetDevice(p,a)      
+#define IWineD3DStateBlock_Capture(p)                           (p)->lpVtbl->Capture(p)
+#define IWineD3DStateBlock_Apply(p)                             (p)->lpVtbl->Apply(p)
 #define IWineD3DStateBlock_InitStartupStateBlock(p)             (p)->lpVtbl->InitStartupStateBlock(p)
 #endif
 
@@ -1167,6 +1196,54 @@
 #endif
 
 /*****************************************************************************
+ * IWineD3DSwapChain interface
+ * TODO: add gamma-ramp setting functions to make life easier
+ * (There kinda missing from Microsofts DirectX!)
+ */
+#define INTERFACE IWineD3DSwapChain
+DECLARE_INTERFACE_(IWineD3DSwapChain,IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD_(HRESULT,QueryInterface)(THIS_ REFIID riid, void** ppvObject) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+    /*** IDirect3DSwapChain9 methods ***/
+    STDMETHOD(GetParent)(THIS_ IUnknown **pParent) PURE;
+    STDMETHOD(GetDevice)(THIS_ IWineD3DDevice** ppDevice) PURE;
+    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion, DWORD dwFlags) PURE;
+    STDMETHOD(GetFrontBufferData)(THIS_ IWineD3DSurface* pDestSurface) PURE;
+    STDMETHOD(GetBackBuffer)(THIS_ UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IWineD3DSurface** ppBackBuffer) PURE;
+    STDMETHOD(GetRasterStatus)(THIS_ D3DRASTER_STATUS* pRasterStatus) PURE;
+    STDMETHOD(GetDisplayMode)(THIS_ D3DDISPLAYMODE* pMode) PURE;
+    STDMETHOD(GetPresentParameters)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
+    STDMETHOD(SetGammaRamp)(THIS_ DWORD Flags, const D3DGAMMARAMP *pRamp) PURE;
+    STDMETHOD(GetGammaRamp)(THIS_ D3DGAMMARAMP *pRamp) PURE;
+};
+#undef INTERFACE
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+/*** IUnknown methods ***/
+#define IWineD3DSwapChain_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IWineD3DSwapChain_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IWineD3DSwapChain_Release(p)                   (p)->lpVtbl->Release(p)
+/*** IWineD3DSwapChain methods ***/
+
+#define IWineD3DSwapChain_GetParent(p,a)               (p)->lpVtbl->GetParent(p,a)
+#define IWineD3DSwapChain_GetDevice(p,a)               (p)->lpVtbl->GetDevice(p,a)
+#define IWineD3DSwapChain_Present(p,a,b,c,d,e)         (p)->lpVtbl->Present(p,a,b,c,d,e)
+#define IWineD3DSwapChain_GetFrontBufferData(p,a)      (p)->lpVtbl->GetFrontBufferData(p,a)
+#define IWineD3DSwapChain_GetBackBuffer(p,a,b,c)       (p)->lpVtbl->GetBackBuffer(p,a,b,c)
+#define IWineD3DSwapChain_GetRasterStatus(p,a)         (p)->lpVtbl->GetRasterStatus(p,a)
+#define IWineD3DSwapChain_GetDisplayMode(p,a)          (p)->lpVtbl->GetDisplayMode(p,a)
+#define IWineD3DSwapChain_GetPresentParameters(p,a)    (p)->lpVtbl->GetPresentParameters(p,a)
+#define IWineD3DSwapChain_SetGammaRamp(p,a,b)          (p)->lpVtbl->SetGammaRamp(p,a,b)
+#define IWineD3DSwapChain_GetGammaRamp(p,a)            (p)->lpVtbl->GetGammaRamp(p,a)
+#endif
+
+
+
+
+/*****************************************************************************
  * IWineD3DVertexShader interface 
  */
 #define INTERFACE IWineD3DVertexShader
diff -urN wine.20050419/include/wine/wined3d_types.h wine.20050419.dx9/include/wine/wined3d_types.h
--- wine.20050419/include/wine/wined3d_types.h	2005-03-03 06:57:15.000000000 -0700
+++ wine.20050419.dx9/include/wine/wined3d_types.h	2005-04-20 01:52:56.000000000 -0600
@@ -105,6 +105,8 @@
   WINED3DSHADERVECTOR oDepth;
 } WINEPSHADEROUTPUTDATA;
 
+
+
 /*****************************************************************************
  * WineD3D Structures to be used when d3d8 and d3d9 are incompatible
  */
@@ -537,5 +539,119 @@
 } WINED3DDEVINFO_VCACHE;
 
 
+/*
+ * The d3dcaps9 structure
+ */
+
+ 
+typedef struct _WINED3DVSHADERCAPS2_0 {
+  DWORD  Caps;
+  INT    DynamicFlowControlDepth;
+  INT    NumTemps;
+  INT    StaticFlowControlDepth;
+} WINED3DVSHADERCAPS2_0;
+
+typedef struct _WINED3DPSHADERCAPS2_0 {
+  DWORD  Caps;
+  INT    DynamicFlowControlDepth;
+  INT    NumTemps;
+  INT    StaticFlowControlDepth;
+  INT    NumInstructionSlots;
+} WINED3DPSHADERCAPS2_0;
+
+typedef struct _WINED3DCAPS {
+  D3DDEVTYPE          *DeviceType;
+  UINT                *AdapterOrdinal;
+  
+  DWORD               *Caps;
+  DWORD               *Caps2;
+  DWORD               *Caps3;
+  DWORD               *PresentationIntervals;
+  
+  DWORD               *CursorCaps;
+  
+  DWORD               *DevCaps;
+  
+  DWORD               *PrimitiveMiscCaps;
+  DWORD               *RasterCaps;
+  DWORD               *ZCmpCaps;
+  DWORD               *SrcBlendCaps;
+  DWORD               *DestBlendCaps;
+  DWORD               *AlphaCmpCaps;
+  DWORD               *ShadeCaps;
+  DWORD               *TextureCaps;
+  DWORD               *TextureFilterCaps;
+  DWORD               *CubeTextureFilterCaps;
+  DWORD               *VolumeTextureFilterCaps;
+  DWORD               *TextureAddressCaps;
+  DWORD               *VolumeTextureAddressCaps;
+  
+  DWORD               *LineCaps;
+  
+  DWORD               *MaxTextureWidth;
+  DWORD               *MaxTextureHeight;
+  DWORD               *MaxVolumeExtent;
+  
+  DWORD               *MaxTextureRepeat;
+  DWORD               *MaxTextureAspectRatio;
+  DWORD               *MaxAnisotropy;
+  float               *MaxVertexW;
+  
+  float               *GuardBandLeft;
+  float               *GuardBandTop;
+  float               *GuardBandRight;
+  float               *GuardBandBottom;
+  
+  float               *ExtentsAdjust;
+  DWORD               *StencilCaps;
+  
+  DWORD               *FVFCaps;
+  DWORD               *TextureOpCaps;
+  DWORD               *MaxTextureBlendStages;
+  DWORD               *MaxSimultaneousTextures;
+  
+  DWORD               *VertexProcessingCaps;
+  DWORD               *MaxActiveLights;
+  DWORD               *MaxUserClipPlanes;
+  DWORD               *MaxVertexBlendMatrices;
+  DWORD               *MaxVertexBlendMatrixIndex;
+  
+  float               *MaxPointSize;
+  
+  DWORD               *MaxPrimitiveCount;
+  DWORD               *MaxVertexIndex;
+  DWORD               *MaxStreams;
+  DWORD               *MaxStreamStride;
+  
+  DWORD               *VertexShaderVersion;
+  DWORD               *MaxVertexShaderConst;
+  
+  DWORD               *PixelShaderVersion;
+  float               *PixelShader1xMaxValue;
+
+  /* DX 9 */
+  DWORD               *DevCaps2;
+
+  float               *MaxNpatchTessellationLevel;
+  DWORD               *Reserved5; /*undocumented*/
+
+  UINT                *MasterAdapterOrdinal;   
+  UINT                *AdapterOrdinalInGroup;  
+  UINT                *NumberOfAdaptersInGroup;
+  DWORD               *DeclTypes;              
+  DWORD               *NumSimultaneousRTs;     
+  DWORD               *StretchRectFilterCaps;  
+  WINED3DVSHADERCAPS2_0   *VS20Caps;
+  WINED3DPSHADERCAPS2_0   *PS20Caps;
+  DWORD               *VertexTextureFilterCaps;
+  DWORD               *MaxVShaderInstructionsExecuted;
+  DWORD               *MaxPShaderInstructionsExecuted;
+  DWORD               *MaxVertexShader30InstructionSlots; 
+  DWORD               *MaxPixelShader30InstructionSlots;
+  DWORD               *Reserved2;/* Not in the microsoft headers but documented */
+  DWORD               *Reserved3;
+
+} WINED3DCAPS;
+
 
 #endif
